<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Firewall Builder: Firewall Access Policy Rulesets, Part 2 | HowtoForge - Linux Howtos and Tutorials</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<style type="text/css">
<!--
.command {
    padding: 1em;
    border: 1px dashed #2f6fab;
    color: black;
    background-color: #f9f9f9;
    line-height: 1.1em;
        font-family: Courier New, Courier, mono;
        font-size: 12px;
        font-style: italic;
}

.system {
    color: black;
        font-family: Courier New, Courier, mono;
        font-size: 12px;
        font-style: italic;
}

.highlight {
    color: #FF0000;
        font-family: Georgia, "Times New Roman", Times, serif;
        font-size: 12px;
        text-decoration: underline;
}
-->
</style>
</head>

<body>
  

  <h1>Firewall Access Policy Rulesets, Part 2</h1>


  <table border=0>
    <tr>
      <td><img src="http://www.fwbuilder.org/images/icon_128x128.png" height="128" width="128" /></td>
      <td>Author: vadim@fwbuilder.org<br/>
        <a href="http://www.fwbuilder.org">http://www.fwbuilder.org</a>
      </td>
    </tr>
  </table>


  <p>
    This article continues the series of articles on Firewall Builder,
    a graphical firewall configuration and management tool that
    supports many Open Source firewall platforms as well as Cisco IOS
    access lists and Cisco ASA (PIX).  Firewall Builder was introduced
    on this site earlier with articles

    <a href="http://www.howtoforge.com/getting-started-with-firewall-builder">
    Getting Started With Firewall Builder</a>, 

    <a href="http://www.howtoforge.com/using-firewall-object-in-firewall-builder">
      Using Firewall Object In Firewall Builder</a>.

    <a href="http://www.howtoforge.com/firewall-access-policy-rulesets-part-1">
      Firewall Access Policy Rulesets, Part 1</a>.
  </p>

  <p>
    This article demonstrates several examples of <strong>Access
     Policy rules</strong> and generated configurations
     for <strong>iptables</strong>, <strong>PF</strong>
     and <strong>Cisco PIX</strong>.
  </p>

  <p>
    More information on Firewall Builder, pre-built binary packages
    and source code, documentation can be found on
    <a href="http://www.fwbuilder.org/">
    the project web site at http://www.fwbuilder.org/</a>. Numerous
    <a href="http://www.fwbuilder.org/docs/users_guide/book1.htm">
    examples of iptables, pf and other rules are available
    in <b>Firewall Builder Users Guide</b></a>.
    Follow <a href="http://blog.fwbuilder.org/"> Firewall Builder
    Project Blog</a> for announcements and articles on all aspects of
    using Firewall Builder.
  </p>

  
  <h2>Firewall object used in examples</h2>

  <p>
    We start with the firewall object that looks like shown in the
    next screenshot. This firewall has three interfaces: eth0
    (outside), eth1 (inside) and loopback.  All addresses are assigned
    statically. Address of the inside interface "eth1" is
    192.168.1.1/24, we also have network object with name
    "net-192.168.1.0" that defines internal network 192.168.1.0/24.
  </p>

  <p>
    To illustrate generated configurations for platforms other
    than iptables/Linux in this chapter, I am using similarly
    configured firewall objects with different platform and host
    OS settings.
  </p>

  <img src="policy-examples-fw-linux.png" />

  <!-- ********************************************************* -->

  <h2>Permit internal LAN to connect to the Internet</h2>

  <p>
    In this example we create a rule to permit our internal LAN to
    connect to the Internet using any protocol. Network object
    "net-192.168.1.0" should be configured with the IP address and
    netmask corresponding to those used on the internal network
    behind the firewall. Since internal LAN in this example uses
    private address block, the rules described here are
    insufficient and should be accompanied with corresponding NAT
    (Network Address Translation) rules. We discuss NAT rules in
    the next chapter.
  </p>

  <img src="policy-1-3.png" />

  <p>
    Here are the iptables command generated for this example:
  </p>

  <p class="command">
# Rule 0 (global)<br>
# <br>
$IPTABLES -A INPUT  -s 192.168.1.0/24   -m state --state NEW  -j ACCEPT <br>
$IPTABLES -A OUTPUT  -s 192.168.1.0/24   -m state --state NEW  -j ACCEPT <br>
$IPTABLES -A FORWARD  -s 192.168.1.0/24   -m state --state NEW  -j ACCEPT <br>
# <br>
# Rule 1 (global)<br>
# <br>
$IPTABLES -N RULE_1<br>
$IPTABLES -A OUTPUT  -j RULE_1 <br>
$IPTABLES -A INPUT  -j RULE_1 <br>
$IPTABLES -A FORWARD  -j RULE_1 <br>
$IPTABLES -A RULE_1  -j LOG  --log-level info --log-prefix "RULE 1 -- DENY "<br>
$IPTABLES -A RULE_1  -j DROP <br>
      </p>

  <p>
    The first rule was placed in all three
    chains: <emphasis>INPUT</emphasis>, <emphasis>OUTPUT</emphasis>
    and <emphasis>FORWARD</emphasis> because option "Assume
    firewall is part of any" was turned on in the "Advanced"
    settings dialog of this firewall object. This option directs
    policy compiler to assume that
    object <emphasis>"Any"</emphasis> matches firewall itself as
    well. In other words, using "Any" in Destination of the rule
    is equivalent to using a combination of any address and the
    firewall. To match packets headed for the firewall, the rule
    should be placed in the <emphasis>INPUT</emphasis> chain.
    Also, network object within address 192.168.1.0/24 matches one
    of the interfaces of the firewall that has address on this
    network. This means, this rule should also match packets sent
    by the firewall itself provided source address is that of the
    interface on the internal net. This requires iptables command
    in the <emphasis>OUTPUT</emphasis> chain. And finally,
    iptables command in the <emphasis>FORWARD</emphasis> chain
    matches packets sent by machines on the internal net.
  </p>

  <p>
    Rule #1 catches all other packets going to, from and across
    the firewall and logs and drops them.
  </p>

  <p>
    Here is the PF configuration created for the same rules:
  </p>

  <p class="command">
# Rule  0 (global)<br>
# <br>
pass  quick inet  from 192.168.1.0/24  to any keep state <br>
# <br>
# Rule  1 (global)<br>
# <br>
block  log  quick inet  from any  to any <br>
  </p>
      
  <p>
    Firewall Builder always generates PF configuration using
    its <emphasis>"quick"</emphasis> clause to switch to the
    first-match mode. In this PF configuration example, the first
    rule permits packets with source address on the 192.168.1.0/24
    network and stops processing. The second rule will only
    inspect packets not matched by the first rule.
  </p>


  <p>
    Here is the fragment of the PIX config generated for the same
    combination of rules:
  </p>

  <p class="command">
! Rule  0 (global)<br>
! <br>
access-list inside_acl_in  remark 0 (global)<br>
access-list inside_acl_in permit ip 192.168.1.0 255.255.255.0 any <br>
! <br>
! Rule  1 (global)<br>
! <br>
access-list outside_acl_in  remark 1 (global)<br>
access-list outside_acl_in deny   ip any any log 4 interval 300 <br>
access-list dmz50_acl_in  remark 1 (global)<br>
access-list dmz50_acl_in deny   ip any any log 4 interval 300 <br>
access-list inside_acl_in  remark 1 (global)<br>
access-list inside_acl_in deny   ip any any log 4 interval 300 <br>
<br>
<br>
access-group dmz50_acl_in in interface dmz50<br>
access-group inside_acl_in in interface inside<br>
access-group outside_acl_in in interface outside<br>
  </p>

  <p>
    Since source address in the rule #0 is limited to the internal
    network, policy compiler was able to determine which interface
    the access list command should be associated with and added it
    only to the ACL <emphasis>"inside_acl_in"</emphasis>.
  </p>

  <p>
    The <emphasis>"access-group"</emphasis> commands are actually
    located at the very bottom of the generated script, after all
    other <emphasis>access-list</emphasis> commands. It is shown
    right next to the ACL rules here for presentation.
  </p>
  

  <!-- ********************************************************* -->

  <h2>Letting certain protocols through, while blocking everything
      else</h2>

  <p>This is one of the simplest, most basic tasks you may want your
    firewall to do - block all the traffic while letting certain protocols
    through. Let's assume that we have a network consisting of just the
    firewall "firewall1" and a few hosts behind it. We want to let SMTP 
    through to the mail server from the Internet, and block
    everything else. All we need to do is put the following rules in the
    Global Policy:</p>

  <img src="policy-1.png" />

  <p>
    Rule #0 allows SMTP through to the server, while rule #1
    blocks and logs everything else. It is worth mentioning that
    this policy also blocks all the access to firewall itself,
    including access to it from internal hosts.
  </p>

  <p>
    We do not need any additional rules to take care of "reply"
    packets coming back from the server to clients because our
    underlying firewall software supports stateful inspection and
    "understands" that such packets should be let through.
  </p>

  <p>
    Here is iptables script generated for these two simple rules:
  </p>

  <p class="command">
$IPTABLES -A INPUT   -m state --state ESTABLISHED,RELATED -j ACCEPT<br>
$IPTABLES -A OUTPUT  -m state --state ESTABLISHED,RELATED -j ACCEPT<br>
$IPTABLES -A FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPT<br>
<br>
# Rule 0 (global)<br>
# <br>
$IPTABLES -A OUTPUT -p tcp -m tcp  -d 192.168.1.100  \<br>
    --dport 25  -m state --state NEW  -j ACCEPT <br>
$IPTABLES -A FORWARD -p tcp -m tcp  -d 192.168.1.100 \<br>
    --dport 25  -m state --state NEW  -j ACCEPT <br>
# <br>
# Rule 1 (global)<br>
# <br>
$IPTABLES -N RULE_1<br>
$IPTABLES -A OUTPUT  -m state --state NEW  -j RULE_1 <br>
$IPTABLES -A INPUT  -m state --state NEW  -j RULE_1 <br>
$IPTABLES -A FORWARD  -m state --state NEW  -j RULE_1 <br>
$IPTABLES -A RULE_1  -j LOG  --log-level info --log-prefix "RULE 1 -- DENY "<br>
$IPTABLES -A RULE_1  -j DROP <br>
  </p>

  <p>
    Rules that utilize module <emphasis>state</emphasis> and match
    states <emphasis>ESTABLISHED,RELATED</emphasis> permit reply
    packets, such as TCP ACKs, UDP reply packets and ICMP messages
    associated with known sessions. These rules are automatically
    added at the beginning of generated iptables script if the
    option "Accept ESTABLISHED and RELATED packets before the
    first rule" is turned on in the firewall object "Advanced"
    settings dialog. If you turn this option off, the rule will
    not be added automatically and you'll have to add it
    yourself. You can use Custom Service
    object <emphasis>ESTABLISHED</emphasis> you can find in
    the <emphasis>Standard</emphasis> objects library to do this.
  </p>

  <p>
    Generated iptables rules were placed in
    both <emphasis>OUTPUT</emphasis>
    and <emphasis>FORWARD</emphasis> chains because option "Assume
    firewall is part of any" was turned on in the "Advanced"
    settings dialog of this firewall object. This option directs
    policy compiler to assume that
    object <emphasis>"Any"</emphasis> matches firewall itself as
    well. In other words, using "Any" in Source of the rule was
    equivalent to using a combination of any address and the
    firewall. Resultant iptables commands should be placed in
    the <emphasis>OUTPUT</emphasis> chain to match packets
    generated by the firewall and <emphasis>FORWARD</emphasis> to
    match packets crossing the firewall. If you turn this option
    off, the program will only generate iptables rules in
    the <emphasis>FORWARD</emphasis> chain for this rule.
  </p>

  <p>
    Here is the code generated for PF for the same rule:
  </p>

  <p class="command">
# Rule  0 (global)<br>
# <br>
pass  quick inet proto tcp  from any  to 192.168.1.100 port 25 keep state <br>
# <br>
# Rule  1 (global)<br>
# <br>
block  log  quick inet  from any  to any <br>
  </p>

  <p>
    In PF we do not have to worry about chains and there is no
    option "Assume firewall is part of any" because there is no
    difference.
  </p>

  <p>
    Here is the code generated for PIX for the same rule:
  </p>

  <p class="command">
! Rule  0 (global)<br>
! <br>
access-list outside_acl_in  remark 0 (global)<br>
access-list outside_acl_in permit tcp any host 192.168.1.100 eq 25 <br>
access-list dmz50_acl_in  remark 0 (global)<br>
access-list dmz50_acl_in permit tcp any host 192.168.1.100 eq 25 <br>
access-list inside_acl_in  remark 0 (global)<br>
access-list inside_acl_in permit tcp any host 192.168.1.100 eq 25 <br>
! <br>
! Rule  1 (global)<br>
! <br>
access-list outside_acl_in  remark 1 (global)<br>
access-list outside_acl_in deny   ip any any log 0 interval 300 <br>
access-list dmz50_acl_in  remark 1 (global)<br>
access-list dmz50_acl_in deny   ip any any log 0 interval 300 <br>
access-list inside_acl_in  remark 1 (global)<br>
access-list inside_acl_in deny   ip any any log 0 interval 300 <br>
  </p>

  <p>
    In PIX, all access lists must be attached to interfaces of the
    firewall. Since the rule did not specify source address, the
    program has to generate access lists that would match any
    source, which means they should be attached to all interfaces
    of the firewall. Since my PIX test object has three
    interfaces: <emphasis>outside</emphasis>, <emphasis>inside</emphasis>
    and <emphasis>dmz</emphasis>, I ended up with ACL lines in
    three access lists, one for each interface.
  </p>

<!-- ********************************************************* -->

  <h2> Letting certain protocols through from specific source.</h2>

  <p>
    In this example, we look at the rule that is similar to the
    previous one, but also matches source address. This rule
    permits access to the mail server inside from mail relay on
    DMZ and from no other source. Generated rules for iptables and
    pf are very similar, they just add source address
    matching. Generated rules for PIX are different because now
    the program can intelligently pick the right access list and
    avoid generating redundant rules.
  </p>


  <img src="policy-1-2.png" />


  <p>
    Here is the code generated for iptables from this rule:
  </p>

  <p class="command">
# Rule 0 (global)<br>
# <br>
$IPTABLES -A FORWARD -p tcp -m tcp  -s 192.168.2.22   -d 192.168.1.100  \<br>
    --dport 25  -m state --state NEW  -j ACCEPT <br>
  </p>

  <p>
    Since source rule element was limited to the host on DMZ,
    generated iptables rule is placed only in the FORWARD chain
    and also matches the source using "-s" clause.
  </p>

  <p>
    Lets look at the configuration generated for PIX from the same rule:
  </p>

  <p class="command">
! Rule  0 (global)<br>
! <br>
access-list dmz50_acl_in  remark 0 (global)<br>
access-list dmz50_acl_in permit tcp host 192.168.2.22 host 192.168.1.100 eq 25 <br>
<br>
<br>
access-group dmz50_acl_in in interface dmz50<br>
access-group inside_acl_in in interface inside<br>
access-group outside_acl_in in interface outside<br>
  </p>

  <p>
    the rule was placed only in the access list attached to the
    DMZ interface because packets with source address of the host
    on DMZ can only cross this interface of the firewall, assuming
    spoofed packets are blocked by special rule, which will
    discuss below.
  </p>


<!-- ********************************************************* -->

  <h2>Interchangeable and non-interchangeable objects</h2>

  <!-- TODO: Need examples for this section -->

  <p>In the previous example we put object "mail server" into
    the Destination field of the policy rule #0 because our goal was
    to permit protocol SMTP to that host and not to any other
    one. This actually reflects general principle Firewall Builder
    is based on: put the object you want to control access for in
    the Source or Destination field of the policy rule. Two
    different objects with the same address may or may not be
    interchangeable, depending on their type and other
    parameters. One of the frequent mistakes is to create Host
    object with IP address of the firewall, then use it in the
    policy and expect Firewall Builder to build policy controlling
    access to the firewall. Unfortunately it does not always work
    that way. If you wish to control access to or from the firewall
    machine, then put Firewall object into the policy rule.</p>

  <p>Another example of two objects which may on the first
    glance represent the same thing, but in fact are not
    interchangeable, is IP service object with protocol number set
    to 1 and ICMP service object with type and code set to
    "any". Both objects might represent the same type of service,
    namely "Any ICMP message". IP protocol 1 is in fact ICMP, so one
    would expect the behaviour of the firewall to be the same
    regardless of what type of service object is used. However,
    target firewall software typically uses special syntax for
    indication of different protocols, so using proper syntax for
    ICMP protocol turns certain features on, like for example
    session state tracking and association of the ICMP packets to
    known sessions these packets might carry error messages
    for. Using just IP with protocol number 1 will most likely not
    turn these features on and therefore will lead to unexpected
    results.</p>

  <p>Interface object and its ip address are interchangeable in
    rules, provided the interface has only one address. If interface
    object has several address child objects, then using the
    interface object in a rule is equivalent to using all of its
    addresses in the same place. If interface has only one address,
    then the result will be the same whether you put interface
    object or its address in the rule. Also, using firewall object
    in the rule should yield the same policy script as if you put
    all its interfaces in the same place instead. This one comes
    with a caveat though: many firewall platforms offer special
    syntax for rules that control access to or from the firewall
    itself and fwbuilder takes advantage of this syntax, so the
    result may not look exactly the same, but should be equivalent
    in function. Some platforms, such as iptables, require using
    different chain to control access to and from
    firewall. Fwbuilder compares ip addresses used in source and
    destination of rules to addresses of all interfaces of the
    firewall and uses proper chains even if the address object in
    the rule is not the firewall object itself.
  </p>

  <p>Two objects of the same type with different names but the
    same values of all other parameters are always
    interchangeable. Using different objects to describe the same
    object may be confusing, but the final firewall policy will be
    correct. Firewall Builder leaves design of the objects up to the
    firewall administrator.</p>
<!-- ********************************************************* -->


  <h2>Anti-spoofing rules</h2>


  <p>
    Generally speaking, IP spoofing is a technique of generating
    IP packets with source address that belongs to someone
    else. Spoofing creates a danger when hosts on the LAN permit
    access to their resources and services to trusted hosts by
    checking the source IP of the packets.  Using spoofing, an
    intruder can fake the source address of his packets and make
    them look like they originated on the trusted hosts. The basic
    idea of anti-spoofing protection is to create a firewall rule
    assigned to the external interface of the firewall that
    examines source address of all packets crossing that interface
    coming from outside. If the address belongs to the internal
    network or the firewall itself, the packet is dropped.
  </p>

  <p>
    Simple anti-spoofing rule looks like shown on
    the next screenshot. Unlike the rule in the
    previous example, anti-spoofing rule requires matching of the
    interface and direction. The idea is that packets that come
    from outside must not have source addresses that match
    internal network or the firewall itself. The only way to
    distinguish packets coming from outside from those coming from
    inside is to check which interface of the firewall they cross
    and in which direction. Here the rule matches
    interface <emphasis>eth0</emphasis>, which is external, and direction
    <emphasis>inbound</emphasis>.
  </p>

  <p>
    Article <a href="http://www.howtoforge.com/using-firewall-object-in-firewall-builder">Using
    Firewall Object In Firewall Builder </a> explains how a firewall
    object and its interfaces can be created.
    Article <a href="http://www.howtoforge.com/firewall-access-policy-rulesets-part-1">
    Firewall Access Policy Rulesets, Part 1</a> explains the concept
    of direction.
  </p>

  <img src="policy-antispoof-rule-1.png" />

  <p>
    Here are the iptables commands generated for this rule:
  </p>

  <p class="command">
# Rule 0 (eth0)<br>
# <br>
# anti spoofing rule<br>
# <br>
$IPTABLES -N In_RULE_0<br>
$IPTABLES -A INPUT  -i eth0   -s 192.0.2.1   -j In_RULE_0 <br>
$IPTABLES -A INPUT  -i eth0   -s 192.168.1.1   -j In_RULE_0 <br>
$IPTABLES -A INPUT  -i eth0   -s 192.168.1.0/24   -j In_RULE_0 <br>
$IPTABLES -A FORWARD  -i eth0   -s 192.0.2.1   -j In_RULE_0 <br>
$IPTABLES -A FORWARD  -i eth0   -s 192.168.1.1   -j In_RULE_0 <br>
$IPTABLES -A FORWARD  -i eth0   -s 192.168.1.0/24   -j In_RULE_0 <br>
$IPTABLES -A In_RULE_0  -j LOG  --log-level info --log-prefix "RULE 0 -- DENY "<br>
$IPTABLES -A In_RULE_0  -j DROP <br>
  </p>

  <p>
    Iptables commands were placed in INPUT and FORWARD chains to
    match both packets that are headed for the firewall and
    through the firewall to hosts behind it. Rules match source
    address of the packets and then log and drop them. Fwbuilder
    generated iptables commands to match all addresses of the
    firewall (192.168.1.1, 192.0.2.1) and network behind it
    (192.168.1.0/24). 
  </p>

  <p>
    Lets see what gets generated for the same rule for PF:
  </p>

  <p class="command">
# Tables: (1)<br>
table &lt;tbl.r0.s&gt; { 192.0.2.1 , 192.168.1.1 } <br>
<br>
# Rule  0 (en0)<br>
# anti spoofing rule<br>
# <br>
block in   log  quick on en0 inet  from &lt;tbl.r0.s&gt;  to any <br>
block in   log  quick on en0 inet  from 192.168.1.0/24  to any <br>
# <br>
  </p>
  
  <p>
    Here compiler uses tables to make generated PF code more
    compact. Table <emphasis>tbl.r0.s</emphasis> can be used in
    other rules wherever we need to operate with all addresses of
    the firewall.
  </p>

  <p>
    Here is the same rule, compiled for PIX:
  </p>

  <p class="command">
! Rule  0 (Ethernet1/0)<br>
! anti-spoofing rule<br>
! <br>
access-list outside_acl_in  remark 0 (Ethernet1/0)<br>
access-list outside_acl_in  remark anti-spoofing rule<br>
access-list outside_acl_in deny   ip host 192.0.2.1 any <br>
access-list outside_acl_in deny   ip host 192.168.2.1 any <br>
access-list outside_acl_in deny   ip host 192.168.1.1 any <br>
access-list outside_acl_in deny   ip 192.168.1.0 255.255.255.0 any<br>
<br>
access-group outside_acl_in in interface outside<br>
  </p>

<!-- ********************************************************* -->

  <h2>Anti-spoofing rules for the firewall with dynamic address</h2>

  <p>
    Anti-spoofing rule must match all addresses of the firewall to
    leave no holes. However it is difficult to do if one interface
    of the firewall gets its ip address dynamically via DHCP or
    PPP protocol. This address is unknown at the compile time and
    proper configuration can not be generated by just including
    it. Some firewall platforms have syntax in their configuration
    language that provides a way to match an address of an
    interface at run time, but other platforms do not have
    anything like this. Lets see how fwbuilder works around this problem.
  </p>

  <p>
    In this test I use variation of the same firewall object where
    external interface <emphasis>"eth0"</emphasis> is configured
    as "dynamic". The anti-spoofing rule looks exactly like the
    rule in the previous example and matches the same external
    interface "eth0", direction "inbound":
  </p>

  <img src="policy-antispoof-rule-2.png" />

  <p>
    Generated iptables script looks like this:
  </p>

  <p class="command">
getaddr eth0  i_eth0<br>
<br>
<br>
# Rule 0 (eth0)<br>
# <br>
# anti spoofing rule<br>
# <br>
$IPTABLES -N In_RULE_0<br>
test -n "$i_eth0" && $IPTABLES -A INPUT  -i eth0   -s $i_eth0   -j In_RULE_0 <br>
$IPTABLES -A INPUT  -i eth0   -s 192.168.1.1   -j In_RULE_0 <br>
$IPTABLES -A INPUT  -i eth0   -s 192.168.1.0/24   -j In_RULE_0 <br>
test -n "$i_eth0" && $IPTABLES -A FORWARD  -i eth0   -s $i_eth0   -j In_RULE_0 <br>
$IPTABLES -A FORWARD  -i eth0   -s 192.168.1.1   -j In_RULE_0 <br>
$IPTABLES -A FORWARD  -i eth0   -s 192.168.1.0/24   -j In_RULE_0 <br>
$IPTABLES -A In_RULE_0  -j LOG  --log-level info --log-prefix "RULE 0 -- DENY "<br>
$IPTABLES -A In_RULE_0  -j DROP <br>
  </p>

  <p>
    The script defines shell
    function <emphasis>"getaddr"</emphasis> at the beginning. This
    function uses <emphasis>"ip addr show"</emphasis> command to
    determine actual address of the interface at the time when
    script is running and assigns the address to the shell
    variable <emphasis>i_eth0</emphasis>. Iptables commands then
    use this variable to build rules matching address of this
    interface. Otherwise generated rules are the same as in the
    previous example.
  </p>

  <p>
    Here is what is generated for PF:
  </p>

  <p class="command">
table &lt;tbl.r0.d&gt; { en0 , 192.168.1.1 } <br>
<br>
# Rule  0 (en0)<br>
# anti spoofing rule<br>
# <br>
block in   log  quick on en0 inet  from &lt;tbl.r0.d&gt;  to any <br>
block in   log  quick on en0 inet  from 192.168.1.0/24  to any <br>
  </p>

  <p>
    In PF, one can place interface name ("en0") in the table and
    PF will use its address at the execution time.
  </p>

  <p>
    Unfortunately there is no workaround for this problem for PIX.
  </p>

<!-- ********************************************************* -->

  <h2>Using groups</h2>

  <p>
    Sometimes we need to define a lot of very similar rules for
    multiple hosts or networks. For example, there may be a need
    to permit the same service to 10 different hosts on the
    network, while still blocking it to all others. The simplest
    way to accomplish this is to add 10 rules with the same source
    and service fields and just different destinations. Another
    method is to add 10 objects to the Source or Destination rule
    element of the same rule. Both methods can make firewall
    policy quite cluttered and hardly readable.  To avoid this we
    can use groups. Group is just a container which includes
    references to multiple objects of the same or similar type.
    Firewall Builder supports groups of objects and groups of
    services. You can
    put <emphasis>"Address"</emphasis>, <emphasis>"Host"</emphasis>, <emphasis>"Network"</emphasis>
    and <emphasis>"Firewall"</emphasis> objects in an object
    group, but you cannot put service objects in a such
    group. Similarly, a service group can contain <emphasis>"IP Service"</emphasis>,
    <emphasis>"TCP Service"</emphasis>, <emphasis>"UDP
      Service"</emphasis> and <emphasis>"ICMP Service"</emphasis>
      objects, but cannot contain hosts or networks. Groups can
      contain other groups of the same type as well. Screenshot below
      represents object group used in this example.
  </p>


  <p>
    Groups not only make policy rules more readable, another great
    advantage of object groups is that they are reusable. You can
    now have many different rules using this same group object. If
    you ever need to add another host or address to the group, you
    only need to do it once and all rules will automatically pick
    the change after recompile.
  </p>

  <img src="policy-rule-group-object.png" />

  <p>
    To add objects to a group simply drag them from the tree on
    the left into group view on the right, or use Copy/Paste
    functions available via menus.
  </p>

  <p>
    Once appropriate group has been created, it can be used for
    the policy and NAT rules just like any other object.
  </p>

  <img src="policy-rule-group-1.png" />

  <p>
    Here is iptables commands generated for this example:
  </p>

  <p class="command">
# Rule 0 (global)<br>
# <br>
$IPTABLES -N Cid17843X27745.0<br>
$IPTABLES -A INPUT -p tcp -m tcp  --dport 22 \<br>
       -m state --state NEW  -j Cid17843X27745.0 <br>
$IPTABLES -A Cid17843X27745.0  -s 192.168.1.110   -j ACCEPT <br>
$IPTABLES -A Cid17843X27745.0  -s 192.168.1.111   -j ACCEPT <br>
$IPTABLES -A Cid17843X27745.0  -s 192.168.1.112   -j ACCEPT <br>
  </p>

  <p>
    Generated iptables command is placed only in
    the <emphasis>INPUT</emphasis> chain because it controls
    access to the firewall and not to any addresses across it.
    The first iptables command matches chain, tcp port and state.
    If this rule does not match the packet, there is no need to
    waste CPU cycles checking source ip addresses. However if the
    first rule matches, it passes control to the special
    user-defined chain "Cid17843X27745.0" where it checks source
    address of the packet. If compiler were to generate iptables
    script not using this temporary chain, it would end up
    comparing tcp port and state three times, together with each
    possible source address. This can be rather wasteful if the
    rule should match a lot of addresses. Separation of the
    matches using temporary chain can improve performance a lot.
  </p>

  <p>
    Compiler decides whether to use temporary chain not because
    administrator used object group in source in the original rule
    in the GUI, but because it determined that in the end it needs
    to compare source address of the packet against several
    addresses defined in the policy. If the group contained just
    one address, the generated iptables script would have
    consisted of just one iptables command without temporary
    chain. If there was no group in "Source" of the rule but
    instead all these host objects were placed in "source" of the
    rule directly, generated iptables script would look exactly
    like shown above, using temporary chain for optimization.
  </p>


  <p>
    Here is the code generated for PF for the same rule:
  </p>


  <p class="command">
table &lt;tbl.r0.d&gt; { 192.0.2.1 , 192.168.1.1 } <br>
table &lt;tbl.r0.s&gt; { 192.168.1.110 , 192.168.1.111 , 192.168.1.112 } <br>
<br>
# Rule  0 (global)<br>
# <br>
pass  quick inet proto tcp  from &lt;tbl.r0.s&gt;  to &lt;tbl.r0.d&gt; port 22 keep state <br>
  </p>

  <p>
    Policy compiler for PF extensively uses tables to produce
    compact code. PF tables are reused when needed.
  </p>

  <p>
    Here is the config generated for PIX:
  </p>

  <p class="command">
object-group network inside.id20599X27745.src.net.0<br>
  network-object  host 192.168.1.110 <br>
  network-object  host 192.168.1.111 <br>
  network-object  host 192.168.1.112 <br>
exit<br>
<br>
! Rule  0 (global)<br>
! <br>
access-list inside_acl_in  remark 0 (global)<br>
access-list inside_acl_in permit tcp object-group inside.id20599X27745.src.net.0<br>
      host 192.0.2.1 eq 22 <br>
access-list inside_acl_in permit tcp object-group inside.id20599X27745.src.net.0<br>
      host 192.168.1.1 eq 22 <br>
! <br>
  </p>

  <p>
    Just like in case of iptables, it is not that a group object
    was used in the original rule what triggered using
    <emphasis>object-group</emphasis> PIX clause. Compiler always
    checks the number of objects it needs to compare the packet
    against and uses
    <emphasis>object-groups</emphasis> statements to optimize
    generated code as appropriate.
  </p>

<!-- ********************************************************* -->

  <h2>Using Address Range instead of a group</h2>


  <p>
    In the example above, three hosts used for the
    group <emphasis>"management hosts"</emphasis> have consecutive
    addresses 192.168.1.110, 192.168.1.111,
    192.168.1.112. Although this example may be artificial, it
    allows us to illustrate how a different type of object could
    be used to achieve the same goal - to permit access to the
    firewall from these three addresses. The difference may be
    negligible when we deal with just three addresses, but when
    the list gets into hundreds it may become significant.
  </p>

  <p>
    Since addresses of the management hosts are consecutive, we
    can use Address Range object to describe them:
  </p>

  <img src="policy-rule-address-range-object.png" />

  <p>
    We use this object in the rule just like any other object. Here is
    how the rule looks like:
  </p>

  <img src="policy-rule-with-address-range.png" />

  <p>
    The main difference in generated code for the rule using
    Address Range compared to the rule using collection of
    individual addresses is that compiler is allowed to optimize
    it. It tries to squeeze the address range to the minimal set
    of address and network objects. Here is how it looks like for
    iptables:
  </p>

  <p class="command">
# Rule 0 (global)<br>
# <br>
$IPTABLES -A INPUT  -s 192.168.1.110/31   -m state --state NEW  -j ACCEPT <br>
$IPTABLES -A INPUT  -s 192.168.1.112   -m state --state NEW  -j ACCEPT <br>
  </p>

  <p>
    Again, the difference may not be very great when we have only
    three ip addresses, but in case of a range that span hundred
    addresses the performance gain and reduction in the size of
    generated script are significant.
  </p>

  <p>
    Generated PF and PIX configurations look similar.
  </p>

  <p>
    We will contniune with even more complex examples of policy access
    rules in the next article.
  </p>



  <p>
    References:
    <ul>
      <li><a href="http://www.fwbuilder.org/">Project web site: http://www.fwbuilder.org/</a></li>

      <li><a href="http://www.fwbuilder.org/docs/firewall_builder_packages.html">Source code, Linux .deb and .rpm package repositories, <strong>Windows</strong> and <strong>Mac OS X</strong> binary packages</a>

      <li><a href="http://www.fwbuilder.org/docs/UsersGuide3.pdf">Firewall Builder Users Guide (PDF)</a></li>
      <li><a href="http://www.fwbuilder.org/docs/users_guide/book1.htm">Firewall Builder Users Guide (HTML)</a></li>

      <li><a href="http://www.fwbuilder.org/guides/firewall_builder_cookbook.html">
          <b>Examples of iptables, pf and other rules: Firewall
            Builder Cookbook</b></a></li>

      <li><a href="http://blog.fwbuilder.org/">Project announcements
          and status: Firewall Builder Project Blog</a></li>


    </ul>
  </p>



</body>
</html>
