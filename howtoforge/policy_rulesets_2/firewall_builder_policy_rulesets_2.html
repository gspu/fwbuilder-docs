    <sect2>
      <title>Firewall object used in examples</title>

      <para>
        We start with the firewall object that looks like shown on
        <xref linkend="policy-examples-linux-fw" />. This firewall has
        three interfaces: eth0 (outside), eth1 (inside) and loopback.
        All addresses are assigned statically. Address of the inside
        interface "eth1" is 192.168.1.1/24, we also have network
        object with name "net-192.168.1.0" that defines internal
        network 192.168.1.0/24.
      </para>

      <para>
        To illustrate generated configurations for platforms other
        than iptables/Linux in this chapter, I am using similarly
        configured firewall objects with different platform and host
        OS settings.
      </para>

      <figure id="policy-examples-linux-fw">
        <title>Firewall and its interfaces used in the examples in this chapter.
        </title>
        <graphic scale="70" fileref="policy-examples-fw-linux.png" />
      </figure>
    </sect2>


    <!-- ********************************************************* -->

    <sect2>
      <title>Permit internal LAN to connect to the Internet</title>

      <para>
        In this example we create a rule to permit our internal LAN to
	connect to the Internet using any protocol. Network object
	"net-192.168.1.0" should be configured with the IP address and
	netmask corresponding to those used on the internal network
	behind the firewall. Since internal LAN in this example uses
	private address block, the rules described here are
	insufficient and should be accompanied with corresponding NAT
	(Network Address Translation) rules. We discuss NAT rules in
	the next chapter.
      </para>

      <figure id="policy-1-3">
        <title>Permit internal network to connect to Internet</title>
        <graphic scale="70" fileref="policy-1-3.png" />
      </figure>

      <para>
        Here are the iptables command generated for this example:
      </para>

      <screen>
# Rule 0 (global)
# 
$IPTABLES -A INPUT  -s 192.168.1.0/24   -m state --state NEW  -j ACCEPT 
$IPTABLES -A OUTPUT  -s 192.168.1.0/24   -m state --state NEW  -j ACCEPT 
$IPTABLES -A FORWARD  -s 192.168.1.0/24   -m state --state NEW  -j ACCEPT 
# 
# Rule 1 (global)
# 
$IPTABLES -N RULE_1
$IPTABLES -A OUTPUT  -j RULE_1 
$IPTABLES -A INPUT  -j RULE_1 
$IPTABLES -A FORWARD  -j RULE_1 
$IPTABLES -A RULE_1  -j LOG  --log-level info --log-prefix "RULE 1 -- DENY "
$IPTABLES -A RULE_1  -j DROP 
      </screen>

      <para>
        The first rule was placed in all three
        chains: <emphasis>INPUT</emphasis>, <emphasis>OUTPUT</emphasis>
        and <emphasis>FORWARD</emphasis> because option "Assume
        firewall is part of any" was turned on in the "Advanced"
        settings dialog of this firewall object. This option directs
        policy compiler to assume that
        object <emphasis>"Any"</emphasis> matches firewall itself as
        well. In other words, using "Any" in Destination of the rule
        is equivalent to using a combination of any address and the
        firewall. To match packets headed for the firewall, the rule
        should be placed in the <emphasis>INPUT</emphasis> chain.
        Also, network object within address 192.168.1.0/24 matches one
        of the interfaces of the firewall that has address on this
        network. This means, this rule should also match packets sent
        by the firewall itself provided source address is that of the
        interface on the internal net. This requires iptables command
        in the <emphasis>OUTPUT</emphasis> chain. And finally,
        iptables command in the <emphasis>FORWARD</emphasis> chain
        matches packets sent by machines on the internal net.
      </para>

      <para>
        Rule #1 catches all other packets going to, from and across
        the firewall and logs and drops them.
      </para>

      <para>
        Here is the PF configuration created for the same rules:
      </para>

      <screen>
# Rule  0 (global)
# 
pass  quick inet  from 192.168.1.0/24  to any keep state 
# 
# Rule  1 (global)
# 
block  log  quick inet  from any  to any 
      </screen>
      
      <para>
        Firewall Builder always generates PF configuration using
        its <emphasis>"quick"</emphasis> clause to switch to the
        first-match mode. In this PF configuration example, the first
        rule permits packets with source address on the 192.168.1.0/24
        network and stops processing. The second rule will only
        inspect packets not matched by the first rule.
      </para>


      <para>
        Here is the fragment of the PIX config generated for the same
        combination of rules:
      </para>

      <screen>
 Rule  0 (global)
! 
access-list inside_acl_in  remark 0 (global)
access-list inside_acl_in permit ip 192.168.1.0 255.255.255.0 any 
! 
! Rule  1 (global)
! 
access-list outside_acl_in  remark 1 (global)
access-list outside_acl_in deny   ip any any log 4 interval 300 
access-list dmz50_acl_in  remark 1 (global)
access-list dmz50_acl_in deny   ip any any log 4 interval 300 
access-list inside_acl_in  remark 1 (global)
access-list inside_acl_in deny   ip any any log 4 interval 300 


access-group dmz50_acl_in in interface dmz50
access-group inside_acl_in in interface inside
access-group outside_acl_in in interface outside
      </screen>

      <para>
        Since source address in the rule #0 is limited to the internal
        network, policy compiler was able to determine which interface
        the access list command should be associated with and added it
        only to the ACL <emphasis>"inside_acl_in"</emphasis>.
      </para>

      <para>
        The <emphasis>"access-group"</emphasis> commands are actually
        located at the very bottom of the generated script, after all
        other <emphasis>access-list</emphasis> commands. It is shown
        right next to the ACL rules here for presentation.
      </para>
      
    </sect2>


    <!-- ********************************************************* -->

    <sect2>
      <title>Letting certain protocols through, while blocking everything
      else</title>

      <para>This is one of the simplest, most basic tasks you may want your
      firewall to do - block all the traffic while letting certain protocols
      through. Let's assume that we have a network consisting of just the
      firewall "firewall1" and a few hosts behind it. We want to let SMTP 
      through to the mail server from the Internet, and block
      everything else. All we need to do is put the following rules in the
      Global Policy:</para>

      <figure>
          <title>Example of a rule permitting only certain protocols to the
          server and blocking everything else.</title>
              <graphic scale="70" fileref="policy-1.png" />
        </figure>

      <para>
        Rule #0 allows SMTP through to the server, while rule #1
        blocks and logs everything else. It is worth mentioning that
        this policy also blocks all the access to firewall itself,
        including access to it from internal hosts.
      </para>

      <para>
        We do not need any additional rules to take care of "reply"
        packets coming back from the server to clients because our
        underlying firewall software supports stateful inspection and
        "understands" that such packets should be let through.
      </para>

      <para>
        Here is iptables script generated for these two simple rules:
      </para>

      <screen>
$IPTABLES -A INPUT   -m state --state ESTABLISHED,RELATED -j ACCEPT
$IPTABLES -A OUTPUT  -m state --state ESTABLISHED,RELATED -j ACCEPT
$IPTABLES -A FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPT

# Rule 0 (global)
# 
$IPTABLES -A OUTPUT -p tcp -m tcp  -d 192.168.1.100  \
     --dport 25  -m state --state NEW  -j ACCEPT 
$IPTABLES -A FORWARD -p tcp -m tcp  -d 192.168.1.100 \
     --dport 25  -m state --state NEW  -j ACCEPT 
# 
# Rule 1 (global)
# 
$IPTABLES -N RULE_1
$IPTABLES -A OUTPUT  -m state --state NEW  -j RULE_1 
$IPTABLES -A INPUT  -m state --state NEW  -j RULE_1 
$IPTABLES -A FORWARD  -m state --state NEW  -j RULE_1 
$IPTABLES -A RULE_1  -j LOG  --log-level info --log-prefix "RULE 1 -- DENY "
$IPTABLES -A RULE_1  -j DROP 
      </screen>

      <para>
        Rules that utilize module <emphasis>state</emphasis> and match
        states <emphasis>ESTABLISHED,RELATED</emphasis> permit reply
        packets, such as TCP ACKs, UDP reply packets and ICMP messages
        associated with known sessions. These rules are automatically
        added at the beginning of generated iptables script if the
        option "Accept ESTABLISHED and RELATED packets before the
        first rule" is turned on in the firewall object "Advanced"
        settings dialog. If you turn this option off, the rule will
        not be added automatically and you'll have to add it
        yourself. You can use Custom Service
        object <emphasis>ESTABLISHED</emphasis> you can find in
        the <emphasis>Standard</emphasis> objects library to do this.
      </para>

      <para>
        Generated iptables rules were placed in
        both <emphasis>OUTPUT</emphasis>
        and <emphasis>FORWARD</emphasis> chains because option "Assume
        firewall is part of any" was turned on in the "Advanced"
        settings dialog of this firewall object. This option directs
        policy compiler to assume that
        object <emphasis>"Any"</emphasis> matches firewall itself as
        well. In other words, using "Any" in Source of the rule was
        equivalent to using a combination of any address and the
        firewall. Resultant iptables commands should be placed in
        the <emphasis>OUTPUT</emphasis> chain to match packets
        generated by the firewall and <emphasis>FORWARD</emphasis> to
        match packets crossing the firewall. If you turn this option
        off, the program will only generate iptables rules in
        the <emphasis>FORWARD</emphasis> chain for this rule.
      </para>

      <para>
        Here is the code generated for PF for the same rule:
      </para>

      <screen>
# Rule  0 (global)
# 
pass  quick inet proto tcp  from any  to 192.168.1.100 port 25 keep state 
# 
# Rule  1 (global)
# 
block  log  quick inet  from any  to any 
      </screen>

      <para>
        In PF we do not have to worry about chains and there is no
        option "Assume firewall is part of any" because there is no
        difference.
      </para>

      <para>
        Here is the code generated for PIX for the same rule:
      </para>

      <screen>
! Rule  0 (global)
! 
access-list outside_acl_in  remark 0 (global)
access-list outside_acl_in permit tcp any host 192.168.1.100 eq 25 
access-list dmz50_acl_in  remark 0 (global)
access-list dmz50_acl_in permit tcp any host 192.168.1.100 eq 25 
access-list inside_acl_in  remark 0 (global)
access-list inside_acl_in permit tcp any host 192.168.1.100 eq 25 
! 
! Rule  1 (global)
! 
access-list outside_acl_in  remark 1 (global)
access-list outside_acl_in deny   ip any any log 0 interval 300 
access-list dmz50_acl_in  remark 1 (global)
access-list dmz50_acl_in deny   ip any any log 0 interval 300 
access-list inside_acl_in  remark 1 (global)
access-list inside_acl_in deny   ip any any log 0 interval 300 
      </screen>

      <para>
        In PIX, all access lists must be attached to interfaces of the
        firewall. Since the rule did not specify source address, the
        program has to generate access lists that would match any
        source, which means they should be attached to all interfaces
        of the firewall. Since my PIX test object has three
        interfaces: <emphasis>outside</emphasis>, <emphasis>inside</emphasis>
        and <emphasis>dmz</emphasis>, I ended up with ACL lines in
        three access lists, one for each interface.
      </para>

    </sect2>

    <!-- ********************************************************* -->


    <sect2>
      <title> Letting certain protocols through from specific source.</title>

      <para>
        In this example, we look at the rule that is similar to the
        previous one, but also matches source address. This rule
        permits access to the mail server inside from mail relay on
        DMZ and from no other source. Generated rules for iptables and
        pf are very similar, they just add source address
        matching. Generated rules for PIX are different because now
        the program can intelligently pick the right access list and
        avoid generating redundant rules.
      </para>


      <figure>
          <title>Example of a rule permitting only certain protocols
          from limited set of sources to the server.</title>
          <graphic scale="70" fileref="policy-1-2.png" />
        </figure>


      <para>
        Here is the code generated for iptables from this rule:
      </para>

      <screen>
# Rule 0 (global)
# 
$IPTABLES -A FORWARD -p tcp -m tcp  -s 192.168.2.22   -d 192.168.1.100  \
     --dport 25  -m state --state NEW  -j ACCEPT 
      </screen>

      <para>
        Since source rule element was limited to the host on DMZ,
        generated iptables rule is placed only in the FORWARD chain
        and also matches the source using "-s" clause.
      </para>

      <para>
        Lets look at the configuration generated for PIX from the same rule:
      </para>

      <screen>
! Rule  0 (global)
! 
access-list dmz50_acl_in  remark 0 (global)
access-list dmz50_acl_in permit tcp host 192.168.2.22 host 192.168.1.100 eq 25 


access-group dmz50_acl_in in interface dmz50
access-group inside_acl_in in interface inside
access-group outside_acl_in in interface outside
      </screen>

      <para>
        the rule was placed only in the access list attached to the
        DMZ interface because packets with source address of the host
        on DMZ can only cross this interface of the firewall, assuming
        spoofed packets are blocked by special rule, which will
        discuss below.
      </para>


    </sect2>

    <!-- ********************************************************* -->

    <sect2>
      <title>Interchangeable and non-interchangeable objects</title>

      <!-- TODO: Need examples for this section -->

      <para>In the previous example we put object "mail server" into
      the Destination field of the policy rule #0 because our goal was
      to permit protocol SMTP to that host and not to any other
      one. This actually reflects general principle Firewall Builder
      is based on: put the object you want to control access for in
      the Source or Destination field of the policy rule. Two
      different objects with the same address may or may not be
      interchangeable, depending on their type and other
      parameters. One of the frequent mistakes is to create Host
      object with IP address of the firewall, then use it in the
      policy and expect Firewall Builder to build policy controlling
      access to the firewall. Unfortunately it does not always work
      that way. If you wish to control access to or from the firewall
      machine, then put Firewall object into the policy rule.</para>

      <para>Another example of two objects which may on the first
      glance represent the same thing, but in fact are not
      interchangeable, is IP service object with protocol number set
      to 1 and ICMP service object with type and code set to
      "any". Both objects might represent the same type of service,
      namely "Any ICMP message". IP protocol 1 is in fact ICMP, so one
      would expect the behaviour of the firewall to be the same
      regardless of what type of service object is used. However,
      target firewall software typically uses special syntax for
      indication of different protocols, so using proper syntax for
      ICMP protocol turns certain features on, like for example
      session state tracking and association of the ICMP packets to
      known sessions these packets might carry error messages
      for. Using just IP with protocol number 1 will most likely not
      turn these features on and therefore will lead to unexpected
      results.</para>

      <para>Interface object and its ip address are interchangeable in
      rules, provided the interface has only one address. If interface
      object has several address child objects, then using the
      interface object in a rule is equivalent to using all of its
      addresses in the same place. If interface has only one address,
      then the result will be the same whether you put interface
      object or its address in the rule. Also, using firewall object
      in the rule should yield the same policy script as if you put
      all its interfaces in the same place instead. This one comes
      with a caveat though: many firewall platforms offer special
      syntax for rules that control access to or from the firewall
      itself and fwbuilder takes advantage of this syntax, so the
      result may not look exactly the same, but should be equivalent
      in function. Some platforms, such as iptables, require using
      different chain to control access to and from
      firewall. Fwbuilder compares ip addresses used in source and
      destination of rules to addresses of all interfaces of the
      firewall and uses proper chains even if the address object in
      the rule is not the firewall object itself.
      </para>

      <para>Two objects of the same type with different names but the
      same values of all other parameters are always
      interchangeable. Using different objects to describe the same
      object may be confusing, but the final firewall policy will be
      correct. Firewall Builder leaves design of the objects up to the
      firewall administrator.</para>
    </sect2>

    <!-- ********************************************************* -->


    <sect2>
      <title>Anti-spoofing rules</title>


      <para>
        Generally speaking, IP spoofing is a technique of generating
        IP packets with source address that belongs to someone
        else. Spoofing creates a danger when hosts on the LAN permit
        access to their resources and services to trusted hosts by
        checking the source IP of the packets.  Using spoofing, an
        intruder can fake the source address of his packets and make
        them look like they originated on the trusted hosts. The basic
        idea of anti-spoofing protection is to create a firewall rule
        assigned to the external interface of the firewall that
        examines source address of all packets crossing that interface
        coming from outside. If the address belongs to the internal
        network or the firewall itself, the packet is dropped.
      </para>

      <para>
        Simple anti-spoofing rule looks like shown on
        <xref linkend="anti-spoof-rule-1" />. Unlike the rule in the
        previous example, anti-spoofing rule requires matching of the
        interface and direction. The idea is that packets that come
        from outside must not have source addresses that match
        internal network or the firewall itself. The only way to
        distinguish packets coming from outside from those coming from
        inside is to check which interface of the firewall they cross
        and in which direction. Here the rule matches
        interface <emphasis>eth0</emphasis>, which is external, and direction
        <emphasis>inbound</emphasis>.
      </para>

      <para>
        <xref linkend="gettingstarted" /> explains how a firewall
        object and its interfaces can be
        created. <xref linkend="host-interface" /> has more details on
        the firewall's interfaces, their types and other
        properties. <xref linkend="direction" /> explains the concept
        of direction.
      </para>

      <figure id="anti-spoof-rule-1">
        <title>Basic anti-spoofing rule</title>
        <graphic scale="70" fileref="policy-antispoof-rule-1.png" />
      </figure>

      <para>
        Here are the iptables commands generated for this rule:
      </para>

      <screen>
# Rule 0 (eth0)
# 
# anti spoofing rule
# 
$IPTABLES -N In_RULE_0
$IPTABLES -A INPUT  -i eth0   -s 192.0.2.1   -j In_RULE_0 
$IPTABLES -A INPUT  -i eth0   -s 192.168.1.1   -j In_RULE_0 
$IPTABLES -A INPUT  -i eth0   -s 192.168.1.0/24   -j In_RULE_0 
$IPTABLES -A FORWARD  -i eth0   -s 192.0.2.1   -j In_RULE_0 
$IPTABLES -A FORWARD  -i eth0   -s 192.168.1.1   -j In_RULE_0 
$IPTABLES -A FORWARD  -i eth0   -s 192.168.1.0/24   -j In_RULE_0 
$IPTABLES -A In_RULE_0  -j LOG  --log-level info --log-prefix "RULE 0 -- DENY "
$IPTABLES -A In_RULE_0  -j DROP 
      </screen>

      <para>
        Iptables commands were placed in INPUT and FORWARD chains to
        match both packets that are headed for the firewall and
        through the firewall to hosts behind it. Rules match source
        address of the packets and then log and drop them. Fwbuilder
        generated iptables commands to match all addresses of the
        firewall (192.168.1.1, 192.0.2.1) and network behind it
        (192.168.1.0/24). 
      </para>

      <para>
        Lets see what gets generated for the same rule for PF:
      </para>

      <screen>
# Tables: (1)
table &lt;tbl.r0.s&gt; { 192.0.2.1 , 192.168.1.1 } 

# Rule  0 (en0)
# anti spoofing rule
# 
block in   log  quick on en0 inet  from &lt;tbl.r0.s&gt;  to any 
block in   log  quick on en0 inet  from 192.168.1.0/24  to any 
# 
      </screen>
      
      <para>
        Here compiler uses tables to make generated PF code more
        compact. Table <emphasis>tbl.r0.s</emphasis> can be used in
        other rules wherever we need to operate with all addresses of
        the firewall.
      </para>

      <para>
        Here is the same rule, compiled for PIX:
      </para>

      <screen>
! Rule  0 (Ethernet1/0)
! anti-spoofing rule
! 
access-list outside_acl_in  remark 0 (Ethernet1/0)
access-list outside_acl_in  remark anti-spoofing rule
access-list outside_acl_in deny   ip host 192.0.2.1 any 
access-list outside_acl_in deny   ip host 192.168.2.1 any 
access-list outside_acl_in deny   ip host 192.168.1.1 any 
access-list outside_acl_in deny   ip 192.168.1.0 255.255.255.0 any

access-group outside_acl_in in interface outside

      </screen>

    </sect2>

    <!-- ********************************************************* -->

    <sect2>
      <title>Anti-spoofing rules for the firewall with dynamic address</title>

      <para>
        Anti-spoofing rule must match all addresses of the firewall to
        leave no holes. However it is difficult to do if one interface
        of the firewall gets its ip address dynamically via DHCP or
        PPP protocol. This address is unknown at the compile time and
        proper configuration can not be generated by just including
        it. Some firewall platforms have syntax in their configuration
        language that provides a way to match an address of an
        interface at run time, but other platforms do not have
        anything like this. Lets see how fwbuilder works around this problem.
      </para>

      <para>
        In this test I use variation of the same firewall object where
         external interface <emphasis>"eth0"</emphasis> is configured
         as "dynamic". The anti-spoofing rule looks exactly like the
         rule in the previous example and matches the same external
         interface "eth0", direction "inbound":
      </para>

      <figure id="anti-spoof-rule-2">
        <title>Basic anti-spoofing rule</title>
        <graphic scale="70" fileref="policy-antispoof-rule-2.png" />
      </figure>

      <para>
        Generated iptables script looks like this:
      </para>

      <screen>
getaddr eth0  i_eth0


# Rule 0 (eth0)
# 
# anti spoofing rule
# 
$IPTABLES -N In_RULE_0
test -n "$i_eth0" && $IPTABLES -A INPUT  -i eth0   -s $i_eth0   -j In_RULE_0 
$IPTABLES -A INPUT  -i eth0   -s 192.168.1.1   -j In_RULE_0 
$IPTABLES -A INPUT  -i eth0   -s 192.168.1.0/24   -j In_RULE_0 
test -n "$i_eth0" && $IPTABLES -A FORWARD  -i eth0   -s $i_eth0   -j In_RULE_0 
$IPTABLES -A FORWARD  -i eth0   -s 192.168.1.1   -j In_RULE_0 
$IPTABLES -A FORWARD  -i eth0   -s 192.168.1.0/24   -j In_RULE_0 
$IPTABLES -A In_RULE_0  -j LOG  --log-level info --log-prefix "RULE 0 -- DENY "
$IPTABLES -A In_RULE_0  -j DROP 
      </screen>

      <para>
        The script defines shell
        function <emphasis>"getaddr"</emphasis> at the beginning. This
        function uses <emphasis>"ip addr show"</emphasis> command to
        determine actual address of the interface at the time when
        script is running and assigns the address to the shell
        variable <emphasis>i_eth0</emphasis>. Iptables commands then
        use this variable to build rules matching address of this
        interface. Otherwise generated rules are the same as in the
        previous example.
      </para>

      <para>
        Here is what is generated for PF:
      </para>

      <screen>
table &lt;tbl.r0.d&gt; { en0 , 192.168.1.1 } 

# Rule  0 (en0)
# anti spoofing rule
# 
block in   log  quick on en0 inet  from &lt;tbl.r0.d&gt;  to any 
block in   log  quick on en0 inet  from 192.168.1.0/24  to any 
      </screen>

      <para>
        In PF, one can place interface name ("en0") in the table and
        PF will use its address at the execution time.
      </para>

      <para>
        Unfortunately there is no workaround for this problem for PIX.
      </para>

    </sect2>

    <!-- ********************************************************* -->

    <sect2>
      <title>Using groups</title>

      <para>
        Sometimes we need to define a lot of very similar rules for
        multiple hosts or networks. For example, there may be a need
        to permit the same service to 10 different hosts on the
        network, while still blocking it to all others. The simplest
        way to accomplish this is to add 10 rules with the same source
        and service fields and just different destinations. Another
        method is to add 10 objects to the Source or Destination rule
        element of the same rule. Both methods can make firewall
        policy quite cluttered and hardly readable.  To avoid this we
        can use groups. Group is just a container which includes
        references to multiple objects of the same or similar type.
        Firewall Builder supports groups of objects and groups of
        services. You can
        put <emphasis>"Address"</emphasis>, <emphasis>"Host"</emphasis>, <emphasis>"Network"</emphasis>
        and <emphasis>"Firewall"</emphasis> objects in an object
        group, but you cannot put service objects in a such
        group. Similarly, a service group can contain <emphasis>"IP Service"</emphasis>,
        <emphasis>"TCP Service"</emphasis>, <emphasis>"UDP
        Service"</emphasis> and <emphasis>"ICMP Service"</emphasis>
        objects, but cannot contain hosts or networks. Groups can
        contain other groups of the same type as
        well. <xref linkend="object-group-2" /> represents object
        group used in this example.
      </para>


      <para>
        Groups not only make policy rules more readable, another great
        advantage of object groups is that they are reusable. You can
        now have many different rules using this same group object. If
        you even need to add another host or address to the group, you
        only need to do it once and all rules will automatically pick
        the change after recompile.
      </para>

      <figure id="object-group-2">
          <title>Object group that consists of three host objects.</title>
          <graphic scale="70" fileref="policy-rule-group-object.png" />
      </figure>

      <para>
        To add objects to a group simply drag them from the tree on
        the left into group view on the right, or use Copy/Paste
        functions available via menus.
      </para>

      <para>
        Once appropriate group has been created, it can be used for
        the policy and NAT rules just like any other object.
      </para>

      <figure>
          <title>Example of a rule using object group.</title>
          <graphic scale="70" fileref="policy-rule-group-1.png" />
      </figure>

      <para>
        Here is iptables commands generated for this example:
      </para>

      <screen>
# Rule 0 (global)
# 
$IPTABLES -N Cid17843X27745.0
$IPTABLES -A INPUT -p tcp -m tcp  --dport 22 \
     -m state --state NEW  -j Cid17843X27745.0 
$IPTABLES -A Cid17843X27745.0  -s 192.168.1.110   -j ACCEPT 
$IPTABLES -A Cid17843X27745.0  -s 192.168.1.111   -j ACCEPT 
$IPTABLES -A Cid17843X27745.0  -s 192.168.1.112   -j ACCEPT 
      </screen>

      <para>
        Generated iptables command is placed only in
        the <emphasis>INPUT</emphasis> chain because it controls
        access to the firewall and not to any addresses across it.
        The first iptables command matches chain, tcp port and state.
        If this rule does not match the packet, there is no need to
        waste CPU cycles checking source ip addresses. However if the
        first rule matches, it passes control to the special
        user-defined chain "Cid17843X27745.0" where it checks source
        address of the packet. If compiler were to generate iptables
        script not using this temporary chain, it would end up
        comparing tcp port and state three times, together with each
        possible source address. This can be rather wasteful if the
        rule should match a lot of addresses. Separation of the
        matches using temporary chain can improve performance a lot.
      </para>

      <para>
        Compiler decides whether to use temporary chain not because
        administrator used object group in source in the original rule
        in the GUI, but because it determined that in the end it needs
        to compare source address of the packet against several
        addresses defined in the policy. If the group contained just
        one address, the generated iptables script would have
        consisted of just one iptables command without temporary
        chain. If there was no group in "Source" of the rule but
        instead all these host objects were placed in "source" of the
        rule directly, generated iptables script would look exactly
        like shown above, using temporary chain for optimization.
      </para>


      <para>
        Here is the code generated for PF for the same rule:
      </para>


      <screen>
table &lt;tbl.r0.d&gt; { 192.0.2.1 , 192.168.1.1 } 
table &lt;tbl.r0.s&gt; { 192.168.1.110 , 192.168.1.111 , 192.168.1.112 } 

# Rule  0 (global)
# 
pass  quick inet proto tcp  from &lt;tbl.r0.s&gt;  to &lt;tbl.r0.d&gt; port 22 keep state 
      </screen>

      <para>
        Policy compiler for PF extensively uses tables to produce
        compact code. PF tables are reused when needed.
      </para>

      <para>
        Here is the config generated for PIX:
      </para>

      <screen>
object-group network inside.id20599X27745.src.net.0
 network-object  host 192.168.1.110 
 network-object  host 192.168.1.111 
 network-object  host 192.168.1.112 
 exit

! Rule  0 (global)
! 
access-list inside_acl_in  remark 0 (global)
access-list inside_acl_in permit tcp object-group inside.id20599X27745.src.net.0
         host 192.0.2.1 eq 22 
access-list inside_acl_in permit tcp object-group inside.id20599X27745.src.net.0
         host 192.168.1.1 eq 22 
! 
      </screen>

      <para>
        Just like in case of iptables, it is not that a group object
        was used in the original rule what triggered using
        <emphasis>object-group</emphasis> PIX clause. Compiler always
        checks the number of objects it needs to compare the packet
        against and uses
        <emphasis>object-groups</emphasis> statements to optimize
        generated code as appropriate.
      </para>

    </sect2>

    <!-- ********************************************************* -->


    <sect2>

      <title>Using Address Range instead of a group</title>


      <para>
        In the example above, three hosts used for the
        group <emphasis>"management hosts"</emphasis> have consecutive
        addresses 192.168.1.110, 192.168.1.111,
        192.168.1.112. Although this example may be artificial, it
        allows us to illustrate how a different type of object could
        be used to achieve the same goal - to permit access to the
        firewall from these three addresses. The difference may be
        negligible when we deal with just three addresses, but when
        the list gets into hundreds it may become significant.
      </para>

      <para>
        Since addresses of the management hosts are consecutive, we
        can use Address Range object to describe them:
      </para>

      <figure id="address-range-obj-1">
        <title>Policy for server</title>
        <graphic scale="60" fileref="policy-rule-address-range-object.png" />
      </figure>

      <para>
        We use this object in the rule just like any other
        object. <xref linkend="policy-rule-with-address-range-obj"/> shows the rule:
      </para>

      <figure id="policy-rule-with-address-range-obj">
        <title>Policy for server</title>
        <graphic scale="60" fileref="policy-rule-with-address-range.png" />
      </figure>

      <para>
        The main difference in generated code for the rule using
        Address Range compared to the rule using collection of
        individual addresses is that compiler is allowed to optimize
        it. It tries to squeeze the address range to the minimal set
        of address and network objects. Here is how it looks like for
        iptables:
      </para>

      <screen>
# Rule 0 (global)
# 
$IPTABLES -A INPUT  -s 192.168.1.110/31   -m state --state NEW  -j ACCEPT 
$IPTABLES -A INPUT  -s 192.168.1.112   -m state --state NEW  -j ACCEPT 
      </screen>

      <para>
        Again, the difference may not be very great when we have only
        three ip addresses, but in case of a range that span hundred
        addresses the performance gain and reduction in the size of
        generated script are significant.
      </para>

      <para>
        Generated PF and PIX configurations look similar.
      </para>

    </sect2>

