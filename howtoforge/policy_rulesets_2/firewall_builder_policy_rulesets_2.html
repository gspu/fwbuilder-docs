<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Firewall Builder: Firewall Access Policy Rulesets, Part 2 | HowtoForge - Linux Howtos and Tutorials</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<style type="text/css">
<!--
.command {
    padding: 1em;
    border: 1px dashed #2f6fab;
    color: black;
    background-color: #f9f9f9;
    line-height: 1.1em;
        font-family: Courier New, Courier, mono;
        font-size: 12px;
        font-style: italic;
}

.system {
    color: black;
        font-family: Courier New, Courier, mono;
        font-size: 12px;
        font-style: italic;
}

.highlight {
    color: #FF0000;
        font-family: Georgia, "Times New Roman", Times, serif;
        font-size: 12px;
        text-decoration: underline;
}
-->
</style>
</head>

<body>
  

  <h1>Firewall Access Policy Rulesets, Part 2</h1>


  <table border=0>
    <tr>
      <td><img src="http://www.fwbuilder.org/images/icon_128x128.png" height="128" width="128" /></td>
      <td>Author: vadim@fwbuilder.org<br/>
        <a href="http://www.fwbuilder.org">http://www.fwbuilder.org</a>
      </td>
    </tr>
  </table>


  <p>
    This article continues the series of articles on Firewall Builder,
    a graphical firewall configuration and management tool that
    supports many Open Source firewall platforms as well as Cisco IOS
    access lists and Cisco ASA (PIX).  Firewall Builder was introduced
    on this site earlier with articles

    <a href="http://www.howtoforge.com/getting-started-with-firewall-builder">
    Getting Started With Firewall Builder</a>, 

    <a href="http://www.howtoforge.com/using-firewall-object-in-firewall-builder">
      Using Firewall Object In Firewall Builder</a>.

    <a href="http://www.howtoforge.com/firewall-access-policy-rulesets-part-1">
      Firewall Access Policy Rulesets, Part 1</a>.
  </p>

  <p>
    This article demonstrates several examples of <strong>Access
     Policy rules</strong> and generated configurations
     for <strong>iptables</strong>, <strong>PF</strong>
     and <strong>Cisco PIX</strong>.
  </p>

  <p>
    More information on Firewall Builder, pre-built binary packages
    and source code, documentation can be found on
    <a href="http://www.fwbuilder.org/">
    the project web site at http://www.fwbuilder.org/</a>. Numerous
    <a href="http://www.fwbuilder.org/docs/users_guide/book1.htm">
    examples of iptables, pf and other rules are available
    in <b>Firewall Builder Users Guide</b></a>.
    Follow <a href="http://blog.fwbuilder.org/"> Firewall Builder
    Project Blog</a> for announcements and articles on all aspects of
    using Firewall Builder.
  </p>

  
  <h2>Firewall object used in examples</h2>

  <p>
    We start with the firewall object that looks like shown in the
    next screenshot. This firewall has three interfaces: eth0
    (outside), eth1 (inside) and loopback.  All addresses are assigned
    statically. Address of the inside interface "eth1" is
    192.168.1.1/24, we also have network object with name
    "net-192.168.1.0" that defines internal network 192.168.1.0/24.
  </p>

  <p>
    To illustrate generated configurations for platforms other than
    iptables/Linux in this article, I am using similarly configured
    firewall objects with different platform and host OS settings.
  </p>

  <img src="policy-examples-fw-linux.png" />

  <!-- ********************************************************* -->

  <h2>Permit internal LAN to connect to the Internet</h2>

  <p>
    In this example we create a rule to permit our internal LAN to
    connect to the Internet using any protocol. Network object
    "net-192.168.1.0" should be configured with the IP address and
    netmask corresponding to those used on the internal network
    behind the firewall. Since internal LAN in this example uses
    private address block, the rules described here are
    insufficient and should be accompanied with corresponding NAT
    (Network Address Translation) rules. We discuss NAT rules in
    the next article.
  </p>

  <img src="policy-1-3.png" />

  <p>
    Here are the iptables command generated for this example:
  </p>

  <pre class="command">
$IPTABLES -A INPUT   -m state --state ESTABLISHED,RELATED -j ACCEPT
$IPTABLES -A OUTPUT  -m state --state ESTABLISHED,RELATED -j ACCEPT
$IPTABLES -A FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPT

# Rule 0 (global)
# 
$IPTABLES -A INPUT  -s 192.168.1.0/24   -m state --state NEW  -j ACCEPT 
$IPTABLES -A OUTPUT  -s 192.168.1.0/24   -m state --state NEW  -j ACCEPT 
$IPTABLES -A FORWARD  -s 192.168.1.0/24   -m state --state NEW  -j ACCEPT 
# 
# Rule 1 (global)
# 
$IPTABLES -N RULE_1
$IPTABLES -A OUTPUT  -j RULE_1 
$IPTABLES -A INPUT  -j RULE_1 
$IPTABLES -A FORWARD  -j RULE_1 
$IPTABLES -A RULE_1  -j LOG  --log-level info --log-prefix "RULE 1 -- DENY "
$IPTABLES -A RULE_1  -j DROP 
      </pre>

  <p>
    Rules that utilize module <emphasis>state</emphasis> and match
    states <emphasis>ESTABLISHED,RELATED</emphasis> permit reply
    packets, such as TCP ACKs, UDP reply packets and ICMP messages
    associated with known sessions. These rules are automatically
    added at the beginning of generated iptables script if the
    option "Accept ESTABLISHED and RELATED packets before the
    first rule" is turned on in the firewall object "Advanced"
    settings dialog. If you turn this option off, the rule will
    not be added automatically and you'll have to add it
    yourself. You can use Custom Service
    object <emphasis>ESTABLISHED</emphasis> you can find in
    the <emphasis>Standard</emphasis> objects library to do this.
  </p>

  <p>
    The first rule was placed in all three
    chains: <emphasis>INPUT</emphasis>, <emphasis>OUTPUT</emphasis>
    and <emphasis>FORWARD</emphasis> because option "Assume
    firewall is part of any" was turned on in the "Advanced"
    settings dialog of this firewall object. This option directs
    policy compiler to assume that
    object <emphasis>"Any"</emphasis> matches firewall itself as
    well. In other words, using "Any" in Destination of the rule
    is equivalent to using a combination of any address and the
    firewall. To match packets headed for the firewall, the rule
    should be placed in the <emphasis>INPUT</emphasis> chain.
    Also, network object within address 192.168.1.0/24 matches one
    of the interfaces of the firewall that has address on this
    network. This means, this rule should also match packets sent
    by the firewall itself provided source address is that of the
    interface on the internal net. This requires iptables command
    in the <emphasis>OUTPUT</emphasis> chain. And finally,
    iptables command in the <emphasis>FORWARD</emphasis> chain
    matches packets sent by machines on the internal net.
  </p>

  <p>
    Rule #1 catches all other packets going to, from and across
    the firewall and logs and drops them.
  </p>

  <p>
    Lets see what gets generated for iptables if option "Assume
    firewall is part of any" is turned off:
  </p>

  <pre class="command">
$IPTABLES -A INPUT   -m state --state ESTABLISHED,RELATED -j ACCEPT
$IPTABLES -A OUTPUT  -m state --state ESTABLISHED,RELATED -j ACCEPT
$IPTABLES -A FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPT

# Rule 0 (global)
# 
$IPTABLES -A FORWARD  -s 192.168.1.0/24   -m state --state NEW  -j ACCEPT 
# 
# Rule 1 (global)
# 
$IPTABLES -N RULE_1
$IPTABLES -A FORWARD  -j RULE_1 
$IPTABLES -A RULE_1  -j LOG  --log-level info --log-prefix "RULE 1 -- DENY "
$IPTABLES -A RULE_1  -j DROP 
  </pre>

  <p>
    Automatically added rules that match packets in states
    ESTABLISHED,RELATED are not affected by the "Assume firewall is
    part of any" option and always match in chains INPUT, OUTPUT and
    FORWARD.
  </p>

  <p>
    Since the compiler does not assume firewall matches "any" anymore,
    the rule with "any" is destination yields iptables command only in
    the FORWARD chain. This applies both to the rule that permits
    outgoing connections from internal LAN and to the "Catch all" rule
    #1. The choice of the setting for this option is up to the policy
    designer. Some people find it more intuitive to leave it off and
    add rules to control access to and from the firewall
    explicitly. Note that default policy for all chains is set to DROP
    with the following commands at the very top of the generated
    iptables script:
  </p>

  <pre class="command">
$IPTABLES -P OUTPUT  DROP
$IPTABLES -P INPUT   DROP
$IPTABLES -P FORWARD DROP
  </pre>

  <p>
    This means that if you do not add rules to permit access to the
    firewall and turn option "Assume firewall is part of any" off,
    then all generated iptables rules will be in the FORWARD chain and
    all access to the firewall itself will be blocked by the default
    policy in the INPUT chain. On the other hand, if the option
    "Assume firewall is part of any" is on, then the rule permitting
    access from internal network to "any" gets side effect of
    permitting access to the firewall as well. It is up to you to
    decide whether this is a good or bad thing. You can always
    restrict access to the firewall and control it with a few rules
    somewhere close to the beginning of the policy regardless of the
    setting of this option.
  </p>

  <p>
    Even if you choose to turn option "Assume firewall is part of any"
    off and do not add any rules to permit access to the firewall in
    your policy rule set, you can use another option in the firewall
    object "advanced" settings dialog for this. The option is called
    "Always permit ssh access to the firewall from management station"
    and allows you to enter single ip address or subnet and then
    automatically adds a rule to the generated script to permit ssh
    access to the firewall from this address. We demonstrate this
    feature in one of the following articles.
  </p>

  <p>
    <strong>Examples below have been compiled with the option "Assume
    firewall is part of any" turned on.</strong>
  </p>

  <p>
    Here is the PF configuration created for the same rules:
  </p>

  <pre class="command">
# Rule  0 (global)
# 
pass  quick inet  from 192.168.1.0/24  to any keep state 
# 
# Rule  1 (global)
# 
block  log  quick inet  from any  to any 
  </pre>
      
  <p>
    Firewall Builder always generates PF configuration using
    its <emphasis>"quick"</emphasis> clause to switch to the
    first-match mode. In this PF configuration example, the first
    rule permits packets with source address on the 192.168.1.0/24
    network and stops processing. The second rule will only
    inspect packets not matched by the first rule.
  </p>


  <p>
    Here is the fragment of the PIX config generated for the same
    combination of rules:
  </p>

  <pre class="command">
! Rule  0 (global)
! 
access-list inside_acl_in  remark 0 (global)
access-list inside_acl_in permit ip 192.168.1.0 255.255.255.0 any 
! 
! Rule  1 (global)
! 
access-list outside_acl_in  remark 1 (global)
access-list outside_acl_in deny   ip any any log 4 interval 300 
access-list dmz50_acl_in  remark 1 (global)
access-list dmz50_acl_in deny   ip any any log 4 interval 300 
access-list inside_acl_in  remark 1 (global)
access-list inside_acl_in deny   ip any any log 4 interval 300 


access-group dmz50_acl_in in interface dmz50
access-group inside_acl_in in interface inside
access-group outside_acl_in in interface outside
  </pre>

  <p>
    Since source address in the rule #0 is limited to the internal
    network, policy compiler was able to determine which interface
    the access list command should be associated with and added it
    only to the ACL <emphasis>"inside_acl_in"</emphasis>.
  </p>

  <p>
    The <emphasis>"access-group"</emphasis> commands are actually
    located at the very bottom of the generated script, after all
    other <emphasis>access-list</emphasis> commands. It is shown
    right next to the ACL rules here for presentation.
  </p>
  
  <!-- ********************************************************* -->

  <h2>Letting certain protocols through, while blocking everything
      else</h2>

  <p>This is one of the simplest, most basic tasks you may want your
    firewall to do - block all the traffic while letting certain protocols
    through. Let's assume that we have a network consisting of just the
    firewall "firewall1" and a few hosts behind it. We want to let SMTP 
    through to the mail server from the Internet, and block
    everything else. All we need to do is put the following rules in the
    Global Policy:</p>

  <img src="policy-1.png" />

  <p>
    Rule #0 allows SMTP through to the server, while rule #1
    blocks and logs everything else. It is worth mentioning that
    this policy also blocks all the access to firewall itself,
    including access to it from internal hosts.
  </p>

  <p>
    We do not need any additional rules to take care of "reply"
    packets coming back from the server to clients because our
    underlying firewall software supports stateful inspection and
    "understands" that such packets should be let through.
  </p>

  <p>
    Here is iptables script generated for these two simple rules:
  </p>

  <pre class="command">
$IPTABLES -A INPUT   -m state --state ESTABLISHED,RELATED -j ACCEPT
$IPTABLES -A OUTPUT  -m state --state ESTABLISHED,RELATED -j ACCEPT
$IPTABLES -A FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPT

# Rule 0 (global)
# 
$IPTABLES -A OUTPUT -p tcp -m tcp  -d 192.168.1.100  \
    --dport 25  -m state --state NEW  -j ACCEPT 
$IPTABLES -A FORWARD -p tcp -m tcp  -d 192.168.1.100 \
    --dport 25  -m state --state NEW  -j ACCEPT 
# 
# Rule 1 (global)
# 
$IPTABLES -N RULE_1
$IPTABLES -A OUTPUT  -m state --state NEW  -j RULE_1 
$IPTABLES -A INPUT  -m state --state NEW  -j RULE_1 
$IPTABLES -A FORWARD  -m state --state NEW  -j RULE_1 
$IPTABLES -A RULE_1  -j LOG  --log-level info --log-prefix "RULE 1 -- DENY "
$IPTABLES -A RULE_1  -j DROP 
  </pre>

  <p>
    Generated iptables rules were placed in
    both <emphasis>OUTPUT</emphasis> and <emphasis>FORWARD</emphasis>
    chains because option "Assume firewall is part of any" was turned
    on in the "Advanced" settings dialog of this firewall object.  In
    other words, using "Any" in Source of the rule was equivalent to
    using a combination of any address and the firewall. Resultant
    iptables commands should be placed in
    the <emphasis>OUTPUT</emphasis> chain to match packets generated
    by the firewall and <emphasis>FORWARD</emphasis> to match packets
    crossing the firewall. If you turn this option off, the program
    will only generate iptables rules in
    the <emphasis>FORWARD</emphasis> chain for this rule.
  </p>

  <p>
    Here is the code generated for PF for the same rule:
  </p>

  <pre class="command">
# Rule  0 (global)
# 
pass  quick inet proto tcp  from any  to 192.168.1.100 port 25 keep state 
# 
# Rule  1 (global)
# 
block  log  quick inet  from any  to any 
  </pre>

  <p>
    In PF we do not have to worry about chains and there is no
    option "Assume firewall is part of any" because there is no
    difference.
  </p>

  <p>
    Here is the code generated for PIX for the same rule:
  </p>

  <pre class="command">
! Rule  0 (global)
! 
access-list outside_acl_in  remark 0 (global)
access-list outside_acl_in permit tcp any host 192.168.1.100 eq 25 
access-list dmz50_acl_in  remark 0 (global)
access-list dmz50_acl_in permit tcp any host 192.168.1.100 eq 25 
access-list inside_acl_in  remark 0 (global)
access-list inside_acl_in permit tcp any host 192.168.1.100 eq 25 
! 
! Rule  1 (global)
! 
access-list outside_acl_in  remark 1 (global)
access-list outside_acl_in deny   ip any any log 0 interval 300 
access-list dmz50_acl_in  remark 1 (global)
access-list dmz50_acl_in deny   ip any any log 0 interval 300 
access-list inside_acl_in  remark 1 (global)
access-list inside_acl_in deny   ip any any log 0 interval 300 
  </pre>

  <p>
    In PIX, all access lists must be attached to interfaces of the
    firewall. Since the rule did not specify source address, the
    program has to generate access lists that would match any
    source, which means they should be attached to all interfaces
    of the firewall. Since my PIX test object has three
    interfaces: <emphasis>outside</emphasis>, <emphasis>inside</emphasis>
    and <emphasis>dmz</emphasis>, I ended up with ACL lines in
    three access lists, one for each interface.
  </p>

<!-- ********************************************************* -->

  <h2> Letting certain protocols through from specific source.</h2>

  <p>
    In this example, we look at the rule that is similar to the
    previous one, but also matches source address. This rule
    permits access to the mail server inside from mail relay on
    DMZ and from no other source. Generated rules for iptables and
    pf are very similar, they just add source address
    matching. Generated rules for PIX are different because now
    the program can intelligently pick the right access list and
    avoid generating redundant rules.
  </p>


  <img src="policy-1-2.png" />


  <p>
    Here is the code generated for iptables from this rule:
  </p>

  <pre class="command">
# Rule 0 (global)
# 
$IPTABLES -A FORWARD -p tcp -m tcp  -s 192.168.2.22   -d 192.168.1.100  \
    --dport 25  -m state --state NEW  -j ACCEPT 
  </pre>

  <p>
    Since source rule element was limited to the host on DMZ,
    generated iptables rule is placed only in the FORWARD chain
    and also matches the source using "-s" clause.
  </p>

  <p>
    Lets look at the configuration generated for PIX from the same rule:
  </p>

  <pre class="command">
! Rule  0 (global)
! 
access-list dmz50_acl_in  remark 0 (global)
access-list dmz50_acl_in permit tcp host 192.168.2.22 host 192.168.1.100 eq 25 


access-group dmz50_acl_in in interface dmz50
access-group inside_acl_in in interface inside
access-group outside_acl_in in interface outside
  </pre>

  <p>
    the rule was placed only in the access list attached to the
    DMZ interface because packets with source address of the host
    on DMZ can only cross this interface of the firewall, assuming
    spoofed packets are blocked by special rule, which will
    discuss below.
  </p>

<!-- ********************************************************* -->

  <h2>Anti-spoofing rules</h2>

  <p>
    Generally speaking, IP spoofing is a technique of generating
    IP packets with source address that belongs to someone
    else. Spoofing creates a danger when hosts on the LAN permit
    access to their resources and services to trusted hosts by
    checking the source IP of the packets.  Using spoofing, an
    intruder can fake the source address of his packets and make
    them look like they originated on the trusted hosts. The basic
    idea of anti-spoofing protection is to create a firewall rule
    assigned to the external interface of the firewall that
    examines source address of all packets crossing that interface
    coming from outside. If the address belongs to the internal
    network or the firewall itself, the packet is dropped.
  </p>

  <p>
    Simple anti-spoofing rule looks like shown on
    the next screenshot. Unlike the rule in the
    previous example, anti-spoofing rule requires matching of the
    interface and direction. The idea is that packets that come
    from outside must not have source addresses that match
    internal network or the firewall itself. The only way to
    distinguish packets coming from outside from those coming from
    inside is to check which interface of the firewall they cross
    and in which direction. Here the rule matches
    interface <emphasis>eth0</emphasis>, which is external, and direction
    <emphasis>inbound</emphasis>.
  </p>

  <p>
    Article <a href="http://www.howtoforge.com/using-firewall-object-in-firewall-builder">Using
    Firewall Object In Firewall Builder </a> explains how a firewall
    object and its interfaces can be created.
    Article <a href="http://www.howtoforge.com/firewall-access-policy-rulesets-part-1">
    Firewall Access Policy Rulesets, Part 1</a> explains the concept
    of direction.
  </p>

  <img src="policy-antispoof-rule-1.png" />

  <p>
    Here are the iptables commands generated for this rule:
  </p>

  <pre class="command">
# Rule 0 (eth0)
# 
# anti spoofing rule
# 
$IPTABLES -N In_RULE_0
$IPTABLES -A INPUT  -i eth0   -s 192.0.2.1   -j In_RULE_0 
$IPTABLES -A INPUT  -i eth0   -s 192.168.1.1   -j In_RULE_0 
$IPTABLES -A INPUT  -i eth0   -s 192.168.1.0/24   -j In_RULE_0 
$IPTABLES -A FORWARD  -i eth0   -s 192.0.2.1   -j In_RULE_0 
$IPTABLES -A FORWARD  -i eth0   -s 192.168.1.1   -j In_RULE_0 
$IPTABLES -A FORWARD  -i eth0   -s 192.168.1.0/24   -j In_RULE_0 
$IPTABLES -A In_RULE_0  -j LOG  --log-level info --log-prefix "RULE 0 -- DENY "
$IPTABLES -A In_RULE_0  -j DROP 
  </pre>

  <p>
    Iptables commands were placed in INPUT and FORWARD chains to
    match both packets that are headed for the firewall and
    through the firewall to hosts behind it. Rules match source
    address of the packets and then log and drop them. Fwbuilder
    generated iptables commands to match all addresses of the
    firewall (192.168.1.1, 192.0.2.1) and network behind it
    (192.168.1.0/24). 
  </p>

  <p>
    Lets see what gets generated for the same rule for PF:
  </p>

  <pre class="command">
# Tables: (1)
table &lt;tbl.r0.s&gt; { 192.0.2.1 , 192.168.1.1 } 

# Rule  0 (en0)
# anti spoofing rule
# 
block in   log  quick on en0 inet  from &lt;tbl.r0.s&gt;  to any 
block in   log  quick on en0 inet  from 192.168.1.0/24  to any 
# 
  </pre>
  
  <p>
    Here compiler uses tables to make generated PF code more
    compact. Table <emphasis>tbl.r0.s</emphasis> can be used in
    other rules wherever we need to operate with all addresses of
    the firewall.
  </p>

  <p>
    Here is the same rule, compiled for PIX:
  </p>

  <pre class="command">
! Rule  0 (Ethernet1/0)
! anti-spoofing rule
! 
access-list outside_acl_in  remark 0 (Ethernet1/0)
access-list outside_acl_in  remark anti-spoofing rule
access-list outside_acl_in deny   ip host 192.0.2.1 any 
access-list outside_acl_in deny   ip host 192.168.2.1 any 
access-list outside_acl_in deny   ip host 192.168.1.1 any 
access-list outside_acl_in deny   ip 192.168.1.0 255.255.255.0 any

access-group outside_acl_in in interface outside
  </pre>

<!-- ********************************************************* -->

  <h2>Anti-spoofing rules for the firewall with dynamic address</h2>

  <p>
    Anti-spoofing rule must match all addresses of the firewall to
    leave no holes. However it is difficult to do if one interface
    of the firewall gets its ip address dynamically via DHCP or
    PPP protocol. This address is unknown at the compile time and
    proper configuration can not be generated by just including
    it. Some firewall platforms have syntax in their configuration
    language that provides a way to match an address of an
    interface at run time, but other platforms do not have
    anything like this. Lets see how fwbuilder works around this problem.
  </p>

  <p>
    In this test I use variation of the same firewall object where
    external interface <emphasis>"eth0"</emphasis> is configured
    as "dynamic". The anti-spoofing rule looks exactly like the
    rule in the previous example and matches the same external
    interface "eth0", direction "inbound":
  </p>

  <img src="policy-antispoof-rule-2.png" />

  <p>
    Generated iptables script looks like this:
  </p>

  <pre class="command">
getaddr eth0  i_eth0


# Rule 0 (eth0)
# 
# anti spoofing rule
# 
$IPTABLES -N In_RULE_0
test -n "$i_eth0" && $IPTABLES -A INPUT  -i eth0   -s $i_eth0   -j In_RULE_0 
$IPTABLES -A INPUT  -i eth0   -s 192.168.1.1   -j In_RULE_0 
$IPTABLES -A INPUT  -i eth0   -s 192.168.1.0/24   -j In_RULE_0 
test -n "$i_eth0" && $IPTABLES -A FORWARD  -i eth0   -s $i_eth0   -j In_RULE_0 
$IPTABLES -A FORWARD  -i eth0   -s 192.168.1.1   -j In_RULE_0 
$IPTABLES -A FORWARD  -i eth0   -s 192.168.1.0/24   -j In_RULE_0 
$IPTABLES -A In_RULE_0  -j LOG  --log-level info --log-prefix "RULE 0 -- DENY "
$IPTABLES -A In_RULE_0  -j DROP 
  </pre>

  <p>
    The script defines shell
    function <emphasis>"getaddr"</emphasis> at the beginning. This
    function uses <emphasis>"ip addr show"</emphasis> command to
    determine actual address of the interface at the time when
    script is running and assigns the address to the shell
    variable <emphasis>i_eth0</emphasis>. Iptables commands then
    use this variable to build rules matching address of this
    interface. Otherwise generated rules are the same as in the
    previous example.
  </p>

  <p>
    Here is what is generated for PF:
  </p>

  <pre class="command">
table &lt;tbl.r0.d&gt; { en0 , 192.168.1.1 } 

# Rule  0 (en0)
# anti spoofing rule
# 
block in   log  quick on en0 inet  from &lt;tbl.r0.d&gt;  to any 
block in   log  quick on en0 inet  from 192.168.1.0/24  to any 
  </pre>

  <p>
    In PF, one can place interface name ("en0") in the table and
    PF will use its address at the execution time.
  </p>

  <p>
    Unfortunately there is no workaround for this problem for PIX.
  </p>

<!-- ********************************************************* -->

  <h2>Using groups</h2>

  <p>
    Sometimes we need to define a lot of very similar rules for
    multiple hosts or networks. For example, there may be a need
    to permit the same service to 10 different hosts on the
    network, while still blocking it to all others. The simplest
    way to accomplish this is to add 10 rules with the same source
    and service fields and just different destinations. Another
    method is to add 10 objects to the Source or Destination rule
    element of the same rule. Both methods can make firewall
    policy quite cluttered and hardly readable.  To avoid this we
    can use groups. Group is just a container which includes
    references to multiple objects of the same or similar type.
    Firewall Builder supports groups of objects and groups of
    services. You can
    put <emphasis>"Address"</emphasis>, <emphasis>"Host"</emphasis>, <emphasis>"Network"</emphasis>
    and <emphasis>"Firewall"</emphasis> objects in an object
    group, but you cannot put service objects in a such
    group. Similarly, a service group can contain <emphasis>"IP Service"</emphasis>,
    <emphasis>"TCP Service"</emphasis>, <emphasis>"UDP
      Service"</emphasis> and <emphasis>"ICMP Service"</emphasis>
      objects, but cannot contain hosts or networks. Groups can
      contain other groups of the same type as well. Screenshot below
      represents object group used in this example.
  </p>


  <p>
    Groups not only make policy rules more readable, another great
    advantage of object groups is that they are reusable. You can
    now have many different rules using this same group object. If
    you ever need to add another host or address to the group, you
    only need to do it once and all rules will automatically pick
    the change after recompile.
  </p>

  <img src="policy-rule-group-object.png" />

  <p>
    To add objects to a group simply drag them from the tree on
    the left into group view on the right, or use Copy/Paste
    functions available via menus.
  </p>

  <p>
    Once appropriate group has been created, it can be used for
    the policy and NAT rules just like any other object.
  </p>

  <img src="policy-rule-group-1.png" />

  <p>
    Here is iptables commands generated for this example:
  </p>

  <pre class="command">
# Rule 0 (global)
# 
$IPTABLES -N Cid17843X27745.0
$IPTABLES -A INPUT -p tcp -m tcp  --dport 22 -m state --state NEW  -j Cid17843X27745.0 
$IPTABLES -A Cid17843X27745.0  -s 192.168.1.110   -j ACCEPT 
$IPTABLES -A Cid17843X27745.0  -s 192.168.1.111   -j ACCEPT 
$IPTABLES -A Cid17843X27745.0  -s 192.168.1.112   -j ACCEPT 
  </pre>

  <p>
    Generated iptables command is placed only in
    the <emphasis>INPUT</emphasis> chain because it controls
    access to the firewall and not to any addresses across it.
    The first iptables command matches chain, tcp port and state.
    If this rule does not match the packet, there is no need to
    waste CPU cycles checking source ip addresses. However if the
    first rule matches, it passes control to the special
    user-defined chain "Cid17843X27745.0" where it checks source
    address of the packet. If compiler were to generate iptables
    script not using this temporary chain, it would end up
    comparing tcp port and state three times, together with each
    possible source address. This can be rather wasteful if the
    rule should match a lot of addresses. Separation of the
    matches using temporary chain can improve performance a lot.
  </p>

  <p>
    Compiler decides whether to use temporary chain not because
    administrator used object group in source in the original rule
    in the GUI, but because it determined that in the end it needs
    to compare source address of the packet against several
    addresses defined in the policy. If the group contained just
    one address, the generated iptables script would have
    consisted of just one iptables command without temporary
    chain. If there was no group in "Source" of the rule but
    instead all these host objects were placed in "source" of the
    rule directly, generated iptables script would look exactly
    like shown above, using temporary chain for optimization.
  </p>


  <p>
    Here is the code generated for PF for the same rule:
  </p>


  <pre class="command">
table &lt;tbl.r0.d&gt; { 192.0.2.1 , 192.168.1.1 } 
table &lt;tbl.r0.s&gt; { 192.168.1.110 , 192.168.1.111 , 192.168.1.112 } 

# Rule  0 (global)
# 
pass  quick inet proto tcp  from &lt;tbl.r0.s&gt;  to &lt;tbl.r0.d&gt; port 22 keep state 
  </pre>

  <p>
    Policy compiler for PF extensively uses tables to produce
    compact code. PF tables are reused when needed.
  </p>

  <p>
    Here is the config generated for PIX:
  </p>

  <pre class="command">
object-group network inside.id20599X27745.src.net.0
  network-object  host 192.168.1.110 
  network-object  host 192.168.1.111 
  network-object  host 192.168.1.112 
exit

! Rule  0 (global)
! 
access-list inside_acl_in  remark 0 (global)
access-list inside_acl_in permit tcp object-group inside.id20599X27745.src.net.0
      host 192.0.2.1 eq 22 
access-list inside_acl_in permit tcp object-group inside.id20599X27745.src.net.0
      host 192.168.1.1 eq 22 
! 
  </pre>

  <p>
    Just like in case of iptables, it is not that a group object
    was used in the original rule what triggered using
    <emphasis>object-group</emphasis> PIX clause. Compiler always
    checks the number of objects it needs to compare the packet
    against and uses
    <emphasis>object-groups</emphasis> statements to optimize
    generated code as appropriate.
  </p>

<!-- ********************************************************* -->

  <h2>Using Address Range instead of a group</h2>


  <p>
    In the example above, three hosts used for the
    group <emphasis>"management hosts"</emphasis> have consecutive
    addresses 192.168.1.110, 192.168.1.111,
    192.168.1.112. Although this example may be artificial, it
    allows us to illustrate how a different type of object could
    be used to achieve the same goal - to permit access to the
    firewall from these three addresses. The difference may be
    negligible when we deal with just three addresses, but when
    the list gets into hundreds it may become significant.
  </p>

  <p>
    Since addresses of the management hosts are consecutive, we
    can use Address Range object to describe them:
  </p>

  <img src="policy-rule-address-range-object.png" />

  <p>
    We use this object in the rule just like any other object. Here is
    how the rule looks like:
  </p>

  <img src="policy-rule-with-address-range.png" />

  <p>
    The main difference in generated code for the rule using
    Address Range compared to the rule using collection of
    individual addresses is that compiler is allowed to optimize
    it. It tries to squeeze the address range to the minimal set
    of address and network objects. Here is how it looks like for
    iptables:
  </p>

  <pre class="command">
# Rule 0 (global)
# 
$IPTABLES -A INPUT  -s 192.168.1.110/31   -m state --state NEW  -j ACCEPT 
$IPTABLES -A INPUT  -s 192.168.1.112   -m state --state NEW  -j ACCEPT
  </pre>

  <p>
    Again, the difference may not be very great when we have only
    three ip addresses, but in case of a range that span hundred
    addresses the performance gain and reduction in the size of
    generated script are significant.
  </p>

  <p>
    Generated PF and PIX configurations look similar.
  </p>

  <p>
    We will contniune with even more complex examples of policy access
    rules in the next article.
  </p>



  <p>
    References:
    <ul>
      <li><a href="http://www.fwbuilder.org/">Project web site: http://www.fwbuilder.org/</a></li>

      <li><a href="http://www.fwbuilder.org/docs/firewall_builder_packages.html">Source code, Linux .deb and .rpm package repositories, <strong>Windows</strong> and <strong>Mac OS X</strong> binary packages</a>

      <li><a href="http://www.fwbuilder.org/docs/UsersGuide3.pdf">Firewall Builder Users Guide (PDF)</a></li>
      <li><a href="http://www.fwbuilder.org/docs/users_guide/book1.htm">Firewall Builder Users Guide (HTML)</a></li>

      <li><a href="http://www.fwbuilder.org/guides/firewall_builder_cookbook.html">
          <b>Examples of iptables, pf and other rules: Firewall
            Builder Cookbook</b></a></li>

      <li><a href="http://blog.fwbuilder.org/">Project announcements
          and status: Firewall Builder Project Blog</a></li>


    </ul>
  </p>



</body>
</html>
