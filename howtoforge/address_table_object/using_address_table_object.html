<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Firewall Builder: Using Address Table Object | HowtoForge - Linux Howtos and Tutorials</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<style type="text/css">
<!--
.command {
    padding: 1em;
    border: 1px dashed #2f6fab;
    color: black;
    background-color: #f9f9f9;
    line-height: 1.1em;
        font-family: Courier New, Courier, mono;
        font-size: 12px;
        font-style: italic;
}

.system {
    color: black;
        font-family: Courier New, Courier, mono;
        font-size: 12px;
        font-style: italic;
}

.highlight {
    color: #FF0000;
        font-family: Georgia, "Times New Roman", Times, serif;
        font-size: 12px;
        text-decoration: underline;
}
-->
</style>
</head>

<body>
  


  <h1>Using Address Table Object in Firewall Builder</h1>

  <table border=0>
    <tr>
      <td><img src="http://www.fwbuilder.org/images/icon_128x128.png" height="128" width="128" /></td>
      <td>Author: vadim@fwbuilder.org<br/>
        <a href="http://www.fwbuilder.org">Firewall Builder project page: http://www.fwbuilder.org</a>
      </td>
    </tr>
  </table>


  <p>
    This article continues the series of articles on Fireall Builder,
    a graphical firewall configuration and management tool that
    supports many Open Source firewall platforms as well as Cisco IOS
    access lists and Cisco ASA (PIX).  Firewall Builder was introduced
    on this site earlier with articles
    <a href="http://www.howtoforge.com/getting-started-with-firewall-builder">
    Getting Started With Firewall Builder</a>, 

    <a href="http://www.howtoforge.com/using-built-in-revision-control-in-firewall-builder">Using
    Built-In Revision Control In Firewall Builder</a>, 

    <a href="http://www.howtoforge.com/using-built-in-policy-installer-in-firewall-builder">
      Using Built-in Policy Installer in Firewall Builder</a>, 

    <a href="http://www.howtoforge.com/using-firewall-object-in-firewall-builder">
      Using Firewall Object In Firewall Builder</a>.
  </p>

  <p>
    This article demonstrates how you can build firewall rules
    matching sets of ip addresses stored in external files.
  </p>

  <p>
    More information on Firewall Builder, pre-built binary packages
    and source code, documentation and <b>Firewall Builder
    Cookbook</b> can be found on
    <a href="http://www.fwbuilder.org/">
    the project web site at
    http://www.fwbuilder.org/</a>. Follow <a href="http://blog.fwbuilder.org/">
    Firewall Builder Project Blog</a> for announcements and articles
    on all aspects of using Firewall Builder.
  </p>

  <h1>Address Table Object</h1>

  <p>Sometimes you need to apply a rule to a set of addresses, but
  you don't know what those addresses will be when you're writing
  the policy. The Address Table object can help.</p>

  <img src="address_table_2.png" alt="address table object dialog in fwbuilder GUI">

    <p>The Address Table object has the following fields:</p>

    <ul compact="compact">
      <li>
        <p>Name:</p>

        <p>The name of the Address Table object</p>
      </li>

      <li>
        <p>Compile Time / Run Time:</p>

        <p>Indicate whether you want the file to be loaded with the
        firewall compiler runs (Compile Time) or when the firewall
        runs the firewall script (Run Time).</p>
      </li>

      <li>
        <p>File name:</p>

        <p>The name of the text file you want to load. (The file
        contains IP addresses or IP address ranges.) The filename can
        have any extension. If you want the file to load at run time,
        you must specify the path and name where the file will be on
        the <emphasis><i>firewall</i></emphasis> machine, not the
        client machine.</p>
      </li>

      <li>
        <p>Browse button:</p>

        <p>Used to populate the file name and path if the file is
        on the local machine.</p>
      </li>

      <li>
        <p>Preview button:</p>

        <p>Once the File name field is populated, use this button
        to view the file.</p>
      </li>

      <li>
        <p>Comment:</p>

        <p>A free-form text field used for comments</p>
      </li>
    </ul>

    <p>The "Compile Time" and "Run Time" radio buttons define when the
      addresses will be read from the file: when the firewall script
      is generated by Firewall Builder or when the firewall runs the
      script. If object is configured as "Compile Time", the Firewall
      Builder policy compiler opens the file during compilation and
      replaces the "Address Table" object in policy rules with the set
      of addresses from the file. This means the file with addresses
      must be accessible on the machine where the Firewall Builder GUI
      and policy compilers run. If the object is configured as "Run
      Time", policy compiler does not try to find and open the file
      but instead generates a firewall script that will do this when
      it is activated. This means the file with addresses must be
      located where it is accessible by the firewall, and the object
      must be configured with the full path to it on the firewall.</p>

  <p>Here is an example of the file contents (this is what you
    see if you click "Preview" button in the object dialog):</p>
  
  <p><img src="address_table_4.png" alt="address table object contents in fwbuilder GUI"></p>

    <p>Note that comments in the file can start with '#' or ';',
    that a comment can follow an address on the same line or take
    the whole line and that lines can start with white space for
    formatting. This example file contains both IPv4 and IPv6
    addresses for illustration purposes.</p>

    <p>Compile-time Address Table objects are supported on all target
    firewall platforms because addresses are read by the compiler. The
    compiler then generates normal configuration lines or script
    commands. Run time Address Table objects require special support
    from the target firewall and therefore supported only on some of
    them. <b>Currently Run Time Address Table objects can be used in
    rules for iptables and PF firewalls</b>.</p>

    <p>Let's look at the firewall script generated by Firewall Builder
    for the iptables and PF when the Address Table object used in the
    policy rule is configured first as "Compile Time" and then as "Run
    Time". The rule is very simple and looks like this:
    </p>

  <p><img src="address_table_3.png" alt="policy rule using address table object in fwbuilder GUI"></p>

    <p>This rule, with the object set to "Compile Time", generates the
    following output:</p>

  <h3>Compile Time, iptables compile output</h3>

    <pre class="command">
# Rule 0 (global)
# 
$IPTABLES -A INPUT  -d 192.168.1.1  -j DROP 
$IPTABLES -A FORWARD  -d 192.168.1.2  -j DROP 
$IPTABLES -A FORWARD  -d 192.168.1.3/30  -j DROP 
$IPTABLES -A FORWARD  -d 192.168.2.128/25  -j DROP 
$IPTABLES -A FORWARD  -d 192.168.1.200  -j DROP 
$IPTABLES -A FORWARD  -d 192.168.1.201  -j DROP 
</pre>

    <p>The compiler replaced object "address_table_1" in the
    Destination with addresses it took from the file. Option "assume
    firewall is part of any" was turned off in the firewall object
    settings, which is why compiler did not generate rules in the
    OUTPUT chain. However one of the addresses in the file matched the
    address of one of the interfaces of the firewall (192.168.1.1) and
    the corresponding rule went into the INPUT chain. Other addresses
    were copied from the file verbatim, including netmask
    specifications. The Policy object of this firewall was configured
    as "IPv4 rule set", because of this the compiler dropped the IPv6
    addresses it found in the file. If the rule set was configured as
    a mix of IPv4 and IPv6, compiler would use IPv4 addresses in IPv4
    rules and IPv6 addresses in IPv6 rules.</p>

  <h3>Compile Time, PF compile output</h3>

      <pre class="command">
# Tables: (1)
table  { 192.168.1.1 , 192.168.1.2 , 192.168.1.3/30 , 192.168.2.128/25 , \
192.168.1.200 , 192.168.1.201 }

# Rule  0 (global)
# 
block in   quick inet  from any  to &lt;tbl.r0.d&gt;
block out  quick inet  from any  to &lt;tbl.r0.d&gt;

</pre>

    <p>The output for PF is simple because Firewall Builder can use
    the built-in table facility. All addresses are copied from the
    file verbatim into the table tbl.r0.d.</p>

  <h3>Run Time, iptables compile output</h3>

  <pre class="command">
# Using 1 address table files
check_file "address_table_1" "/home/vadim/addr-table-1.tbl"

# Rule 0 (global)
# 
grep -Ev '^#|^;|^\s*$' /home/vadim/addr-table-1.tbl | while read L ; do
  set $L; at_address_table_1=$1; $IPTABLES -A FORWARD  -d $at_address_table_1  -j DROP 
done
</pre>

    <p>First, the generated script checks if the file specified in
    the Address Table object exists on the firewall machine. If the
    file is not found, the script aborts execution to avoid loading
    incomplete iptables rules. However, the script cannot verify
    that the file is the one you intended it to be, it just assumes
    that if the file with this name exists it is the right one and
    tries to interpret it as a list of IP addresses, with one
    address per line. Then the script reads the file line by line,
    skipping comments, and assigns IP addresses to the shell
    variable at_address_table_1, which it then uses in the iptables
    command.</p>

    <p>Since the compiler did not see the addresses from the file,
    it could not detect that one of them matched an address of the
    firewall and all iptables commands went to the FORWARD chain.
    The file /home/vadim/addr-table-1.tbl should be located on the
    firewall where the generated iptables script will be executed
    so the script can find it.</p>

    <p>Here is what you get if the option "Assume firewall is part of
    any" is turned on in the firewall object settings:</p>

  <h3>Run Time, iptables compile output, assume firewall is part of
      "any"</h3>

  <pre class="command">

# Rule 0 (global)
# 
grep -Ev '^#|^;|^\s*$' /home/vadim/addr-table-1.tbl | while read L ; do
  set $L; at_address_table_1=$1; $IPTABLES -A OUTPUT  -d $at_address_table_1  -j DROP 
done
grep -Ev '^#|^;|^\s*$' /home/vadim/addr-table-1.tbl | while read L ; do
  set $L; at_address_table_1=$1; $IPTABLES -A FORWARD  -d $at_address_table_1  -j DROP 
done
</pre>

    <p>The difference is that compiler generated two sets of commands,
    one in chain OUTPUT and another in chain FORWARD. The original
    rule has "any" in source, and if option "Assume firewall is part
    of any" is turned on, the compiler assumes the source of the rule
    can have either an unknown address or the firewall. The former
    makes it generate iptables command in the FORWARD chain and the
    latter makes it generate iptables command in the OUTPUT
    chain. This logic is not specific to the Address Table object
    type; the compiler does this regardless of the type of the object
    used in destination if source is "any" and option "Assume firewall
    is part of any" is turned on.</p>

    <h3>Run Time, PF compile output</h3>

    <pre class="command">

# Tables: (1)
table  persist file "/home/vadim/addr-table-1.tbl"
# Rule  0 (global)
# 
# 
block in   quick inet  from any  to &lt;address_table_1&gt;
block out  quick inet  from any  to &lt;address_table_1&gt;
</pre>

    <p>PF is even easier in the case of run time address tables.
    Compiler just uses <i>table</i> facility with <i>persist</i> and
    <i>file</i> options to direct pfctl to open the file and read its
    contents.  In this case the file should follow formatting
    requirements of PF.</p>

    <p>Policy compiler for PF treats Address Table objects with
    empty file name specially. It just generates the line "table
    &lt;table_name&gt;" at the beginning of the .conf file with no
    file specification. This table will not be populated when .conf
    file is loaded and therefore will remain empty, but it can be
    used in the rules.</p>

    <p>Addresses can be added to the table later using external
    scripts that call pfctl like this:</p>

    <pre class="command">

pfctl -t bad_hosts -T add 192.0.2.1

</pre>

    <h3>Using Dynamically Populated Run Time Address Table Object with PF</h3>

    <p>Another interesting possibility is to automatically populate
    the table if option "overload" is used in combination with
    other rate limiting options on a rule. Taking an example from
    the man page for pf.conf, here is how it looks:</p>

    <pre class="command">

block quick from &lt;bad_hosts&gt;
pass in on $ext_if proto tcp to $webserver port www keep state \
                   (max-src-conn-rate 100/10, overload &lt;bad_hosts&gt; flush global)
</pre>

    <p>The idea behind these rules is that if some host tries to
    connect to the web server too often&mdash;more often than is
    allowed by max-src-conn-rate 100/10&mdash;its address will be
    added to the table &lt;bad_hosts&gt; by PF. The next time this
    host tries to connect, the packet coming from it will be denied
    by the blocking rule right away.</p>

    <p>To implement these rules in Firewall Builder, you would
    create an Address Table object with name "bad_hosts" but a
    blank file name, configured to resolve at run time:</p>

  <p><b>Address Table Object bad_hosts</b></p>
  
  <p><img src="address_table_5.png"  alt="address table object with empty table in fwbuilder GUI"></p>

  <p>Then, use this Address Table object in the source field of a
    policy rule with action "Deny". This is rule #0 in the screenshot
    below. Another rule, rule #1 in the screenshot, has action
    "Accept" and matches destination against address of the web
    server, protocol http, and has limiting options set up to restrict
    the number of connections and to turn <span class=
    "guilabel">overload table</span> on, with the name of the overload
    table "bad_hosts" that matches the name of the Address Table
    object.</p>

  <p><b>Address Table Object bad_hosts Rules</b></p>

  <p><img src="address_table_6.png" alt="policy rules using address table object with dynamically populated addresses in fwbuilder GUI"></p>

  <p>These two rules, as shown on the screen shots, yield the
    following PF configuration that matches the one given in the man
    page:</p>

  <pre class="command">

# Tables: (1)
table &lt;bad_hosts&gt; persist

# Rule  0 (global)
# 
block in   log  quick inet  from &lt;bad_hosts&gt;  to any 
# 
# Rule  1 (global)
# 
pass in   quick inet proto tcp  from any  to 192.168.1.1 port 80 \
   keep state  (  max-src-conn-rate 100/10, overload &lt;bad_hosts&lt; flush global ) 

</pre>



</body>
</head>
</html>
