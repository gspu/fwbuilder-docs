<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Firewall Builder: Using Firewall Object | HowtoForge - Linux Howtos and Tutorials</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<style type="text/css">
<!--
.command {
    padding: 1em;
    border: 1px dashed #2f6fab;
    color: black;
    background-color: #f9f9f9;
    line-height: 1.1em;
        font-family: Courier New, Courier, mono;
        font-size: 12px;
        font-style: italic;
}

.system {
    color: black;
        font-family: Courier New, Courier, mono;
        font-size: 12px;
        font-style: italic;
}

.highlight {
    color: #FF0000;
        font-family: Georgia, "Times New Roman", Times, serif;
        font-size: 12px;
        text-decoration: underline;
}
-->
</style>
</head>

<body>

  <h1>Using Addressable Objects in Firewall Builder</h1>

  <p>
    Firewall Builder supports variety of object types,
    both simple such as address, network, host, or IP,
    TCP, UDP and ICMP services, as well as more
    sophisticated such as Firewall, Host, Address table,
    DNS name, User service. In this article, we examine
    object types that represent addresses or groups of
    addresses.
  </p>


  <h2>Common Properties of Objects </h2>

  <p>
    All objects in Firewall Builder have some
    characteristics in common.  All objects have a Name
    field and a Comment field. The Name field can contain
    white spaces and can be arbitrarily long (though
    shorter names work better in the GUI). The Comment
    field can contain any text of any length.
  </p>

  <p>
    Objects that contain IP address fields provide
    validity checking for the address when the object is
    saved.  Invalid IP addresses produce an error.
  </p>

  <h2>IPv4 Address Object</h2>

  <p>
    The regular address object describes single IPv4
    address. It can be a child of an interface object,
    in which case it represents its IP address and
    netmask, or it can be used as a standalone
    object. In the latter case it does not have netmask
    and is located in the
    <b>Objects/Addresses</b> branch of the objects tree.
  </p>

  <h3>IPv4 Address Object When Used as an Address of an Interface</h3>

  <p>
    In this case this object is located directly under
    the interface object. This could be interface of a
    Host or a Firewall object. To create this kind of an
    Address, use context menu associated with the
    Interface (right mouse click on the Interface object
    in the tree to open the menu).
  </p>

  <img src="ipv4_1.png"/>

  <p>
    Its dialog provides the following entry fields:
  </p>

  <p>
    <ul>
      <li>
        Name -- This is the name of the object. Use a
        descriptive name because when the address object
        is used in the flrewall policy, it is labeled
        with this name. It may be hard to tell one
        address from another if their names are similar.
      </li>

      <li>
        Address -- This is an IP address. The GUI widget
        provides syntax control for the values entered
        in the octet fields.  (This syntax control
        activates when you save the object.)

        <blockquote>Note: A typical error is to
          interpret this object as an address of the
          subnet to which the interface of the host or
          flrewall belongs. This object represents an
          address of the interface, not a network
          address. (So, 192.168.1.1, not 192.168.1.0)
        </blockquote>
      </li>

      <li>
        Netmask -- This is a netmask assigned to the
        interface. You can enter the netmask using the
        traditional method (255.255.255.0) or using
        network bit length notation ("24"). Bit length
        type netmask is converted to a traditional
        netmask by Firewall Builder.
      </li>

      <li>
        DNS Lookup -- If parent host or firewall object
        has the same name as the actual machine, then
        clicking this button generates a DNS query that
        populates the interface IP address and
        subnet. Only parent host or firewall object's
        name is used for the DNS query, name of the
        parent interface is ignored and can be anything.
      </li>

      <li>
        Comment -- This is free-form text field for a
        comment.
      </li>
    </ul>
  </p>

  <p>
    Consider rule as shown on the screenshot below where
    we use IPv4 address shown on the screenshot above
    (remember, it belongs to the interface):
  </p>

  <img src="ipv4_1_rule_1.png"/>

  <p>
    In case of iptables Firewall Builder generates the
    following command from this rule:
  </p>

  <p>
    <p class="command">
      $IPTABLES -A INPUT -p tcp -m tcp  -d 172.16.22.1  --dport 22  -m state --state NEW  -j ACCEPT 
    </p>
  </p>

  <blockquote>
    Note how even though the Address object has a netmask,
    generated command matches its address as a host
    address. This is because the netmask is only used to
    describe subnet the interface is connected to. When
    this address object is used in a rule, it is
    understood that the intention is to match the address
    of the interface it belongs to rather than any address
    on the subnet. Use Network object if you need to match
    whole subnet.
  </blockquote>

  <p>
    This iptables rule was placed in the <b>INPUT</b>
    chain because object in the "Destination" was an
    address of an interface of the firewall. While
    processing the policy for the iptables target firewall
    platform, Firewall Builder compares addresses in
    source and destination of a rule to the addresses of
    all interfaces of the firewall to find rules that
    control access to and from the firewall and places
    them into <b>INPUT</b> or <b>OUTPUT</b> chains. This
    is only necessary for iptables.
  </p>

  <h3>IPv4 Address Object When Used as Stand-alone Object</h3>

  <p>
    In this case this object is located in
    the <b>Objects / Addresses</b> part of the objects
    tree and does not have netmask entry field.  To
    create this kind of an Address, use main <b>New
      Object</b> menu item <b>New Address</b> or context
    menu associated with the <b>Addresses</b> folder in
    the tree (right mouse click on the Interface object
    in the tree to open the menu).
  </p>

  <img src="ipv4_2.png"/>

  <p>
    Dialog fields <b>Name</b>, <b>Address</b>
    and <b>Comment</b> have the same purpose and
    properties as in the case of the Address object
    used to describe an addresses of an interface.
  </p>

  <p>
    DNS Lookup button can be used to automatically
    populate the address field using DNS query. The
    program runs DNS query for the "A" record with the
    name of the Address object. The name does not have
    to match any DNS record if you never plan to use
    this feature and can populate the address
    manually. DNS query function is just a convenience,
    but to use it, the name of the object must match DNS
    record.
  </p>

  <h2>IPv6 Address Object</h2>

  <p>
    The IPv6 address object is similar to the IPv4
    address object. Just like IPv4 address, it can be
    used both as a child of an interface object or as
    stand-alone.
  </p>

  <h3>IPv6 Address Object When Used as an Address of an Interface</h3>

  <p></p>

  <img src="ipv6_1.png"/>

  <p>
    If it is used to describe IPv6 address of an
    interface, it has a netmask represented as bit
    length. Unlike with IPv4 address object, netmask of
    IPv6 is never represented as full colon-separated
    string of octets.
  </p>

  <h3>IPv6 Address Object When Used as Stand-alone Object</h3>

  <p></p>

  <img src="ipv6_2.png"/>

  <p>
    In this case this object is located in
    the <b>Objects / Addresses</b> part of the objects
    tree (the same place where stand-alone IPv4
    addresses are located) and does not have netmask
    entry field.  To create this kind of an Address, use
    main <b>New Object</b> menu item <b>New Address
      IPv6</b> or context menu associated with
    the <b>Addresses</b> folder in the tree (right mouse
    click on the Interface object in the tree to open
    the menu).
  </p>

  <p>
    Policy compilers treat IPv6 addresses in policy rules
    according to the same algorithms as those for IPv4
    rules. For example, just like with IPv4, compiler
    for iptables checks if address matches address of
    any interface of the firewall to determine if the
    rule should be placed in <b>INPUT</b>
    or <b>OUTPUT</b> chain.
  </p>

  <p>
    Consider rule as shown on the screenshot below where
    we use two IPv6 address objects. One object belongs
    to the interface <b>inside</b> of the firewall while
    another is IPv6 address of the project's web site.
  </p>

  <img src="ipv6_1_rule_1.png"/>

  <p>
    For iptables, Firewall Builder generates the
    following commands from this rule:
  </p>

  <p>
    <p class="command">
      $IP6TABLES -A INPUT -p tcp -m tcp  -d fe80::21d:9ff:fe8b:8e94  --dport 80  -m state --state NEW  -j ACCEPT <br>
      $IP6TABLES -A FORWARD -p tcp -m tcp  -d 2001:470:1f0e:162::2  --dport 80  -m state --state NEW  -j ACCEPT <br>
    </p>
  </p>

  <p>
    The rule that matches address described by
    object <b>guardian-2:eth1:ipv6</b> went to
    the <b>INPUT</b> chain because compiler detected that
    this rule matches packets that are headed for the
    firewall itself, which iptables inspects in
    the <b>INPUT</b> chain. Rule that matches address
    described by the object <b>ipv6.fwbuilder.org</b>
    went to the <b>FORWARD</b> chain because these packets
    go through the firewall.
  </p>

  <h2>The Physical Address Object</h2>

  <img src="physaddress1.png"/>

  <p>
    The Physical Address object describes the hardware
    or media address. For Ethernet this would be the MAC
    address of the interface. Currently only Ethernet
    MAC addresses are supported but support for other
    kinds may be added in the future. Physical Address
    object can only be a child of an interfaces, it can
    not exist as a stand-alone object. To create this
    kind of address object, use context menu associated
    with the interface object, item <b>"Add MAC
      Address"</b>. Only one Physical Address object is
    allowed per interface, the program enforces this
    restriction. If you create Firewall or Host object
    using SNMP discovery, all interfaces will be
    automatically populated with their MAC addresses.
  </p>

  <p>
    <ul>
      <li>
        Name -- This is the name of the object. The
        field is populated automatically with a
        host:interface:addressType descriptive name when
        the object is created, however you can change it
        later. If you change the name, use something
        descriptive because when the address object is
        used in the firewall policy, it is labeled with
        this name. It may be hard to tell one address
        from another if their names are similar.
      </li>

      <li>
        Address -- This is a string representation of
        the physical or media address. For many types of
        media, this will be in a binary
        representation. For example, an ethernet address
        would be represented as a string of 6 octets.
      </li>

      <li>
        Comment -- This is free-form text field for a comment. 
      </li>
    </ul>
  </p>

  <h3>Using The Physical Address Object in Policy Rules</h3>

  <p>
    Only a few flrewall platforms really support physical
    address flltering. Currently Netfllter/iptables is the
    only flrewall platform that can do it and is
    supported by Firewall Builder.
  </p>

  <p>
    if the Interface object that has multiple Address
    and Physical Address child objects is used in the
    policy or the NAT rule element (either Source or
    Destination), then the policy compiler tries to
    generate a rule using all of them. Compiler actually
    does this by generating multiple rules using each
    address in turn. This roughly corresponds to using
    logical operation "OR" on these addresses: if our
    interface had two addresses Address1 and Address2,
    then the generated rule would match if address in
    the packet is either Address1 OR Address2. The case
    of a Physical Address is different though. If the
    Interface has a physical address, then compiler
    tries to build a set of rules that matches on
    combination of each IP address and its MAC
    address. The reason for this change is as follows:
  </p>

  <p>
    Suppose we have a very important host on the
    network. We create a Host object, then add an
    interface to it. The interface should have both
    Address and Physical Address objects as shown on
    the following screenshot (these two child objects are
    visible in the tree under the Interface <b>eth0</b>):
  </p>

  <img src="using-physaddress-1.png"/>

  <blockquote>
    Note how checkbox <b>"MAC matching"</b> in the Host
    object dialog is checked, this makes compiler use
    MAC addresses of the interfaces of this host.
  </blockquote>

  <p>
    Because this is a very important host, we would like
    to be sure that packets whose source IP is that of
    this host are really coming from it and are not
    spoofed. The best way to achieve this goal is to use
    strong authentication, for example with IPSEC
    protocol. Using IPSEC is outside the scope of this
    document though; our goal right now is to show that
    inspecting MAC address of the packet can improve
    security.
  </p>

  <p>
    Both the real packet originated from this host and a
    spoofed packet have a source IP address of the
    interface of this host, but a source MAC address is
    going to be different if spooflng is going on. We can
    use this to catch and drop spoofed packets. Here are
    three possible ways to build security policy in this
    situation:
  </p>

  <p>
    <ul>
      <li>
        <p>
          Using only Address object in the rule
          element. This means the flrewall inspects only IP
          address and ignores the MAC address of the
          packets.
        </p>
        <img src="using-physaddress-4.png"/>
        <p>
          Firewall Builder generates the following
          simple iptables command for this rule:
          <p class="command">
            $IPTABLES -A FORWARD  -s 10.3.14.44  -m state --state NEW  -j ACCEPT 
          </p>
        </p>
      </li>

      <li>
        <p>
          Using only Physical Address object. A rule
          built this way permits all kinds of trafflc
          coming from the trusted host even if its IP
          address changes.
        </p>
        <img src="using-physaddress-5.png"/>
        <p>
          For this rule, the following iptables command
          is generated:
          <p class="command">
            $IPTABLES -A FORWARD  -m mac --mac-source 00:1D:09:8B:8E:94 -m state --state NEW  -j ACCEPT 
          </p>
        </p>
      </li>

      <li>
        <p>
          Using Host or Interface object. This way we
          end up with a rule that matches on a
          combination of the IP address and MAC
          address. This may be used as a sophisticated
          anti-spooflng rule.
        </p>
        <img src="using-physaddress-6.png"/>
        <img src="using-physaddress-3.png"/>
        <p>
          For this rule, the following iptables command
          is generated:
          <p class="command">
            $IPTABLES -A FORWARD  -m mac --mac-source 00:1D:09:8B:8E:94 -s 10.3.14.44  -m state --state NEW  -j ACCEPT 
          </p>
        </p>
      </li>
    </ul>
  </p>

  <p>
    Using Address and Physical Address objects in a
    rule is not the same as using a Host or
    Interface object to which these Address and
    Physical Address belong. Here is what happens if
    we put objects representing IP address and MAC
    address in the rule:
  </p>

  <img src="using-physaddress-7.png"/>

  <p>
    For this rule, the following iptables command
    is generated:
    <p class="command">
      $IPTABLES -A FORWARD  -s 10.3.14.44  -m state --state NEW  -j ACCEPT <br>
      $IPTABLES -A FORWARD  -m mac --mac-source 00:1D:09:8B:8E:94 -m state --state NEW  -j ACCEPT <br>
    </p>
  </p>

  <p>
    Using multiple objects in the rule element is like
    bundling them together using logical operation
    OR. If put Address and Physical Address in the rule
    like in the screenshot above, we end up with policy
    matching packets that have the source address
    10.3.14.44 or MAC address 00:1D:09:8B:8E:94, but not
    necessarily both at the same time. Any host that
    manages to pretend to have the IP address 10.3.14.44
    would be able to send packets through our flrewall
    even if its MAC address is different. To achieve our
    goal and make sure packets with the source IP
    10.3.14.44 really belong to our important host, we
    should be checking its IP address and MAC address at
    the same time and let a packet through only if its
    IP address AND MAC address are what we expect them
    to be. That is why Firewall Builder treats physical
    addresses differently and generates flrewall code
    that inspects both IP address and physical address.
  </p>

  <p>
    Firewall Builder generates flrewall code to
    inspect MAC address only for Host objects with
    the option "MAC address flltering" turned on. If
    this option is off, the Physical Address object
    will be ignored even if it is present in the
    Host object’s Interface. This is because Host
    objects created using the Network Discovery
    Druid are populated with both IP address and MAC
    address information which is available through
    SNMP query, but inspection of MAC addresses is
    rarely needed. You can use the MAC address
    flltering option in the Host object to specify
    that you want the MAC address to be verifled for
    the host.
  </p>

  <blockquote>
    Target firewall imposes certain restrictions on the
    ruels matching MAC address, for example only source
    MAC address can be matched. Firewall Builder is
    aware of these restrictions, policy compiler will
    issue an error if Physical Address object is used in
    a rule that would lead to an impossible iptables
    command.
  </blockquote>

  <h2>The Host Object</h2>

  <p>
    The host object in Firewall Builder is designed to
    represent real hosts in the network: workstations,
    servers, and any other network node with an
    address. Just like real hosts, the host objects have
    interfaces, representing different physical
    connections to the network. Most Internet hosts will
    have just a single (visible) interface with a single
    IP address. In that case the actual interface and
    its name do not matter.  For most foreign hosts,
    Firewall Builder will assign an arbitrary name
    “interface1” to the hosts interface.  By using a
    tree-like hierarchy of hosts -> interfaces ->
    addresses it is possible however to specify the
    exact address and/or interface of a host in the case
    when it does matter. Both interfaces and addresses
    are represented by objects, which are organized in a
    tree. Interface objects sit in the tree directly
    under the host, and the address objects are located
    under their interfaces. The interface object can
    have either one or multiple addresses. An example of
    a host with one interface with multiple addresses
    are shown in the screenshot below. Host <b>“test
      server”</b> has three virtual IP addresses that all
    belong to the same interface <b>“eth0”</b>.
  </p>


  <blockquote>
    Note that in Firewall Builder, the host object is an
    abstraction. It does not have to conform to an
    individual host. This host object may in fact
    represent a web farm that accepts connections on
    three IP addresses, each on a different computer.
  </blockquote>

  <img src="host_in_tree.png"/>

  <blockquote>
    Note: The host object cannot have any access, NAT or
    routing policy associated with it; only firewall
    objects can have policies.
  </blockquote>

  <h2>Creating Host Object</h2>

  <p></p>

  <img src="creating_host1.png"/>

  <p>
    To speed up the process and make it simpler,
    creating a new host object is aided by the wizard
    which collects all data needed for both the host and
    its interfaces and then creates the object. The
    screenshot above represents the first page of the
    wizard.
  </p>

  <p>
    Enter the host name. Generally, this name does not
    have to be the same as the real host’s
    name. However, if you are going to use SNMP to
    populate the host’s interfaces, or if you are going
    to use DNS to look up interface IP addresses, the
    name does have to match.
  </p>

  <p>
    You can create a new host from a template by
    checking corresponding checkbox on the first page of
    the wizard, or you can do it manually. Lets look at
    the manual process. To do this, click "Next" button
    to switch to the page where you can enter interfates
    and their addresses.
  </p>
  
  <img src="creating_host2.png"/>

  <p>
    If the new host object has a single interface (this,
    perhaps, is the most common case) then you just need
    to fill the entry field for its address and maybe MAC
    address and click Next. If the object’s name is the
    same as the real host name, then you can use the DNS
    Lookup button to get the address from DNS.
  </p>

  <p>
    Here you can add interfaces to the new host
    object. Enter the interface name, address, and
    netmask in the appropriate fields, then
    click <b>"Add"</b> to add it to the list. (If the
    interface is dynamic or unnumbered, then click the
    appropriate checkbox instead of entering address
    information.) The <b>"Update"</b> button updates
    information for the interface that is selected in
    the list, and the <b>"Delete"</b> button deletes the
    currently selected interface.
  </p>

  <p>
    This method only works for IPv4 addresses. If you
    need to add an IPv6 address, save the host object
    without the IPv6 address, then add the IPv6 address
    to the interface.
  </p>

  <blockquote>
    Note: You can always add, modify and remove
    interfaces of the new host object later using
    controls provided by the main window and the object
    tree view.
  </blockquote>

  <h3>Editing a Host Object</h3>

  <p></p>

  <img src="host_dialog1.png"/>

  <p>
    The Host object dialog allows you to edit the
    following parameters:
  </p>

  <p>
    <ul>
      <li>
        Name -- The Host object name. 
      </li>

      <li>
        MAC matching -- If this option is activated, the
        policy compiler uses the MAC addresses of all
        interfaces of this host in the ﬁrewall
        rules. Not all ﬁrewall platforms support MAC
        address ﬁltering, so this option may have no
        effect on the generated ﬁrewall script. This is
        treated as a non-critical situation, and the
        policy compiler will only generate a warning
        while processing a ﬁrewall policy where such a
        host is used.
      </li>

      <li>
        Comment -- This is a free-form text ﬁeld which
        can be used to add comments.
      </li>
    </ul>
  </p>


  <h3>Using Host Object in Rules</h3>

  <p>
    When Host object is used in a rule, it acts as a
    group of all of its addresses, that is, adresses
    that belong to all of its interfaces. The only
    exception is loopback interface; compilers skip its
    address when they replace Host object with its
    addresses.
  </p>

  <p>
    Consider the following Host object. It has
    interface <b>eth0</b> with two IP addresses and a
    MAC address, interface <b>he-ipv6</b> with IPv6
    address and a MAC address, interface <b>lo</b>
    (loopback) with its own IP address and
    interface <b>sit0</b> (tunnel) with no address.
  </p>

  <img src="host_example_1.png"/>

  <p>
    Lets put this host object in a rule as follows:
  </p>

  <img src="host_example_2.png"/>

  <p>
    The rule set is configured as "IPv4 only", so even
    though interface <b>he-ipv6</b> has IPv6 address,
    fwbuilder will ignore it while generating iptables
    commands for this rule. Interface <b>eth0</b> has two
    IPv4 addresses and both will be used. Here are iptables
    commands generated for this rule:
  </p>

  <p>
    <p class="command">
      $IPTABLES -A FORWARD -p tcp -m tcp  --dport 22  -m state --state NEW  -j Cid6066X5981.1 <br>
      $IPTABLES -A Cid6066X5981.1  -d 10.3.14.44  -j ACCEPT <br>
      $IPTABLES -A Cid6066X5981.1  -d 10.3.14.55  -j ACCEPT <br>
      $IPTABLES -A Cid6066X5981.1  -d  -j ACCEPT <br>
    </p>
  </p>

  <p>
    Lets see what we get for the same rule if we configure
    rule set object as "IPv4+IPv6":
  </p>

  <img src="host_example_3.png"/>

  <p>
    Since rule is now configured to compile for both
    address families, fwbuilder processes it twice,
    using on each pass only those addresses of the host
    that match address family. Here is what we get
    (these are relevant fragments of the generated script):
  </p>

  <p>
    <p class="command">
      # ================ IPv4<br>
<br>
      $IPTABLES -A FORWARD -p tcp -m tcp  --dport 22  -m state --state NEW  -j Cid6066X5981.1 <br>
      $IPTABLES -A Cid6066X5981.1  -d 10.3.14.44  -j ACCEPT <br>
      $IPTABLES -A Cid6066X5981.1  -d 10.3.14.55  -j ACCEPT <br>
      $IPTABLES -A Cid6066X5981.1  -d  -j ACCEPT <br>
<br>
      # ================ IPv6<br>
<br>
      $IP6TABLES -A FORWARD -p tcp -m tcp  --dport 22  -m state --state NEW  -j Cid6066X5981.1 <br>
      $IP6TABLES -A Cid6066X5981.1  -d fe80::a3:e2c  -j ACCEPT <br>
    </p>
  </p>

  <h2>Interface Object</h2>

  <img src="interface-1.png"/>

  <p>
    Interface objects belong to firewall or host
    objects. Interface objects cannot exist alone.  The
    dialog for the interface object that belongs to the
    firewall or host provides controls for the parameters
    described here.
  </p>

  <p>
    <ul>
      <li>Name: The name of the interface object in
        Firewall Builder must match exactly the name of
        the interface of the firewall machine it
        represents. This will be something like "eth0",
        "eth1", "en0", "br0", and so on.
      </li>

      <li>Label: On most OS’s this field is not used and
        serves the purpose of a descriptive
        label. Firewall Builder GUI uses a label, if it
        is not blank, to show interfaces in the
        tree. One of the suggested uses for this field is
        to mark interfaces to reflect the network
        topology (’outside’, ’inside’) or the purpose
        (’web frontend’ or ’backup subnet’). The label
        is mandatory for Cisco PIX though, where it must
        reflect the network topology.
      </li>

      <li>Management interface: When firewall has
        several network interfaces, one of them can be
        marked as the ’management interface’. The
        management interface is used for all
        communication between Firewall Builder and the
        firewall. For example, built-in policy installer
        uses address of the management interface to
        connect to the firewall via ssh when it copies
        generated script or configuration
        file to it.
      </li>

      <li>External interface (insecure): Marks an
        interface that connects to the Internet.
      </li>

      <li>Unprotected interface: Marks interface to
        which Firewall Builder should not assign any
        access lists or firewall rules. Unprotected
        interfaces are recognized by policy compilers
        for Cisco IOS access lists and PF. Compiler for
        IOS ACL just skips unprotected interfaces and
        does not assign any ACL to them when it choses
        which interface to associate given ACL
        with. Compiler for PF generates "set skip
        on <interface_name>" clause for unprotected
          interfaces.
      </li>

      <li>Regular Interface: Use this option if the
        interface has an IP address assigned to it
        manually (static IP address).
      </li>

      <li>Address is assigned dynamically: Use this
        option if the interface has a dynamic address
        (obtained by means of DHCP or PPP or another
        protocol). In this case an address is unknown at
        the moment when Firewall Builder generates the
        Firewall policy. Some firewalls allow for using
        the interface name in the policy instead of its
        IP address; the firewall engine then picks its
        address either when the policy is activated or
        even at run-time. Some other firewalls support
        special syntax for rules that are supposed to
        match packets headed to or from the firewall
        machine. Examples of these two cases are OpenBSD
        PF and Netfilter. PF rules can be constructed
        using interface names; PF automatically uses the
        current interface address when it loads rules
        into the memory. Netfilter supports special
        "chains" called "INPUT" and "OUPUT" that are
        guaranteed to inspect only packets headed for
        the firewall machine ("INPUT") or originated on
        it ("OUTPUT"). Both methods allow Firewall
        Builder to build correct firewall policy rules
        that affect the interface with a dynamic IP
        address, however the interface must be marked as
        such for the policy compiler to use proper
        technique depending on the target firewall
        platform. In cases where the rule has to use
        actual IP address of the interface (example:
        anti-spoofing rules), compiler emulates this
        feature by adding shell script fragment to
        determine the address at the time when firewall
        script is executed and then uses the address in
        rules. Such emulation is only possible on
        platforms where firewall configuration is in the
        form of the shell script, most notably this is
        iptables script on Linux.
      </li>

      <li>Unnumbered interface: Use this option if the
        interface can never have an IP address, such as
        the Ethernet interface used to run PPPoE
        communication on some ADSL connections, or
        tunnel endpoint interface. Although unnumbered
        interface does not have an address, firewall
        policy rules or access lists can be associated
        with it.
      </li>

      <li>Bridge port: This option is used for port of
        bridged firewall. Compilers skip bridge ports
        when they pick interfaces to attach policy and
        nat rules to. For target firewall platforms that
        support bridging and require special
        configuration parameters to match bridged
        packets, compilers use this attribute to
        generate proper configuration. For example, in
        case of iptables compiler uses <b> -m
          physdev --physdev-in</b> or <b> -m physdev --physdev-out</b>
        for bridge port interfaces.
      </li>

      <li>Security level: Depending on the firewall
        platform, the security level is either
        External/Internal or a numeric value between 0
        and 100, with 0 being least secure and 100 being
        most secure levels. This field in the GUI dialog
        automatically shows controls appropriate to the
        current firewall. Not all firewall support the
        concept of a security zone.
      </li>

      <li>Network zone: Network zone of this interface,
        used only with Cisco PIX (ASA). Network zone
        drop-down list shows all network objects and
        groups of addresses and networks present in the
        tree.  Choose one of them to tell the compiler
        which networks and blocks of addresses can be
        reached through this interface. Usually the
        external interface (the one which connects your
        firewall to the Internet) has the Network Zone
        set to Any. It is also recommended that you
        create a group of objects to represent Network
        Zones for all other interfaces on the firewall.
        The compiler uses this information to decide
        which interface each ACL rule should be
        associated with based on the addresses used in
        the destination of the rule.
      </li>
    </ul>
  </p>                      




  <h3>More about Security Levels and Network Zones </h3>

  <p></p>

  <p>
    Consider the network layout shown in the following
    screenshot.
  </p>

  <img src="fwbuilder-using-netzone1.jpg"/>

  <p>
    Here the firewall has three interfaces: ’outside’,
    ’dmz’, and ’inside’. Behind the firewall there is a
    router which in turn is connected to three subnets
    ’subnet A’, ’subnet B’, and ’subnet C’. Subnet A is
    shared between the router and the firewall (each
    device has an interface on this subnet). Let’s also
    suppose that we have created Network Objects for
    each subnet and called them ’subnet DMZ’, ’subnet
    A’, ’subnet B’ and ’subnet C’ (remember, spaces are
    allowed in object names). For this setup, network
    zones should be configured as follows:
  </p>

  <p>
    <table border=1 cellspacing=0>
      <tr>
        <th>Interface</th> <th>Network Zone</th>
      </tr>

      <tr>
        <td>outside</td>   <td>ANY </td>
      </tr>

      <tr>
        <td>dmz</td> <td>subnet DMZ </td>
      </tr>

      <tr>
        <td>inside</td> <td>subnet A, subnet B, subnet C </td>
      </tr>
    </table>
  </p>

  <p>
    Since the network zone for the ’inside’ interface
    consists of multiple objects, a group must be
    created so that you could use this group as a
    Network Zone object.
  </p>


  <p>
    The following explains the differences in the way
    firewall platforms interpret values in the Security
    Level and Network Zone parameters of the firewall
    interfaces.
  </p>

  <p>
    <table border=1 cellspacing=0>
      <tr>
        <th>Firewall Platform</th> <th>Security Level Values</th> <th>Network Zone</th>
      </tr>

      <tr>
        <td>iptables</td> <td>two values: ’External’ or ’Internal’ </td> <td>N/A </td>
      </tr>

      <tr>
        <td>ipfilter</td> <td>two values: ’External’ or ’Internal’</td> <td>N/A </td>
      </tr>

      <tr>
        <td>pf</td> <td> two values: ’External’ or ’Internal’ </td> <td>N/A </td>
      </tr>

      <tr>
        <td>Cisco PIX</td> <td> numeric, 0 - 100</td> <td> a reference to a group or network object </td>
      </tr>
    </table>


  </p>

  <blockquote>
    Note that "external" interface option may be
    deprecated in the future versions of the program
  </blockquote>

  <p>
    In PIX, access lists must always be attached to
    interfaces. Policy compiler for PIX uses information
    about network zones of interfaces to decide which
    interface a rule should be associated with if its
    "interface" column does not specify one (is left set
    to "All"). Instead of placing this rule in access
    lists attached to all interfaces, it compares
    addresses in "source" and "destination" of the rule
    with network zones of interfaces and uses only
    interfaces that match. This helps generate PIX
    configuration that is more compact.
  </p>





  <h3>Using Interface Object in Rules</h3>

  <p></p>

  <p>
    Policy rules in Firewall Builder have special rule
    element or column called "Interface". You can drag
    and drop, or copy/paste interface object into this
    column of a rule to make the firewall match not only
    source and destination address and service, but also
    interface of the firewall through which packets
    enter or exit it. The direction is defined by the
    setting in the column "Direction". Consider the
    following example:
  </p>

  <img src="rules_with_interface_1.png"/>

  <p>
    Rule #0 is "anti-spoofing" rule which relies on the
    ability to define interface and direction. It
    matches packets with source addresses equal to the
    addresses of the firewall's interfaces or internal
    network. This packets are coming in from outside,
    which is determined by comparing the interface
    through which they enter the firewall. Packets with
    addresses like these can not normally come from
    outside, and so if they do, they must be spoofed and
    should be dropped. This is what this rule does, it
    drops and logs these packets. Rule #1 permits
    connections originating from the internal network
    going out, but it makes sure these packets enter the
    firewall through its internal interface. 
  </p>

  <p>
    these two rules generate the following iptables script:

    <p class="command">
      # <br>
      # Rule 0 (eth0)<br>
      # <br>
      $IPTABLES -N In_RULE_0<br>
      $IPTABLES -A FORWARD  -i eth0  -s 192.0.2.1  -j In_RULE_0 <br>
      $IPTABLES -A FORWARD  -i eth0  -s 172.16.22.1  -j In_RULE_0 <br>
      $IPTABLES -A FORWARD  -i eth0  -s 192.168.2.1  -j In_RULE_0 <br>
      $IPTABLES -A FORWARD  -i eth0  -s 172.16.22.0/24  -j In_RULE_0 <br>
      $IPTABLES -A In_RULE_0  -j LOG  --log-level info --log-prefix "RULE 0 -- DENY "<br>
      $IPTABLES -A In_RULE_0  -j DROP <br>
      # <br>
      # Rule 1 (eth1)<br>
      # <br>
      $IPTABLES -A FORWARD  -i eth1  -s 172.16.22.0/24  -m state --state NEW  -j ACCEPT <br>
    </p>
  </p>

  <p>
    Here all iptables command got <b>"-i eth0"</b>
    or <b>"-i eth1"</b> clause which makes iptables
    compare the interface and direction.
  </p>

  <p>
    Here is what we get if we compile the same rules for PF:

    <p class="command">
      # Tables: (1)<br>
      table &lt;tbl.r9999.d&gt; { 192.0.2.1 , 172.16.22.1 , 192.168.2.1 } <br>
<br>
      # <br>
      # Rule  0 (eth0)<br>
      # <br>
      block in   log  quick on en0 inet  from &lt;tbl.r9999.d&gt;  to any<br>
      block in   log  quick on en0 inet  from 172.16.22.0/24  to any<br>
      # <br>
      # Rule  1 (eth1)<br>
      # <br>
      pass in   quick on en1 inet  from 172.16.22.0/24  to any keep state<br>
      # <br>
    </p>
  </p>

  <p>
    For PF, compiler generated <b>block in quick log on
      eth0</b> clause to make the rule match interface and
    direction.
  </p>

  <p>
    In case of Cisco IOS access lists, defining
    interface in the rule makes compiler place code
    generated for this rule into ACL attached to the
    given interface. Compiler for IOS ACL always
    generates both inbound and outbound access lists for
    each interface, but if the rule specifies both
    interface and direction "Inbound" or "Outbound",
    generated configuration goes only in to
    corresponding access list. Here is the output
    produced for the rules shown above for Cisco IOS
    ACL:

    <p class="command">
      ip access-list extended inside_in<br>
      ! Rule  1 (eth1)<br>
      ! <br>
      permit ip 172.16.22.0 0.0.0.255 any  <br>
      exit<br>
<br>
      ip access-list extended outside_in<br>
      ! Rule  0 (eth0)<br>
      ! <br>
      deny   ip host 192.0.2.1 any  log <br>
      deny   ip host 192.168.2.1 any  log <br>
      deny   ip 172.16.22.0 0.0.0.255 any  log <br>
      exit<br>
<br>
      interface FastEthernet1<br>
      ip access-group inside_in in<br>
      exit<br>
      interface FastEthernet0<br>
      ip access-group outside_in in<br>
      exit<br>
    </p>
  </p>


              <p>
                So far examples in this chapter demonstrated how to
                use interface objects to associate policy rules with
                interfaces to match packets crossing certain
                interface. Interface object can be used in "soruce"
                and "destination" of rules just like any other
                addressable object. In this case, fwbuilder replaces
                interface object with a set of its addresses, picking
                only those addresses that match address family (IPv4
                or IPv6) assigned to the rule set. Here is how this
                looks like. We start with a firewall configuration
                where interface <b>eth1</b> has two ip addresses, one
                IPv4 and another is IPv6. Note that this could be a
                host object as well because interface can belong
                either to a firewall or a host object.
              </p>

              <img src="interface-2.png"/>

              <p>
                Interface <b>eth1</b> has IPv4 address 172.16.22.1 and
                IPv6 address fe80::21d:9ff:fe8b:8e94; it is used in a
                simple policy rule as follows:
              </p>

              <img src="interface-rule-1.png"/>

              <p>
                Policy rule set is configured as a mixed IPv4+IPv6
                rule set. For the iptables, compilers generate the
                following code:
              </p>

              <p>
                <p class="command">
# ================ IPv4 <br>
# Rule 0 (global) <br>
#  <br>
$IPTABLES -A INPUT -p tcp -m tcp  -d 172.16.22.1  --dport 22  -m state --state NEW  -j ACCEPT  <br>
 <br>
# ================ IPv6 <br>
 <br>
# Rule 1 (global) <br>
#  <br>
$IP6TABLES -A INPUT -p tcp -m tcp  -d fe80::21d:9ff:fe8b:8e94  --dport 22  -m state --state NEW  -j ACCEPT  <br>
                </p>
              </p>

              <p>
                For PF we get the following:
                <br/>
                <p class="command">
# Rule  0 (global) <br>
#  <br>
#  <br>
pass in   quick inet proto tcp  from any  to 172.16.22.1 port 22 keep state <br>
pass out  quick inet proto tcp  from any  to 172.16.22.1 port 22 keep state <br>
 <br>
# Rule  0 (global) <br>
#  <br>
#  <br>
pass in   quick inet6 proto tcp  from any  to fe80::21d:9ff:fe8b:8e94 port 22 keep state <br>
pass out  quick inet6 proto tcp  from any  to fe80::21d:9ff:fe8b:8e94 port 22 keep state <br>
                </p>
              </p>

              <p>
                Since interface has two addresses, one IPv4 and
                another IPv6, compiler generated commands in both IPv4
                section and in IPv6 section of the script, but it used
                only the right address of the interface in each. Other
                than that, interface object behaves just like a set of
                addresses when used in the source or destination
                element of a rule. It can also be used in NAT rules,
                here is an example:
              </p>
              
              <img src="interface-nat-rule-1.png"/>

              <p>
                this generates the following code for iptables:

                <p class="command">
# Rule 0 (NAT) <br>
#  <br>
$IPTABLES -t nat -A POSTROUTING -o eth0  -s 172.16.22.0/24 -j SNAT --to-source 192.0.2.1  <br>
#  <br>
# Rule 1 (NAT) <br>
#  <br>
$IPTABLES -t nat -A PREROUTING  -p tcp -m tcp   -d 192.0.2.1 --dport 80 -j DNAT --to-destination 172.16.22.100  <br>
                </p>
              </p>

              <p>
                And for PF:
                <br/>
                <p class="command">
# Rule  0 (NAT) <br>
#  <br>
nat on eth0 proto {tcp udp icmp} from 172.16.22.0/24 to any -> 192.0.2.1  <br>
#  <br>
# Rule  1 (NAT) <br>
#  <br>
rdr on eth0 proto tcp from any to 192.0.2.1 port 80 -> 172.16.22.100 port 80  <br>
                </p>
              </p>

              <h3>Using Interface Object with Dynamic Address in Rules</h3>

                <p></p>

              <p>
                Examples above demonstrated what happens when an
                interface with one or several IP addresses is used in
                policy and NAT rules. Lets look at the case when
                interface has address assigned dynamically. This means
                the address is unknwown to fwbuilder policy compiler
                when it generates configuration script. Compiler uses
                features of the target firewall to work around this.
                Here is the configration of the interface
                object <b>eth0</b>, the radio-button "Address is
                assigned dynamically" is checked.
              </p>

              <img src="interface-3.png"/>
                
              <p>
                The following policy rule uses interface <b>eth0</b>
                in destination:
              </p>

              <img src="interface-rule-3.png"/>

              <p>
                Here is what we get for iptables
                <br/>

                <p class="command">
getaddr eth0  i_eth0 <br>
getaddr6 eth0  i_eth0_v6 <br>
 <br>
# ================ IPv4 <br>
 <br>
# Rule 0 (global) <br>
#  <br>
test -n "$i_eth0" && $IPTABLES -A INPUT -p tcp -m tcp  -d $i_eth0  --dport 22  -m state --state NEW  -j ACCEPT  <br>
 <br>
# ================ IPv6 <br>
 <br>
# Rule 0 (global) <br>
#  <br>
test -n "$i_eth0_v6" && $IP6TABLES -A INPUT -p tcp -m tcp  -d $i_eth0_v6  --dport 22  -m state --state NEW  -j ACCEPT  <br>
                </p>
              </p>

              <p>
                Shell functions <b>getaddr</b> and <b>getaddr6</b> are
                defined earlier in the script. Generated script
                determines IPv4 and IPv6 ip addresses of the
                interface <b>eth0</b> at the time of execution and
                then uses the values in iptables commands. If
                interface does not have an address, corresponding
                variable gets an empty string for its value and
                iptables command using it is skipped.
              </p>

              <p>
                PF allows for using interface name in rules and gets
                its current ip address automatically. Here is what is
                generated for PF:

                <p class="command">
# Rule  0 (global) <br>
#  <br>
pass in   quick inet proto tcp  from any  to (en0) port 22 keep state <br>
pass out  quick inet proto tcp  from any  to (en0) port 22 keep state <br>
 <br>
# Rule  0 (global) <br>
#  <br>
pass in   quick inet6 proto tcp  from any  to (en0) port 22 keep state  <br>
pass out  quick inet6 proto tcp  from any  to (en0) port 22 keep state <br>
                </p>
              </p>

              <p>
                We still get two separate parts for IPv4 and IPv6
                because the rule set is configured as IPv4+IPv6 mix,
                but in both cases compiler just used interface name
                because its actual IP address is dynamic and was unknown
                at the time when configuration was generated.
              </p>



  <h3>Using Interface Object in Rules of Bridging iptables Firewall</h3>

  <p></p>

  <p>
    In case of the "normal" iptables firewall, fwbuilder
    adds <b>"-i eth0"</b> or <b>"-o eth0"</b> parameter
    to the generated iptables command to make it match
    interface and direction. If radio-button 
    <b>"Bridge port"</b> is turned on in the interface
    object, compilers use different option to make
    iptables match packets crossing bridge ports. Here
    is the interface <b>"eth1"</b> which is configured
    as a bridge port:
  </p>

  <img src="bridge_interface_dialog_1.png"/>
  
  <p>
    Consider then the following rule in the policy of
    the firewall this interface belongs to:
  </p>

  <img src="rules_with_interface_2.png"/>

  <p>
    This rule matches interface "eth1" and generates the
    following iptables command:

    <p class="command">
      $IPTABLES -A FORWARD  -m physdev --physdev-in eth1  -s 172.16.22.0/24  -d 172.16.22.255  -m state --state NEW  -j ACCEPT 
    </p>
  </p>

  <p>
    Since  interface is now a bridge port, compiler uses
    <b>-m physdev --physdev-in eth1</b> to match it.
  </p>


  <h2>IPv4 Network Object</h2>

  <p></p>

  <img src="network_dialog1.png"/>

  <p>
    The network object describes an IP network or
    subnet. Use main menu <b>"Net Object / New Network"</b>
    item to create objects of this type. The dialog of
    the Network obejct provides the following entry
    fields:
  </p>

  <p>
    <ul>
      <li>Name -- Network object name 
      </li>

      <li>Address -- This is the IPv4 address of the
        network
      </li>

      <li>Netmask -- The netmask, in combination with an
        Address, deflnes the subnet. You can enter either
        string octet representation of the mask or its bit
        length here, however the program always converts
        it to the octet representation. Netmask in the
        network object is always entered in the "natural"
        way, such as "255.255.255.0", even if the object
        is going to be used to build Cisco IOS access
        lists which require reversed "bit mask"
        presentation instead (e.g "0.0.0.255" for the
        netmask above). Firewall Builder policy compiler
        takes care of the conversion automatically.
      </li>

      <li>Comment -- This is a free-form text field used
        for comments
      </li>
    </ul>
  </p>

  <p>
    Lets try to use Network object shown on the
    screenshot above in a policy rule of firewalls
    compiled for different target platforms.
  </p>

  <img src="network_example_1.png"/>

  <p>
    Here is what we get for iptables:

    <p class="command">
      $IPTABLES -A FORWARD -p tcp -m tcp  -s 172.16.22.0/24  --dport 80  -m state --state NEW  -j ACCEPT 
    </p>
  </p>

  <p>
    Here is the output produced for PF:

    <p class="command">
      pass in   quick inet proto tcp  from 172.16.22.0/24  to any port 80 keep state<br>
      pass out  quick inet proto tcp  from 172.16.22.0/24  to any port 80 keep state<br>
    </p>
  </p>

  <p>
    Here is how the output looks like when the rule is
    compiled into Cisco IOS access-lists (this is one of the
    generated access lists):

    <p class="command">
      ip access-list extended outside_out<br>
      permit tcp 172.16.22.0 0.0.0.255 any  eq 80 <br>
      exit<br>
    </p>
  </p>


  <p>
    Here is what we get when the rule is compiled into
    Cisco ASA (PIX) configuration. Note how compiler
    uses netmask 255.255.255.0 for PIX, while for IOS it
    was converted to 0.0.0.255. Also,
    interface <b>inside</b> was confgured with network
    zone <b>172.16.0.0/12</b> which matched network
    object used in the source element of the rule,
    because of that compiler put the rule only into
    access list attached to interface <b>inside</b>.

    <p class="command">
      access-list inside_acl_in permit tcp 172.16.22.0 255.255.255.0 any eq 80 <br>
      access-group inside_acl_in in interface inside<br>
    </p>
  </p>


  <h2>IPv6 Network Object</h2>

  <p></p>

  <img src="ipv6-network_dialog1.png"/>

  <p>
    The network object describes an IPv6 network or
    subnet. This object is very similar to the IPv4
    Network object, except you can only enter netmask as
    a bit length.  Use main menu <b>"Net Object / New
      Network IPv6"</b> item to create objects of this
    type.
  </p>

  <p>
    Lets see what we get if we use IPv6 Network object
    in a policy rule like shown in the screenshot:
  </p>

  <img src="ipv6_network_example_1.png"/>

  <p>
    Here is the command generated for iptables:

    <p class="command">
      $IP6TABLES -A FORWARD -p tcp -m tcp  -s 2001:470:1f0e:162::/64  --dport 80  -m state --state NEW  -j ACCEPT 
    </p>
  </p>

  <p>
    Here is what we get for PF:

    <p class="command">
      pass in   quick inet6 proto tcp  from 2001:470:1f0e:162::/64  to any port 80 keep state<br>
      pass out  quick inet6 proto tcp  from 2001:470:1f0e:162::/64  to any port 80 keep state<br>
    </p>
  </p>

  <p>
    Here is the output for Cisco IOS access lists (only
    one ACL is shown):

    <p class="command">
      ipv6 access-list ipv6_outside_out<br>
      permit tcp 2001:470:1f0e:162::/64 any  eq 80 <br>
      exit<br>
<br>
      interface eth0<br>
      ipv6 traffic-filter ipv6_outside_out out<br>
      exit<br>
    </p>
  </p>

  <p>
    There is no IPv6 support for Cisco ASA (PIX) in
    fwbuilder at this time.
  </p>

  <h2>Address Range Object</h2>
  
  <p></p>

  <img src="address_range_1.png"/>

  <p>
    The Address Range object describes a continuous range
    of IPv4 addresses. (Arbitrary address ranges are
    unsupported for IPv6.) To create new Address Range
    object, use main menu <b>"New Object / New Address
      Range"</b>. Its dialog provides the following entry
    fields:
  </p>

  <p>
    <ul>
      <li>Name -- The name of the Address Range object 
      </li>

      <li>Range start -- The address of the start of the range 
      </li>

      <li>Range end -- The address of the end of the range 
      </li>

      <li>Comment -- A free-form text field used for comments 
      </li>
    </ul>
  </p>

  <p>
    The Address range is inclusive, that is, both the
    start and the end addresses are included in the range.
  </p>

  <p>
    When Address Range object is used in a rule, Firewall
    Builder replaces it with a list of addresses
    equivalent to the specified range. The program tries
    to generate most economical representation of the
    range using combiantion of subnets of different
    length. Consider Address Range object as shown on the
    screenshot above. This Address Range object represents
    IP addresses between <b>192.168.1.100</b>
    and <b>192.168.1.160</b> (inclusively). It would be
    wasteful to generate 61 iptables commands to represent
    this range. Instead, compiler uses combination of
    several subnets of different length and ends up with
    the following:
  </p>

  <p>
    <p class="command">
      $IPTABLES -A FORWARD  -s 192.168.1.100/30  -m state --state NEW  -j ACCEPT <br>
      $IPTABLES -A FORWARD  -s 192.168.1.104/29  -m state --state NEW  -j ACCEPT <br>
      $IPTABLES -A FORWARD  -s 192.168.1.112/28  -m state --state NEW  -j ACCEPT <br>
      $IPTABLES -A FORWARD  -s 192.168.1.128/27  -m state --state NEW  -j ACCEPT <br>
      $IPTABLES -A FORWARD  -s 192.168.1.160  -m state --state NEW  -j ACCEPT <br>
    </p>
  </p>

  <p>
    Here is how generated configuration looks like for PF
    (this is essentially the same except it uses tables
    for brevity):
  </p>

  <p>
    <p class="command">
      table &lt;tbl.r0.s&gt; { 192.168.1.100/30 , 192.168.1.104/29 , 192.168.1.112/28 , 192.168.1.128/27 , 192.168.1.160 } <br>
<br>
      pass in   quick inet  from &lt;tbl.r0.s&gt;  to any keep state<br>
    </p>
  </p>

  <p>
    Just for completness, lets look at the configuration
    generated for the same rule for Cisco IOS access lists.
    This is really jsut a fragment of the generate router
    access list configuration because geenrated ACLs are
    attached to interfaces and, since the rule in the
    example was not associated with any interface, it got
    attached to all of them. Here we show only one generated
    ACL:
  </p>
  
  <p>
    <p class="command">
<br>
      ip access-list extended inside_in<br>
      ! <br>
      ! Rule  0 (global)<br>
      ! <br>
      ! <br>
      permit ip 192.168.1.100 0.0.0.3 any  <br>
      permit ip 192.168.1.104 0.0.0.7 any  <br>
      permit ip 192.168.1.112 0.0.0.15 any  <br>
      permit ip 192.168.1.128 0.0.0.31 any  <br>
      permit ip host 192.168.1.160 any  <br>
      exit<br>
    </p>
  </p>

  <h2>A Group Of Addressable Objects</h2>

  <p></p>

  <img src="group-view1.png"/>

  <p>
    The group of objects holds references to Hosts,
    Networks, Address Ranges, Firewalls and other groups
    of addressable objects. Use main menu <b>"New Obejct /
      New Obejct Group"</b> to create new obejct of this
    type. Objects can be added to the group using the
    following methods:
  </p>

  <p>
    <ul>
      <li>Using drag and drop -- Objects can be dragged
        from the tree into the group dialog. The tree
        switches to the object in a single click, however
        pointing a mouse cursor at the object and then
        pressing the button does not switch, but rather
        allows to start a drag and drop operation.
      </li>

      <li>Using the popup menu -- You can use the
        Copy/Paste operations between the tree and group
        dialog. Right mouse clicking on the object in the
        tree brings a pop-up menu. Choose Copy or Cut in
        this menu, then switch to the group dialog and
        right mouse click in the icon field. This also
        brings up a pop-up menu, where you choose
        Paste. This inserts a reference to the object in
        the group.
      </li>

      <li>Using the Edit main menu -- Just like in the
        case of a pop-up menu, select the object in the
        tree, use the Edit/Copy Object, then switch to the
        group dialog and use the Edit/Paste Object main
        menu.
      </li>
    </ul>
  </p>


  <h2>Special case addresses</h2>

  <p></p>

  <p>
    Policy compilers treat some addresses in policy rules
    in special ways, depending on the requirements of the
    target firewall platform. For example, compiler for
    iptables checks if address found in "Destination" or
    "Source" of a rule matches address of any interface of
    the firewall to determine if the rule should be placed
    in <b>INPUT</b> or <b>OUTPUT</b> chain. Compiler for
    PIX will use command <b>ssh &lt;address&gt;
      &lt;netmask&gt; inside</b> when it detects such
    address in the destnation of a rule where service is
    TCP Service object <b>"SSH"</b>. There are other
    special cases as well.
  </p>

  <h3>Boradcast and Multicast Addresses, iptables Firewall</h3>

  <p></p>

  <p>
    One important special case is broadcast and multicast
    addresses. It is important to place rules in the
    correct chain in generated iptables script because
    even though these addresses are not equal to those of
    the firewall's interfaces, iptables processes packets
    with broadcast or multicast destination in
    the <b>INPUT</b> chain. Firewall Builder is aware of
    this and generates correct iptables commands.
  </p>

  <p>
    In order to match broadcast or multicast addresses in
    the rules, we need to create objects to describe
    them. The choice of object type to describe broadcast
    or multicast address depends on whether this is just a
    single address, a range or a block. Address object is
    good to define single address, Address Range is good
    for ranges, and Network object is good to describe a
    block. For example, one can use Address object with
    address "255.255.255.255" to describe a broadcast.
    Address Range with addresses "224.0.0.5 - 224.0.0.6"
    would work well to describe two multicast groups used
    by OSPF and network object with address "224.0.0.0"
    and netmask "240.0.0.0" can be used to describe whole
    multicast address block.
  </p>

  <p>
    Here are few examples:
  </p>


  <img src="multicast_object_1.png"/>

  <p>
    Object <b>"all multicasts"</b> is part of
    the <b>Standard Objects</b> library that comes with
    the program and describes entire address block
    allocated for multicasts. Consider simple policy
    rule that permits all multicasts:
  </p>

  <img src="multicast_rule_1.png"/>

  <p>
    For iptables, this rule translates into the following
    script:
  </p>
  
  <p>
    <p class="command">
      $IPTABLES -A INPUT  -d 224.0.0.0/4  -m state --state NEW  -j ACCEPT 
    </p>
  </p>

  <p>
    The rule went into the <b>INPUT</b> chain because
    iptables processes multicast in it.
  </p>

  <p>
    Here is another example, this time it involves
    broadcast addresses. Interface <b>inside</b> of the
    test firewall has address 172.16.22.1 with netmask
    255.255.255.0. This defines subnet
    172.16.22.0/255.255.255.0 with broadcast address
    172.16.22.255. We create Address object with the name
    "net-172.16.22 broadcast" and address "172.16.22.255"
    and use it in the destination field of a policy rule.
    Another rule in the same example will match broadcast
    address "255.255.255.255"; an Address Range Object
    that defines this address is present in the Standard
    Objects library under the name "broadcast". Here are
    the rules:
  </p>
  
  <img src="broadcast_rules_1.png"/>

  <p>
    these two rules translate into the following script
    for iptables:
  </p>
  
  <p>
    <p class="command">
      # Rule 0 (global)<br>
      # <br>
      $IPTABLES -A INPUT  -d 255.255.255.255  -m state --state NEW  -j ACCEPT <br>
      # <br>
      # Rule 1 (global)<br>
      # <br>
      $IPTABLES -A INPUT  -d 172.16.22.255  -m state --state NEW  -j ACCEPT <br>
    </p>
  </p>

  <p>
    Both rules went into INPUT chain as expected.
  </p>



  <h3>Boradcast and Multicast Addresses and Bridging iptables Firewall</h3>

  <p></p>

  <p>
    Compilers treat broadcast and multicast addresses
    differently if the firewall object describes bridging
    firewall. In this case checkbox <b>"Bridging
      firewall"</b> should be turned on in the firewall
    settings dialog and one or more interface objects
    should be marked as <b>"Bridge port"</b>:
  </p>

  <img src="bridge_interface_dialog_1.png"/>

  <p>
    Now the rule that should match broadcast destination
    address will be treated differently:
  </p>

  <img src="broadcast_rules_2.png"/>

  <p>
    this produces the following iptables commands:

    <p class="command">
      $IPTABLES -A FORWARD  -d 172.16.22.255  -m state --state NEW  -j ACCEPT <br>
      $IPTABLES -A INPUT  -d 172.16.22.255  -m state --state NEW  -j ACCEPT <br>
    </p>
  </p>

  <p>
    Rules went into both <b>INPUT</b> and <b>FORWARD</b>
    chains because bridging firewall passes broadcasts
    through, but at the same time accepts them as packets
    headed for itself as well. Since the rule did not
    specify which interface it should look at, fwbuilder
    assumed that generated rule should inspect packets
    crossing all interfaces, both bridge ports and
    "normal" ones and therefore placed rule in
    both <b>INPUT</b> and <b>FORWARD</b> chains.
  </p>

  

</body>
</head>
