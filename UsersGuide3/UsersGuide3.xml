<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd" [
<!ENTITY fwbuilder-url "http://www.fwbuilder.org/">
<!ENTITY iptables-url "http://netfilter.filewatcher.org/">
<!ENTITY ipfilter-url "http://coombs.anu.edu.au/~avalon/">
<!ENTITY gtkmm-url "http://gtkmm.sourceforge.net/">
<!ENTITY gtkmm-download "http://www.hvrlab.org/pub/gtkmm/">
<!ENTITY ipt-howto "http://www.netfilter.org/documentation/HOWTO//NAT-HOWTO.html">
<!ENTITY faq-url "http://www.fwbuilder.org/docs/firewall_builder_faq.html">
]>
<book id="Using">
  <bookinfo>
    <title>Firewall Builder User's Guide</title>

    <affiliation>
      <orgname>NetCitadel LLC</orgname>
    </affiliation>

    <edition>$Id$</edition>

    <copyright>
      <year>2003,2009</year>

      <holder>NetCitadel, LLC</holder>
    </copyright>

    <legalnotice>
      <para>The information in this manual is subject to change without notice
      and should not be construed as a commitment by NetCitadel LLC.
      NetCitadel LLC assumes no responsibility or liability for any errors or
      inaccuracies that may appear in this manual.</para>

      <!--
      <para>The software described in this manual is furnished under a
      license and may only be used or copied in accordance with the
      terms and conditions of such a license.</para>
-->
    </legalnotice>
  </bookinfo>

  <!-- ############################################################### -->

  <chapter id="Introduction">
    <title>Introduction</title>

    <sect1>
      <title>Introducing Firewall Builder</title>

      <para>Firewall Builder simplifies the firewall policy management
      for a number of firewall platforms, including
      Netfilter/iptables, ipfw, PF, Cisco PIX, and others. Firewall
      Builder provides a professional-grade GUI to these platforms,
      simplifying administration tasks.</para>

      <para>With Firewall Builder, you can manage the security policy of your
      firewall efficiently and accurately, without the learning curve usually
      associated with command line interfaces. Instead of thinking in terms of
      obscure commands and parameters, you simply create a set of objects
      describing your firewall, servers, and subnets, and then implement your
      firewall policy by dragging objects into policy rules. You can also take
      advantage of a large collection of predefined objects describing many
      standard protocols and services. Once a policy is built in the GUI, you
      can compile it and install it on one, or several, firewall
      machines.</para>
    </sect1>

    <sect1>
      <title>Overview of Firewall Builder Features</title>

      <para><itemizedlist spacing="compact">
          <listitem>
            <para>Over 100 predefined objects for the most popular and widely
            used protocols and services</para>
          </listitem>

          <listitem>
            <para>Ability to create custom objects describing IP,ICMP,TCP,UDP
            or custom services</para>
          </listitem>

          <listitem>
            <para>Ability to create objects to describe hosts, networks and
            address ranges</para>
          </listitem>

          <listitem>
            <para>Templates to help you jumpstart your
            firewall policy, and do it right the first time. Templates
            implement standard policies for typical network layouts, which can
            later be extended and edited by hand</para>
          </listitem>

          <listitem>
            <para>The Network discovery tool that automates the creation of
            multiple objects by reading a hosts file, by crawling your network via SNMP, or by importing an existing firewall policy.</para>
          </listitem>

          <listitem>
            <para>An object oriented approach to the policy management: any
            change made to an object gets immediately reflected in all policy
            rules of all firewalls using that object. The configuration for
            multiple firewalls shares the same object database.</para>
          </listitem>

          <listitem>
            <para>The ability to turn a firewall policy into a configuration
            file or a script and then install it on a firewall with just a few
            clicks of the mouse.</para>
          </listitem>

          <listitem>
            <para>Convenient GUI that supports standard Copy/Paste operations
            for both text strings and network objects and allows for policy
            editing using drag and drop</para>
          </listitem>

	  <listitem>
            <para>Find and Replace functionality that can be used within a policy or across a set of policies</para>
          </listitem>

          <listitem>
            <para>Support for several firewall platforms, including Cisco PIX
            and Open Source firewalls iptables, ipfilter and pf.</para>
          </listitem>

          <listitem>
            <para>The ability to print a single object, a firewall policy, the
            whole hierarchy, or export it to the text file in either plain
            text or html format</para>
          </listitem>

          <listitem>
	    <para>Built-in, platform-specific help. Different firewalls provide different features and options. The Firewall Builder GUI provides help in appropriate dialogs to assist you in choosing the right options for your platform.</para>
          </listitem>
        </itemizedlist></para>

      <figure float="1" id="example1">
        <title>Sample firewall policy</title>
            <graphic scale="60" fileref="scrn2.png" />
      </figure>
    </sect1>
  </chapter>

  <!-- ############################################################### -->
  <chapter id="install">
    <title>Installing Firewall Builder</title>
    <sect1>
      <title>RPM-based distributions (Red Hat, Fedora, OpenSUSE and others)</title>
      <para>Using pre-built binary RPMs</para>

      <para>You need to download and install two RPMs:</para>

      <itemizedlist>
	<listitem><para>Example: <filename>libfwbuilder-3.0.0-1.i386.rpm</filename>
	</para></listitem>
	<listitem><para>Example: <filename>fwbuilder-3.0.0-1.i386.rpm</filename>
	</para></listitem>
      </itemizedlist>

      <para>To satisfy dependencies, you need the following packages installed on your system:</para>

      <itemizedlist>
	<listitem><para>libxml2 v2.4.10 or newer
	</para></listitem>
	<listitem><para>libxslt v1.0.7 o newer
	</para></listitem>
	<listitem><para>ucd-snmp or net-snmp
	</para></listitem>
	<listitem><para>QT 4.3.x, 4.4.x Fwbuilder depends on QT 4.3 or 4.4, it will not work with 4.2
	</para></listitem>
      </itemizedlist>
	<para>Pre-built binary RPMs for RedHat Enterprise Linux 5 (RHEL 5) and CentOS 5.2</para>

	<para>These distributions do not come with QT4 and third-party binary RPMs of QT v4.3.x and 4.4.x are hard to come by. We distribute binary RPMs of Firewall Builder 3.0 statically linked with QT 4.4.1 for these distributions. These RPMs are posted in the downloads area on the SourceForge project site. These RPMs have the same standard names: <filename>libfwbuilder-3.0.0-1.i386.el5.rpm</filename> and <filename>fwbuilder-3.0.0-1.i386.el5.rpm</filename>, they just have no dependency on QT RPMs.</para>

	<para>If fwbuilder statically linked with QT crashes on start on your CentOS system, check if you have the following font packages installed: bitmap-fonts or bitstream-vera-fonts. Either one should make fwbuilder work (but we are told bitstream-vera fonts look better). See bug report <ulink url="http://sourceforge.net/tracker/?func=detail%26aid=2595205%26group_id=5314%26atid=1070394"><citetitle>#2595205</citetitle></ulink> on SourceForge for more details.</para>

      <para>To install Firewall Builder, go to your download directory and run the following command (replace the filenames with the names of the files you actually downloaded:</para>

      <screen>rpm -i libfwbuilder-3.0.0-1.i386.rpm fwbuilder-3.0.0-1.i386.rpm</screen>
    </sect1>
    <sect1>
      <title>Ubuntu Installation</title>
      <para>Using pre-built binary packages</para>
      
      <para>You need to download and install two packages: 

      <itemizedlist>
	<listitem><para>Example: <filename>libfwbuilder_3.0.4-b778-ubuntu-hardy-1_i386.deb</filename>
	</para></listitem>
	<listitem><para>Example: <filename>fwbuilder_3.0.4-b778-ubuntu-hardy-1_i386.deb</filename>
	</para></listitem>
      </itemizedlist></para>

      <para>To satisfy dependencies, you need the following packages installed on your system:</para>

      <itemizedlist>
	<listitem><para>QT 4.3.x, 4.4.x. Fwbuilder depends on QT 4.3 or 4.4, it will not work with 4.2
	</para></listitem>
      </itemizedlist>

      <para>You can get QT via your regular package manager.</para>

      <para>To install Firewall Builder, go to your download directory and run the following command (replace the filenames with the names of the files you actually downloaded:</para>

      <screen>dpkg -i libfwbuilder_3.0.4-b778-ubuntu-hardy-1_i386.deb \
	  fwbuilder_3.0.4-b778-ubuntu-hardy-1_i386.deb</screen>

    </sect1>
    <sect1>
      <title>Installing FreeBSD and OpenBSD Ports</title>
      <para>Firewall Builder consists of two ports: <filename>/usr/ports/security/libfwbuilder</filename>  and <filename>/usr/ports/security/fwbuilder</filename>. Once both ports are updated (it usually takes couple of weeks to update ports after the package is released), just install the port as usual using portinstall or issuing "make install" in <filename>/usr/ports/security/fwbuilder</filename>.</para>
    </sect1>
    <sect1>
      <title>Windows Installation</title>

      <para>Double-click on the package file, then follow the step-by-step instructions in the installation wizard.</para>
    </sect1>
    <sect1>
      <title>Mac OS X Installation</title>

      <para>Mac OS X package is distributed in the form of a disk image ( .dmg file). Doubleclick on the image to mount it, then drag Firewall Builder application to your Applications folder (or any other place).</para>
    </sect1>
    <sect1>
      <title>Compiling from Source</title>

      <para>Firewall Builder can be compiled and works on the following OS and distributions:</para>

    <para><itemizedlist spacing="compact">
        <listitem>
          <para>Debian Linux (including Ubuntu)</para>
        </listitem>

        <listitem>
          <para>Mandrake Linux</para>
        </listitem>

        <listitem>
          <para>RedHat Linux</para>
        </listitem>

        <listitem>
          <para>SuSE Linux</para>
        </listitem>

        <listitem>
          <para>Gentoo Linux</para>
        </listitem>

        <listitem>
          <para>FreeBSD</para>
        </listitem>

        <listitem>
          <para>OpenBSD</para>
        </listitem>

        <listitem>
          <para>Mac OS X</para>
        </listitem>

        <listitem>
          <para>Solaris</para>
        </listitem>
      </itemizedlist></para>

      <para>To compile from source, first download dependencies for your platform:</para>

      <para>For RedHat-based systems:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para>automake</para>
        </listitem>

        <listitem>
          <para>autoconf</para>
        </listitem>

        <listitem>
          <para>libtool</para>
        </listitem>

        <listitem>
          <para>libxml2-devel</para>
        </listitem>

        <listitem>
          <para>libxslt-devel</para>
        </listitem>

        <listitem>
          <para>net-snmp-devel</para>
        </listitem>

        <listitem>
          <para>qt</para>
        </listitem>

        <listitem>
          <para>qt-devel</para>
        </listitem>

        <listitem>
          <para>qt-x11</para>
        </listitem>
      </itemizedlist>

      <para>You may need to install packages elfutils-libelf and elfutils-libelf-devel (libelf on SuSE), otherwise libfwbuilder won't pick up net-snmp library even if it is installed.</para>

      <para>For Debian-based systems:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para>automake</para>
        </listitem>

        <listitem>
          <para>autoconf</para>
        </listitem>

        <listitem>
          <para>libtool</para>
        </listitem>

        <listitem>
          <para>libxml2-dev</para>
        </listitem>

        <listitem>
          <para>libxslt-dev</para>
        </listitem>

        <listitem>
          <para>libsnmp-dev</para>
        </listitem>

        <listitem>
          <para>libqt4-core</para>
        </listitem>

        <listitem>
          <para>libqt4-dev</para>
        </listitem>

        <listitem>
          <para>libqt4-gui</para>
        </listitem>

        <listitem>
          <para>qt4-dev-tools</para>
        </listitem>
      </itemizedlist>

      <para>Next, download source archives from SourceForge (libfwbuilder-3.0.0.tar.gz and fwbuilder-3.0.0.tar.gz, for example) and unpack them somewhere. Then build as follows:</para>
<screen>
cd libfwbuilder-&lt;version_number&gt;
./autogen.sh
make
make install

cd /fwbuilder-&lt;version_number&gt;
./autogen.sh
make
make install
</screen> 

    <note><title>Compilation may require other packages for RedHat and SuSE</title>

    <para>If you get errors that refer to missing autoconf macros while running autogen.sh for fwbuilder, check if your system has RPM gettext-devel. You may need to add other "development" RPMs besides these, but these two are often forgotten.</para>
    </note>

      <para>The configure scripts for both libfwbuilder and fwbuilder tries to find your QT4 installation in several more-or-less standard places. However, if you installed QT in a directory where the script can't find it, you can provide the path to it using the <parameter>--with-qtdir</parameter> option to script autogen.sh. This looks as follows:</para>

<screen>
cd libfwbuilder-&lt;version_number&gt;
./autogen.sh --with-qtdir=/opt/qt4
make
make install
      
cd /fwbuilder-&lt;version_number&gt;
./autogen.sh --with-qtdir=/opt/qt4
make
make install
</screen>           

      <para>By default script configure assumes prefix="/usr/local" and installs libfwbuilder libraries in /usr/local/lib and binaries in /usr/local/bin. Make sure /usr/local/lib is added to your LD_LIBRARY_PATH environment variable or to the /etc/ld.so.conf configuration file, otherwise the program won't find dynamic libraries there. Likewise, /usr/local/bin needs to be in your PATH.</para>

      <para>You can install libraries and binaries in a different place by specifying new prefix as follows:</para>
<screen>
./autogen.sh --prefix="/opt"
</screen>

      <para>This will install libraries in <filename class='directory'>/opt/lib</filename> and the program in <filename class='directory'>/opt/bin</filename>.</para> 

    </sect1>
  </chapter>
    <!-- *************************************************************** -->
  <chapter id="definitions">
    <title>Definitions and Terms</title>

    <para>This chapter defines common terms that pertain to the Firewall
    Builder program.</para>
    <variablelist>
      <varlistentry>
	<term>
	Firewall
	</term>
      <listitem>
	<para>The term <emphasis>firewall</emphasis> can refer to a device that implements firewall software, or it can refer to the software and policy running on the device, or it can refer to just the firewall access policy.</para>
	<para>In this document, the term <emphasis>firewall</emphasis> refers the firewall object in in Firewall Builder. The firewall object contains a logical representation of the firewall devices interfaces, and the access policy ruleset, NAT ruleset, and Routing ruleset that will be placed on the firewall device.</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>
	Policy
	</term>
      <listitem>
	<para>The term <emphasis>policy</emphasis> can refer to the entire set of "business logic" that is implemented in the firewall, or it can refer to the access policy portion of firewall only.</para>
	<para>In this document, the term <emphasis>policy</emphasis> refers to the access policy ruleset</para>
	</listitem>
      </varlistentry>
    </variablelist>
  </chapter>
    <!-- *************************************************************** -->
  <chapter id="gettingstarted">
    <title>Getting Started</title>

    <para>This chapter introduces you to the Firewall Builder program. It walks you through using the tool, from starting it to building and installing an actual firewall configuration.</para> 

    <para>The Firewall Builder package for most Linux distributions creates a menu item that makes starting the program easy. (On Ubuntu, it's <guimenuitem>System > Administration > Firewall Builder</guimenuitem>.) However, if the menu item is not there, you can always launch it from the command line by just typing <command>fwbuilder</command> at the shell prompt.</para>

    <para>The program starts by opening the main window and a tips dialog.</para>

      <figure id="pict_020"><title>Starting Firewall Builder</title>
	<graphic scale="50" fileref="pict_020.png"/>
      </figure>

     <para>Let's create our first firewall object. To do this, we'll use the object creation menu, accessed by clicking this icon above the object tree: <inlinegraphic scale="70" fileref="new-object-icon.png"/>. Choose <guimenuitem>New Firewall</guimenuitem> from the menu that appears.</para>

      <figure id="pict_030">
        <title>Select New Firewall</title>
          <graphic scale="70" fileref="pict_030.png" />
      </figure>

      <para>The first page of the New Firewall wizard appears. In this page of the wizard we can enter the name for the new firewall object (here it is "guardian"), its platform ("iptables") and its host OS ("Linux 2.4/2.6").</para>

	<figure id="pict_040">
          <title>Define firewall platform</title>
             <graphic scale="70" fileref="pict_040.png" />
        </figure>

      <para>The name of the new firewall object can be anything you want. However, if you want to use SNMP to populate the interface objects, or if you want to use DNS lookups to populate IP address objects, you must name the firewall object the same name as the actual firewall machine.</para>

      <para>There are three ways a new firewall can be created: you can use a pre-configured template firewall object, create it from scratch, or use SNMP to create a firewall object with interfaces but an empty policy.</para>

      <para>The Getting Started chapter demonstrates the first method, using a template object. (Other methods are described in <xref linkend="firewall-object" />.) To do this, check <guilabel>Use pre-configured template firewall objects</guilabel> checkbox. Firewall Builder comes with a default set of objects, and we'll be using one of those there. Alternatively, an administrator can distribute a library of predefined templates to other users in the enterprise, as described in <xref linkend="new-library" />.</para>

      <para>We are going to use one of the standard templates distributed with Firewall Builder, so we'll leave the standard template library path and name in the <guilabel>Template file</guilabel> input field. Click <guibutton>Next</guibutton> to move on to the next page of the wizard.</para>

      <para>Note that the template firewall object comes completely configured, including addresses and netmasks for its interfaces and some basic policy and NAT rules. This configuration is intended as a starting point only. You should reconfigure addresses of interfaces to match those used on your network. You most likely will have to adjust rules to match your security policy. See <xref linkend="change-ip-address-in-template" /> for instructions.</para>

      <para>This page of the wizard shows template objects and their configuration. Standard template objects represent firewalls with two or three interfaces, a host with one interface, a web server or a Cisco router. We'll choose <guilabel>fw template 3</guilabel>, a firewall with three interfaces, for this example. Click <guibutton>Finish</guibutton> to create a new firewall object using the chosen template. </para>

      <figure id="pict_050">
          <title>Pick a template</title>
              <graphic scale="70" fileref="pict_050.png" />
      </figure>

      <para>Our new firewall object is show in <xref linkend="pict_060" />. Its name is "guardian", and it appears in the object tree in the left hand side of the main window in the folder "Firewalls". When an object is selected in the tree, a brief summary of its properties appears in the panel under the tree. Double-clicking on the object in the tree opens it in the editor panel at the bottom-right panel of the main window. The editor for the firewall object allows us to change its name, platform and host OS, and also provides buttons that open dialogs for "advanced" settings for the firewall platform and host OS. We will inspect these little later in this chapter. </para>

      <figure id="pict_060">
          <title>New Firewall</title>
              <graphic scale="50" fileref="pict_060.png" />
      </figure>

      <para>Now would be a good time to save the data to a disk file. To do so use main menu <guimenuitem>File/Save As</guimenuitem>. </para>

      <figure id="pict_070">
          <title>Save firewall</title>
              <graphic scale="70" fileref="pict_070.png" />
      </figure>

      <para>Pick a location and name for the new data file. Firewall Builder uses file extension ".fwb" for data files. </para>

      <figure id="pict_080">
          <title>Specify filename</title>
              <graphic scale="70" fileref="pict_080.png" />
      </figure>

      <para>Note that once the firewall data is saved to a file, its name appears in the main window title. Here it is "test.fwb."</para>

      <figure id="pict_090">
          <title>Filename displayed</title>
              <graphic scale="60" fileref="pict_090.png" />
      </figure>

      <para>Let's take a little tour of the network and service objects that come standard with the program. You can use these pre-configured objects to build access Policy, NAT, and Routing rules for your firewall.</para>

      <para>Objects in the tree are organized in libraries. You can switch between libraries using the drop-down menu above the tree. Firewall Builder comes with a collection of address, service and time interval objects in the library called "Standard". Let's take a look at them.</para>

      <figure id="pict_093">
          <title>Objects tree</title>
              <graphic scale="70" fileref="pict_093.png" />
      </figure>

      <para>Folder <guilabel>Objects/Hosts</guilabel> contains a few host objects used in standard firewall templates. Folder <guilabel>Objects/Network</guilabel> contains network objects that represent various standard address ranges and blocks, such as multicast, net 127/8, networks defined in RFC1918 and so on. </para>

      <figure id="pict_094">
          <title>Host and Network objects</title>
              <graphic scale="70" fileref="pict_094.png" />
      </figure>

      <para>Firewall Builder also comes with an extensive collection of service objects. This picture shows some TCP objects (all of them do not fit in the screenshot). </para>

      <figure id="pict_095">
          <title>TCP objects</title>
              <graphic scale="70" fileref="pict_095.png" />
      </figure>

      <para>ICMP service objects. </para>

      <figure id="pict_096">
          <title>ICMP objects</title>
              <graphic scale="70" fileref="pict_096.png" />
      </figure>

      <para>UDP service objects. </para>

      <figure id="pict_097">
          <title>UDP objects</title>
              <graphic scale="70" fileref="pict_097.png" />
      </figure>

      <para>Let's inspect some of the objects Firewall Builder created for you as part of the new firewall object. To open an object in the editor and inspect or change its properties, double-click on it in the tree.</para> 

      <figure id="pict_100">
          <title>Firewall object</title>
              <graphic scale="60" fileref="pict_100.png" />

      </figure>

      <para>You can also right-click on the object in the tree to open a pop-up menu. Choose <guimenuitem>Edit</guimenuitem> to edit the object. </para>

      <figure id="pict_101">
          <title>Edit an object</title>
              <graphic scale="70" fileref="pict_101.png" />
      </figure>

      <para>Every object in Firewall Builder has basic attributes such as <guilabel>Name</guilabel> and <guilabel>Comment</guilabel>. Other attributes depend on the object type.</para>

      <para>Attributes of the firewall object include <guilabel>Platform</guilabel> (can be iptables, pf, ipfilter, etc.), <guilabel>Version</guilabel> (platform-dependent) and <guilabel>Host OS</guilabel>. Buttons <guibutton>Host OS Settings</guibutton> and <guibutton>Firewall Settings</guibutton> open dialogs with many additional attributes that depend on the firewall platform and host OS. More on these later.</para>

      <figure id="pict_102">
          <title>Firewall attributes</title>
              <graphic scale="60" fileref="pict_102.png" />
      </figure>

      <para>Here are the choices for the firewall platform, version (for iptables) and host OS. </para>

      <figure id="pict_103">
          <title>iptables attributes</title>
              <graphic scale="70" fileref="pict_103.png" />
      </figure>

      <para>Interfaces of the firewall are represented by objects located below the Firewall object in the tree. We refer to them as "children" of the firewall object. <xref linkend="pict_104" /> shows properties of interface eth0. To open it in the editor, double-click on it in the tree. If editor panel is already open and shows some object, it is sufficient to select the new object in the tree to reveal it in the editor panel (no need to double-click).</para>

      <para>IP and MAC addresses of interfaces are represented by child objects in the tree located below the corresponding interface.</para>

      <figure id="pict_104">
          <title>Firewall interface objects</title>
              <graphic scale="70" fileref="pict_104.png" />
      </figure>

      <para>An interface object has several attributes that define its function, such as "Management interface", "external", and so on.</para>

      <itemizedlist>
	<listitem><para><guilabel>Name</guilabel>: The name of the interface object in Firewall Builder must match exactly the name of the interface of the firewall machine it represents. This will be something like "eth0", "eth1", "en0", "br0", and so on.
	</para></listitem>
	<listitem><para><guilabel>Label</guilabel>: On most OS's this field is not used and serves the purpose of a descriptive label. Firewall Builder GUI uses a label, if it is not blank, to show interfaces in the tree. One of the suggested uses for this field is to mark interfaces to reflect the network topology ('outside', 'inside') or the purpose ('web frontend' or 'backup subnet'). The label is mandatory for Cisco PIX though, where it must reflect the network topology.
	</para></listitem>
	<listitem><para><guilabel>Management interface</guilabel>: When the firewall has several network interfaces, one of them can be marked as the "management interface". The management interface is used for all communication between Firewall Builder and the firewall.  For example, the Firewall Builder policy installer uses the address of the management interface to connect to the firewall via SSH when it copies the generated script or configuration file to it. (firewall object only)
	</para></listitem>
	<listitem><para><guilabel>External interface (insecure)</guilabel>: Marks an interface that connects to the Internet.
	</para></listitem>
	<listitem><para><guilabel>Unprotected interface</guilabel>: Recognized by policy compilers for Cisco IOS access lists and PF. The compiler for IOS ACL just skips unprotected interfaces and does not assign an ACL to them. The compiler for PF generates a "set skip on &lt;interface_name&gt;" clause for unprotected interfaces.
	</para></listitem>
	<listitem><para><guilabel>Regular Interface</guilabel>: Use this option if the interface has an IP address assigned to it manually.
	</para></listitem>
	<listitem><para><guilabel>Address is assigned dynamically</guilabel>: Use this option if the interface has a dynamic address obtained via DHCP, PPP or another protocol. In this case an address is unknown when when Firewall Builder generates the Firewall policy. Some firewalls allow for using the interface name in the policy instead of the IP address; the firewall engine then picks its address either when the policy is activated or even at run-time.</para>
	</listitem>
	<listitem><para><guilabel>Unnumbered interface</guilabel>: Use this option if the interface can never have an IP address, such as the Ethernet interface used to run PPPoE communication on some ADSL connections, or tunnel endpoint interface (GRE, PPPoE, sometimes IPSEC). Although unnumbered interfaces do not have addresses, firewall policy rules and access lists can be associated with them.
	</para></listitem>
	<listitem><para><guilabel>Bridge port</guilabel>: This option is used for a port of a bridged firewall. Compilers skip bridge ports when they pick interfaces to attach policy and NAT rules to. For target firewall platforms that support bridging and require special configuration parameters to match bridged packets, compilers use this attribute to generate proper configurations. For example, in the case of iptables, the compiler uses <emphasis> -m physdev --physdev-in</emphasis> or <emphasis> -m physdev --physdev-out</emphasis> for bridge port interfaces.
	</para></listitem>
	<listitem><para><guilabel>Security level</guilabel>: The security level of this interface, used only with Cisco PIX (ASA).
	</para></listitem>
	<listitem><para><guilabel>Network zone</guilabel>: Network zone of this interface, used only with Cisco PIX (ASA). Network zone drop-down list shows all network objects and groups of addresses and networks present in the tree. Choose one of them to tell the compiler which networks and blocks of addresses can be reached through this interface. Compiler uses this information to decide which interface each ACL rule should be associated with based on the addresses used in the destination of the rule.
	</para></listitem> 
      </itemizedlist>

      <figure id="pict_105">
          <title>Interface object attributes</title>
              <graphic scale="70" fileref="pict_105.png" />
      </figure>

      <para>Here is IP address of interface eth0. The address and netmask are attributes of the child object of the type "IPv4 address". Here the address is "192.0.2.1" and netmask "255.255.255.0". (Netmask can also be specified using slash notation, such as 24, without the actual slash.) Button <guibutton>DNS Lookup</guibutton> can be used to determine IP address using DNS. The program runs DNS query for the "A" record for the name of the parent firewall object. (This only works if the firewall object has the same name as the actual firewall machine.)</para>

      <figure id="pict_110">
          <title>Interface IP address</title>
              <graphic scale="70" fileref="pict_110.png" />
      </figure>

      <para>This is the IP address of the internal interface of the firewall. The address used in this template is "192.168.1.1" with netmask "255.255.255.0". This is a typical address used for small and home networks. Some commercial firewall appliances come pre-configured with this address.</para>

      <para>If your network uses an address different from the "192.168.1.0/24" address used in the template, you should change the address of the interface in the editor panel and click <guibutton>Apply</guibutton>. In addition, you also will need to replace the network object "net-192.168.1.0" used in several Policy and NAT rules of the newly created firewall with a network object that has an address matching your network configuration. See <xref linkend="change-ip-address-in-template" /> for instructions.</para>

      <figure id="pict_120">
          <title>Firewall internal interface</title>
              <graphic scale="70" fileref="pict_120.png" />
      </figure>

      <para>Here is the IP address of the DMZ interface of the firewall. The address used in this template is "192.168.2.1", with netmask "255.255.255.0". Change it to match your DMZ network address. </para>

      <figure id="pict_130">
          <title>Firewall DMZ interface</title>
              <graphic scale="70" fileref="pict_130.png" />
      </figure>

      <para>Let's inspect the properties of the firewall object. Double-click on the firewall "guardian" in the tree to open it in the editor panel, then click the <guibutton>Firewall Settings</guibutton> button in the editor. This opens a new dialog that looks like <xref linkend="pict_140" />.</para>

      <figure id="pict_140">
          <title>Firewall Compiler properties</title>
              <graphic scale="60" fileref="pict_140.png" />
      </figure>

      <para>Click the <guibutton>Help</guibutton> button to open help fir this dialog. The online help explains all attributes and parameters located in each tab of the <guilabel>advanced settings</guilabel> dialog. Explore it, as many parameters are important and affect the generated firewall script in different ways.</para>

      <para>The next few images show other tabs of the <guilabel>advanced settings</guilabel> dialog. You can find detailed explanations of all parameters in the online help.</para>

      <figure id="pict_145">
          <title>Compiler properties online help</title>
              <graphic scale="60" fileref="pict_145.png" />
      </figure>

      <para>This page defines various parameters for the built-in policy installer. The installer uses an SSH client (pscp.exe and plink.exe on Windows) to transfer the generated script to the firewall machine and activate it there. </para>

      <figure id="pict_150">
          <title>Installer properties</title>
              <graphic scale="50" fileref="pict_150.png" />
      </figure>

      <para>You can define shell commands that will be included in the generated script at the beginning and at the end of it. These commands can do anything you want, such as configure some subsystems, set up routing, and so on. </para>

      <figure id="pict_160">
          <title>Script Prolog/Epilog properties</title>
              <graphic scale="50" fileref="pict_160.png" />
      </figure>

      <para>Parameters for logging. </para>

      <figure id="pict_170">
          <title>Logging properties</title>
              <graphic scale="50" fileref="pict_170.png" />
      </figure>

      <para>This screen shows more options for the script generation. Notice that Firewall Builder can produce the iptables script in two formats: 1) as a shell script that calls the iptables utility to add each rule one by one, or 2) it can use iptables-restore script to activate the whole policy at once. Other parameters are explained in the online help. </para>

      <figure id="pict_180">
          <title>Script properties</title>
              <graphic scale="50" fileref="pict_180.png" />
      </figure>

      <para>Starting with v3.0, Firewall Builder can generate both IPv4 and IPv6 policies. This tab controls the order in which they are added to the script if you have defined rules for both address families in the Policy objects of the firewall.</para> 

      <figure id="pict_190">
          <title>IPv4, IPv6 generation order</title>
              <graphic scale="50" fileref="pict_190.png" />
      </figure>

      <para>Let's take a look at the policy of the template firewall shown in <xref linkend="pict_200" />. These rules are intended to be an example, a starting point to help you create your own policy. Most likely you will want to modify the rules to suite your requirements. Explanations of the rules given here are brief because the goal of Getting Started is only to demonstrate how to use Firewall Builder.</para>

      <itemizedlist>
	<listitem><para><guilabel>Rule 0</guilabel>: This is an anti-spoofing rule. It blocks incoming packets on the external interface that have source addresses that belong to the firewall or your internal or DMZ networks. The rule is associated with outside interface and has <guilabel>Direction</guilabel> set to "Inbound".
	</para></listitem>
	<listitem><para><guilabel>Rule 1</guilabel>: This rule permits any packets on the loopback interface. This is necessary because many services on the firewall machine communicate back to the same machine via loopback.
	</para></listitem>
	<listitem><para><guilabel>Rule 2</guilabel>: Permit ssh access from internal network to the firewall machine. Notice service object "ssh" in the column <guilabel>Service</guilabel>. (This object can be found in the Standard objects library in the Services/TCP folder.)
	</para></listitem>
      </itemizedlist>

      <figure id="pict_200">
          <title>Template rulesets</title>
              <graphic scale="70" fileref="pict_200.png" />
      </figure>

      <para>Access policy rules belong to the object "Policy", which is a child object of the firewall and can be found in the tree right below it. As with any other object in Firewall Builder, the Policy object has some attributes that you can edit if you double-click on it in the tree.</para>

      <itemizedlist>
	<listitem><para>Policy can be IPv4, IPv6, or combined IPv4 and IPv6. In the last case you can use a mix of IPv4 and IPv6 address objects in the same policy (in different rules), and Firewall Builder will automatically figure out which one is which and sort them out.
	</para></listitem>
	<listitem><para>Policy can translate into only the mangle table (used for modifying packets) or a combination of the filter table (used for allowing/blocking packets) and the mangle table. In the latter case, the policy compiler decides which table to use based on the rule action and service object. Some actions, such as "Tag" (which translates into iptables target MARK), go into mangle table.
	</para></listitem>
	<listitem><para>The "Top ruleset" is the one the compiler will use to populate iptables built-in chains INPUT/OUTPUT/FORWARD. (If you have only one ruleset, then mark it as the top ruleset.) If a policy is not marked as "top ruleset", generated rules will go into a user-defined chain with the same name as the policy object.
	</para></listitem>
      </itemizedlist>

      <figure id="pict_210">
          <title>Policy ruleset</title>
              <graphic scale="60" fileref="pict_210.png" />
      </figure>

      <para>Here are the pre-configured NAT rules.</para>
      <itemizedlist>
	<listitem><para><guilabel>Rule 0</guilabel>: Tells the firewall that no address translation should be done for packets traveling from network 192.168.2.0 to 192.168.1.0 (because Translated Source, Translated Destination and Translated Service are left empty).
	</para></listitem>
	<listitem><para><guilabel>Rule 1</guilabel>: Packets coming into the firewall from internal and DMZ networks are translated so that their source address will change to that of the outside interface on the firewall.
	</para></listitem>
	<listitem><para><guilabel>Rule 2</guilabel>: Packets coming from the Internet to the interface "outside" will be translated and forwarded to the internal server on DMZ represented by the host object "server on dmz".
	</para></listitem>
      </itemizedlist>

      <figure id="pict_220">
          <title>NAT ruleset</title>
              <graphic scale="70" fileref="pict_220.png" />
      </figure>

      <para>Now we compile the policy of the firewall "guardian" and generate the iptables script. To do so, right-click on the firewall in the tree, then select <guimenuitem>Compile</guimenuitem> from the pop-up menu. </para>

      <figure id="pict_230">
          <title>Compile the firewall rulesets</title>
              <graphic scale="70" fileref="pict_230.png" />
      </figure>

      <para>A new dialog appears that allows you to choose which firewalls you want to compile. Obviously this is only useful if you have several firewalls in the object tree. Since the checkbox next to the "guardian" firewall is already checked, click <guibutton>Next</guibutton> to proceed.</para>

      <figure id="pict_240">
          <title>Compile firewall dialog</title>
              <graphic scale="50" fileref="pict_240.png" />
      </figure>

      <para>Firewall Builder calls the appropriate policy compiler. The dialog displays compiler progress and results. </para>

      <figure id="pict_250">
          <title>Compile status dialog</title>
              <graphic scale="50" fileref="pict_250.png" />
      </figure>

      <para>Compiler generates an iptables script in a ".fw" file with the same name the same as the firewall object (guardian.fw). The file is placed in the same directory as the .fwb data file. </para>

      <figure id="pict_260">
          <title>Generated file</title>
              <graphic scale="70" fileref="pict_260.png" />
      </figure>

      <para>Here is the how generated script looks (this is just the beginning). Now you can transfer it to the firewall and execute it there to install iptables rules. However, it is much more convenient to use Firewall Builders' built-in policy installer to do this. </para>

      <figure id="pict_270">
          <title>Generated script</title>
              <graphic scale="50" fileref="pict_270.png" />
      </figure>

      <para>To use the installer, right-click on the firewall object in the tree and select <guimenuitem>Install</guimenuitem>. Firewall Builder will compile the policy (if it is not compiled already) and then open a dialog where you can configure the parameters of the installer. Here you need to enter a password to authenticate to the firewall. Section <xref linkend="compile-install-policy" /> has detailed instructions for setting up and using the installer.</para>

      <figure id="pict_280">
          <title>Policy installer</title>
              <graphic scale="70" fileref="pict_280.png" />
      </figure>
 
  </chapter>

    <!-- *************************************************************** -->
  <chapter id="using-gui">
    <title>Firewall Builder GUI</title>
    <para>The Firewall Builder GUI consists of the <guilabel>Main Window</guilabel>, which can display one or more object files, and a number of dialogs that let you control GUI preferences and tailor the specifics of Firewall Builder objects and services.</para>
    <sect1>
      <title>The Main Window</title>

      <para>The main window mainly consists of a menu bar and a display area. Normally, the display area holds the object file (or files) you are working on. (An object file holds the objects that represent your real devices, interfaces, networks and so on that you'll use to configure your firewall device and its policies.)</para>

      <figure id="main-win1">
          <title>The main window</title>
              <graphic scale="40" fileref="fwbMainWindow.png" />
        </figure>

      <para>With an object file loaded, the main window consists of the following "areas":</para>

	<itemizedlist spacing="compact">
              <listitem>
                <para>Menu and Button bars: Firewall Builder comes with menu and button bars at the top of the window.</para>
              </listitem>
	      <listitem>
                <para>Display area: Below the menus is the Display area. The display area displays one or more open object files. An object file contains the Object Trees, Policy Views, and Dialog Area.</para>
              </listitem>
              <listitem>
                <para>Object Trees: Object trees, displayed on the left side of the window, hold firewall, host, interface, service, and other "objects" that you will used when creating your firewall.</para>
              </listitem>
              <listitem>
                <para>Policy View: The policy view area, in the upper right of the screen, displays the access, NAT, or routing policy you're working on. </para>
              </listitem>
              <listitem>
                <para>Dialog Area: The dialog area, in the lower right, is where you make changes to object parameters. The dialog area, which is not visible at first, appears when you select an object in the GUI. </para>
              </listitem>
          </itemizedlist>

      <para>We'll describe these areas in more detail below.</para>
      </sect1>

      <sect1 id="gui-menus">
	<title>GUI Menu and Button Bars</title>

      <figure id="main-win-menus">
          <title>Menu and Button Bars</title>
              <graphic scale="70" fileref="fwbMainWindow-3.png" />
        </figure>

      <para>The <guimenu>File</guimenu> menu provides the same file management options found in most GUIs, plus it lets you import and export libraries and manage your object files with the revision control system.</para>

      <table frame='none'><title>File Menu</title>
	<tgroup cols='2' align='left'  rowsep='1'>
	  <colspec colname='c1'/>
	  <colspec colname='c2'/>
	    <thead>
	      <row>
		<entry>File Menu entry</entry>
		<entry>Explanation</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>New Object File</entry>
		<entry>Opens a "file" dialog that lets you name your new object file. Object file names should end with ".fwb". In general, you should create a new directory for your object files.</entry>
	      </row>
	      <row>
		<entry>Open...</entry>
		<entry>Opens a standard "file" dialog that lets you select an existing file. The file dialog, by default, only looks for files that end in ".fwb".</entry>
	      </row>
	      <row>
		<entry>Open Recent</entry>
		<entry>Contains a sub-menu listing recently opened object files.</entry>
	      </row>
	      <row>
		<entry>Save</entry>
		<entry>Saves the current file.</entry>
	      </row>
	      <row>
		<entry>Save As...</entry>
		<entry>Opens a "file" dialog that lets you save the object file under a new name.</entry>
	      </row>
	      <row>
		<entry>Close</entry>
		<entry>Closes the current object file, but does not exit the program.</entry>
	      </row>
	      <row>
		<entry>Properties</entry>
		<entry>Opens a dialog indicating properties of the current file, including revision control information (if applicable.) (Program preferences are in the Edit menu.)</entry>
	      </row>
	      <row>
		<entry>Add File to RCS</entry>
		<entry>This menu item adds the object file to reversion control. See <xref linkend="rcs" /> for a detailed explanation.</entry>
	      </row>
	      <row>
		<entry>Commit</entry>
		<entry>Commits current changes to RCS. (This option is grayed out if the file has not already been added to RCS.)  See <xref linkend="rcs" /> for a detailed explanation.</entry>
	      </row>
	      <row>
		<entry>Import Policy</entry>
		<entry>Allows you to import an existing policy into Firewall Builder.</entry>
	      </row>
	      <row>
		<entry>Import Library</entry>
		<entry>Lets you import an Object Library. (See <guimenuitem>Export Library</guimenuitem>.)</entry>
	      </row>
	      <row>
		<entry>Export Library</entry>
		<entry>Brings up a dialog that lets you select which Object Library you wish to export to a ".fwl" file. Once exported, you can import it into another instantiation of Firewall Builder. This is particularly useful in Enterprise settings that have multiple Firewall Builder workstations and administrators.</entry>
	      </row>
	      <row>
		<entry>Print</entry>
		<entry>Lets you print your policy.</entry>
	      </row>
	      <row>
		<entry>Exit</entry>
		<entry>Closes Firewall Builder.</entry>
	      </row>
	  </tbody>
	</tgroup>
      </table>

      <para>The <guimenu>Edit</guimenu> options are self-explanatory if you're familiar with GUI-based Tools. However, the <guimenuitem>Preferences</guimenuitem> require some explanation.</para>

      <para>To open the <guilabel>Preferences</guilabel> dialog, select <guimenuitem>Edit/Preferences...</guimenuitem>. The dialog has several tabs, described here.</para>

      <figure id="preferences-dialog">
        <title>The GUI Preferences Dialog</title>
            <graphic scale="60" fileref="fwbPrefGeneral.png" />
      </figure>

      <table frame='none'><title>Preferences>General tab</title>
	<tgroup cols='2' align='left'  rowsep='1'>
	  <colspec colname='c1'/>
	  <colspec colname='c2'/>
	    <thead>
	      <row>
		<entry>General Preferences</entry>
		<entry>Explanation</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>Working Directory</entry>
		<entry>This option tells the program where it should store the
                data file. Policy compilers also store firewall configuration
                files or scripts they produce in the this directory. If this
                parameter is left blank, then the policy compiler will store
                the firewall configuration it generates in the same directory
                as the original data file.</entry>
	      </row>
	      <row>
		<entry>Check for updates automatically</entry>
		<entry>If checked, the program checks for program updates every time it starts.</entry>
	      </row>
	      <row>
		<entry>Check Now</entry>
		<entry>Click if you want the program to check for updates at that moment.</entry>
	      </row>
	      <row>
		<entry>Use http proxy while checking for updates (host:port)</entry>
		<entry>Whether you use the automatic or manual method to check for updates, if you are behind a proxy, enter the
                host IP and port of the proxy in this
                field. Separate the host IP and port number with a colon
                (:).</entry>
	      </row>
	  </tbody>
	</tgroup>
      </table>

     <table frame='none'><title>Preferences>Objects tab</title>
	<tgroup cols='2' align='left'  rowsep='1'>
	  <colspec colname='c1'/>
	  <colspec colname='c2'/>
	    <thead>
	      <row>
		<entry>Objects Preferences</entry>
		<entry>Explanation</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>Automatically save data in dialogs while switching
                between objects</entry>
		<entry>The GUI shows a dialog for every opened object in the
                same place (the right half of the main window). Normally if
                you have made changes to an object's data and want
                to switch to another object without clicking on the
                <guibutton>Apply</guibutton> or
                <guibutton>Undo</guibutton> button, GUI shows a pop-up
                dialog asking whether data should be saved or changes should
                be ignored. If this option is turned on, the program
                automatically saves unsaved data every time you open another object in the dialog area.</entry>
	      </row>
	      <row>
		<entry>Enable object tooltips</entry>
		<entry>Firewall Builder can show a summary of an object's
                properties in a quick pop-up window (a "tooltip") when you places the mouse cursor over
                an object icon. If this is not enabled, then you must click
                on an object to get the same information. The
                <guilabel>Tooltip delay</guilabel> control sets the delay, in
                seconds, between the time you hover the cursor and the time the tooltip appears.</entry>
	      </row>
	      <row>
		<entry>Show deleted objects</entry>
		<entry>Selecting this checkbox turns on a third object tree:
                Deleted Objects. Once activated, the Deleted Objects tree acts
                like trash can (or recycle bin) for deleted objects. If you
                delete something by mistake, you can retrieve it.</entry>
	      </row>
	      <row>
		<entry>Clip comments in rules</entry>
		<entry>Comments in a rule can sometimes make the rule line
                taller, reducing the number of rules visible on a screen.
                Select this if you want comments to be truncated in the view if they take up more than one line.</entry>
	      </row>
	  </tbody>
	</tgroup>
      </table>

     <table frame='none'><title>Preferences>Data File tab</title>
	<tgroup cols='2' align='left'  rowsep='1'>
	  <colspec colname='c1'/>
	  <colspec colname='c2'/>
	    <thead>
	      <row>
		<entry>Data File Preferences</entry>
		<entry>Explanation</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>Periodically save data to file every ... minute</entry>
		<entry>If checked, automatically saves your data every
                specified number of minutes.</entry>
	      </row>
	      <row>
		<entry>Do not ask for the log record when checking in the new
                file version</entry>
		<entry>Only affects RCS. If selected, the program does not
                prompt you for a "comment" when you check your file back into
                RCS.  See <xref linkend="rcs" /> for a detailed explanation on using revision control with Firewall Builder.</entry>
	      </row>
	      <row>
		<entry>Enable compression of the data file</entry>
		<entry>If selected, your data file will be compressed to save
                disk space.</entry>
	      </row>
	  </tbody>
	</tgroup>
      </table>

     <table frame='none'><title>Preferences>SSH tab</title>
	<tgroup cols='2' align='left'  rowsep='1'>
	  <colspec colname='c1'/>
	  <colspec colname='c2'/>
	    <thead>
	      <row>
		<entry>SSH Preferences</entry>
		<entry>Explanation</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>SSH and SCP paths</entry>
		<entry>These fields let the program know where your SSH and SCP
            programs (or their equivalents) live. If they are in your PATH,
            then you don't have to specify the complete paths to them. On Windows, however, you must install putty. See <xref linkend="install-putty" /> for instructions.</entry>
	      </row>
	  </tbody>
	</tgroup>
      </table>

     <table frame='none'><title>Preferences>Labels tab</title>
	<tgroup cols='2' align='left'  rowsep='1'>
	  <colspec colname='c1'/>
	  <colspec colname='c2'/>
	    <thead>
	      <row>
		<entry>Labels Preferences</entry>
		<entry>Explanation</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>Labels</entry>
		<entry>You can assign colors to particular rows in your policies to
            make them stand out visually. You can change the text label
            associated with each color using this tab. While the color shows
            up in the ruleset, the text label only appears in the label
            list.</entry>
	      </row>
	  </tbody>
	</tgroup>
      </table>

     <table frame='none'><title>Preferences>Icons tab</title>
	<tgroup cols='2' align='left'  rowsep='1'>
	  <colspec colname='c1'/>
	  <colspec colname='c2'/>
	    <thead>
	      <row>
		<entry>Icons Preferences</entry>
		<entry>Explanation</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>Show icons in rules</entry>
		<entry>By default, objects such as interfaces, hosts, and
                networks show up as both an icon and text. De-select this to have
                only the text appear (no icon).</entry>
	      </row>
	      <row>
		<entry>Show text descriptions in columns
                "Direction","Action"</entry>
		<entry>By default, the Direction and Action columns show only
                icons. Select this to have text appear as well.</entry>
	      </row>
	      <row>
		<entry>Icon size</entry>
		<entry>By default, icons are 25x25 pixels. Select <guilabel>16x16</guilabel> to make
                them somewhat smaller. (The larger icons are easier to see, the smaller ones are suitable for smaller displays, such as laptop screens.)</entry>
	      </row>
	  </tbody>
	</tgroup>
      </table>

     <table frame='none'><title>Preferences>Fonts tab</title>
	<tgroup cols='2' align='left' rowsep='1'>
	  <colspec colname='c1'/>
	  <colspec colname='c2'/>
	    <thead>
	      <row>
		<entry>Fonts Preferences</entry>
		<entry>Explanation</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>Fonts</entry>
		<entry>Use these controls to set the font used for rules and the
            font used in the object tree, respectively.</entry>
	      </row>
	  </tbody>
	</tgroup>
      </table>

      <para>The <guimenu>Object</guimenu> lets you create a new object, find occurrences of an object (including doing replaces), lock an object to prevent accidentally changes, and unlock an object when you need to edit it.</para>

      <table frame='none'><title>Object menu</title>
	<tgroup cols='2' align='left' rowsep='1'>
	  <colspec colname='c1'/>
	  <colspec colname='c2'/>
	    <thead>
	      <row>
		<entry>Object Menu entry</entry>
		<entry>Explanation</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>New Object</entry>
		<entry>Opens a menu of all possible object types. Select one to create a new object of that type. <xref linkend="creating-objects" /> describes how to create objects.</entry>
	      </row>
	      <row>
		<entry>Find Object</entry>
		<entry>Opens the <guilabel>Find object</guilabel> dialog, which also provides search-and-replace functions. <xref linkend="find-replace" /> explains how to use this dialog.</entry>
	      </row>
	      <row>
		<entry>Lock</entry>
		<entry>Makes the selected object read-only, which prevents accidental modification. An object that is locked has a little padlock for its icon. In this example, the eth0 interface of test server is locked. Locking the eth0 interface object also renders read-only the address objects associated with the interface. (test server, because it is "above" eth0 in the hierarchy, is still editable.) <inlinegraphic scale="70" fileref="locked.png"/></entry>
	      </row>
	      <row>
		<entry>Unlock</entry>
		<entry>Unlocks the selected icon. The object becomes editable, and the objects associated with it become editable as well, unless they have their own locks. <inlinegraphic scale="70" fileref="unlocked.png"/></entry>
	      </row>
	  </tbody>
	</tgroup>
      </table>

      <para>The <guimenu>Rules</guimenu> lets you add, delete, and rearrange rules in a policy. In addition, it lets you compile and install a complete set of firewall policies.</para> 

      <table frame='none'><title>Rules menu</title>
	<tgroup cols='2' align='left' rowsep='1'>
	  <colspec colname='c1'/>
	  <colspec colname='c2'/>
	    <thead>
	      <row>
		<entry>Rules Menu entry</entry>
		<entry>Explanation</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>Insert Rule</entry>
		<entry>Inserts a blank rule above the currently selected rule. If no rule is selected, inserts a blank rule in position 0 of the current ruleset.</entry>
	      </row>
	      <row>
		<entry>Add Rule Below</entry>
		<entry>Adds a rule below the currently selected rule.</entry>
	      </row>
	      <row>
		<entry>Remove Rule</entry>
		<entry>Removes the currently selected rule.</entry>
	      </row>
	      <row>
		<entry>Move Selected Rules</entry>
		<entry><para>Opens a dialog that lets you specify where the selected rule(s) should go. Firewall Builder will move rules down to make room for the rule; selecting a rule that has contents does not replace the rule, it moves it down.</para>
		  <para>To select multiple rules, click on one rule, then shift-click on another rule <emphasis>in the first column</emphasis> (the rule number column). You must select a contiguous set. To select one rule, click anywhere.</para></entry>
	      </row>
	      <row>
		<entry>Copy Rule</entry>
		<entry>Copies the selected rule to the clipboard.</entry>
	      </row>
	      <row>
		<entry>Cut Rule</entry>
		<entry>Copies the selected rule to the clipboard and removes it from the ruleset.</entry>
	      </row>
	      <row>
		<entry>Paste Rule Above</entry>
		<entry>Pastes the rule on the clipboard into the currently selected rule row. Moves the selected rule (and all other rules below it) down to make room.</entry>
	      </row>
	      <row>
		<entry>Paste Rule Below</entry>
		<entry>Pastes the rule on the clipboard below the currently selected rule. Moves lower rules down to make room.</entry>
	      </row>
	      <row>
		<entry>Compile</entry>
		<entry>Opens a dialog that lets you specify which of the firewalls in the current object file you wish to compile. See <xref linkend="compile-install-policy" />.</entry>
	      </row>
	      <row>
		<entry>Install</entry>
		<entry>Opens a dialog that lets you install a compiled firewall onto an actual target device. See <xref linkend="compile-install-policy" />.</entry>
	      </row>
	  </tbody>
	</tgroup>
      </table>

     <para>The <guimenu>Tools</guimenu> menu provides access to useful tools.</para>

     <table frame='none'><title>Tools menu</title>
	<tgroup cols='2' align='left' rowsep='1'>
	  <colspec colname='c1'/>
	  <colspec colname='c2'/>
	    <thead>
	      <row>
		<entry>Tools Menu entry</entry>
		<entry>Explanation</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>Find Conflicting Objects In Two Files</entry>
		<entry>Launches a tool that lets you specify two object files (.fwb) or two library files (.fwl). The tool then looks for objects that have the same ID, but different characteristics. Such a conflict would cause a problem if you wanted to merge the files.</entry>
	      </row>
	      <row>
		<entry>Discovery Druid</entry>
		<entry>Launches a wizard that lets you populate many objects automatically via an SNMP crawl, via an existing "hosts" file, or via the import of an existing firewall policy. ( <xref linkend="network-discovery" /> ) explains the tool.</entry>
	      </row>
	  </tbody>
	</tgroup>
      </table>

      <para>The <guimenu>Window</guimenu> menu provides controls for selecting and rearranging object file windows. It works similarly to Window menus in most GUIs.</para>

      <para>The <guimenu>Help</guimenu> provides access to help resources, information about the current version of Firewall Builder, and a dialog with debugging information.</para> 

      <para>The Button Bar has buttons for commonly used functions:</para>

      <figure id="main-buttons">
          <title>Buttons</title>
              <graphic scale="70" fileref="fwbMainWindow-3.png" />
        </figure>

     <table frame='none'><title>Button bar</title>
	<tgroup cols='2' align='left' rowsep='1'>
	  <colspec colname='c1'/>
	  <colspec colname='c2'/>
	    <thead>
	      <row>
		<entry>Button</entry>
		<entry>Explanation</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>Open</entry>
		<entry>Opens a standard "file" dialog that lets you select an existing file. The file dialog, by default, only looks for files that end in ".fwb".</entry>
	      </row>
	      <row>
		<entry>Save</entry>
		<entry>Saves the current file.</entry>
	      </row>
	      <row>
		<entry>Find</entry>
		<entry>Opens the <guilabel>Find object</guilabel> dialog, which also provides search-and-replace functions.  <xref linkend="find-replace" /> explains how to use this dialog.</entry>
	      </row>
	      <row>
		<entry>Compile</entry>
		<entry>Opens the compile wizard. <xref linkend="compile-install-policy" /> explains this in more detail.</entry>
	      </row>
	      <row>
		<entry>Install</entry>
		<entry>Opens the compile/install wizard. <xref linkend="compile-install-policy" /> explains this in more detail.</entry>
	      </row>
	  </tbody>
	</tgroup>
      </table>

    </sect1>

      <sect1 id="gui-display">
	<title>Display area</title>
	<para>The display area is where you view and work on your object files.</para>
      <para>You can open more than one object file window at a time. You can even have the same object file open in two different windows at the same time. (Just use the <guimenuitem>Open</guimenuitem> or <guimenuitem>Open Recent</guimenuitem> again.) If you do, the two views onto the same file are synchronized and work with the
      same object tree. Changes made to the object in one window are
      immediately reflected in all windows, both in the
      tree and in the dialog. See <xref linkend="multiple-data-files" /> for an example of working with multiple data files.</para>

      <para>This figure shows two object files open at the same time.</para>

      <figure id="main-win2">
          <title>The main window</title>
              <graphic scale="40" fileref="fwbMainWindow-2.png" />
        </figure>

      <para>Drag-and-drop and Copy/Paste operations work across different
      windows.</para>

      </sect1>

    <sect1>
    <title>Object Tree</title>

      <figure float="1" id="tree-structure" pgwide="0">
        <title>Object Tree Structure</title>
            <graphic scale="80" fileref="fwbMainWindow-4.png" />
      </figure>

      <para>The object tree stores all objects in a predefined hierarchy.
      Types that correspond to network objects (hosts, address ranges,
      networks and groups of these) are located in the <guilabel>Objects</guilabel> branch, types
      that correspond to services are in the <guilabel>Services</guilabel> branch, time
      intervals are in the <guilabel>Time</guilabel> branch, and all firewalls are in the
      <guilabel>Firewalls</guilabel> branch. Newly created objects are automatically placed in
      the appropriate position in the tree. Each branch of the tree is
      automatically sorted by the object name.</para>

      <para>The program has three default libraries: User, Standard, and Deleted Objects. (Deleted Objects must be turned on in <guimenuitem>File>Preferences>Objects>Show deleted objects</guimenuitem>. <guilabel>User</guilabel> holds
      objects that you define, including objects for your firewall, hosts, and networks. <guilabel>Standard</guilabel> holds a collection of standard
      objects that come with the program, and <guilabel>Deleted Objects</guilabel> acts like a trash can or recycle bin for user objects you delete. In addition, you can create tailored libraries by selecting <guimenuitem>New Library</guimenuitem> from the <guimenu>New Object</guimenu> menu and populating it by copy-and-pasting objects from one of the other views (or creating them there from scratch). <xref linkend="new-library" /> has instructions for creating and distributing user-defined libraries.</para>

      <para>Functionally, there is no difference between having an object in the Standard 
      tree, the User tree, or a user defined tree; it is just a convenient way to sort objects in the tree. You
      can think of each as a kind of the "view". It only affects representation
      of the data in the GUI; objects are all equal in all other senses and
      you can use an object from any library in your policy. You
      need not (and cannot) insert objects into the Standard tree.</para>

      <para>The object
      that is currently selected in the tree is highlighted in color and is
      shown in the dialog area on the right.</para>

      <figure float="1" id="main-standard-objects">
        <title>Standard Objects</title>
            <graphic scale="80" fileref="pict_095.png" />
      </figure>

      <para>Firewall Builder understands and uses the object and service types described in the table below. See <xref linkend="working-with-objects" /> and <xref linkend="working-with-services" /> for more detailed information.</para>

     <table frame='none'><title>Object Types</title>
	<tgroup cols='2' align='left' rowsep='1'>
	  <colspec colname='c1'/>
	  <colspec colname='c2'/>
	    <thead>
	      <row>
		<entry>Object Type</entry>
		<entry>Explanation</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>Library</entry>
		<entry>Firewall Builder comes with the Standard, User, and Deleted Objects libraries. In addition, you can create your own.</entry>
	      </row>
	      <row>
		<entry>Firewall</entry>
		<entry>Represents a physical firewall device, its interfaces and addresses, and the policy rulesets associated with the device. Use Firewall Builder to model your actual device's firewall software, OS, interfaces and addresses. Then, use Firewall Builder to construct the policy rulesets to assign to the device.</entry>
	      </row>
	      <row>
		<entry>Host</entry>
		<entry>A computer on your network. Hosts can have interfaces associated with them.</entry>
	      </row>
	      <row>
		<entry>Interface</entry>
		<entry>A physical interface on a firewall or host. Interfaces can have IP and physical (MAC) addresses associated with them. An IP address can be created from the <guimenu>New Object</guimenu> for the selected interface, but physical addresses can only be created by right-clicking on an interface object.</entry>
	      </row>
	      <row>
		<entry>Network</entry>
		<entry>An IPv4 subnet</entry>
	      </row>
	      <row>
		<entry>Network IPv6</entry>
		<entry>An IPv6 subnet</entry>
	      </row>
	      <row>
		<entry>Address</entry>
		<entry>An IPv4 address</entry>
	      </row>
	      <row>
		<entry>Address IPv6</entry>
		<entry>An IPv6 address</entry>
	      </row>
	      <row>
		<entry>DNS Name</entry>
		<entry>A DNS Name object represents a DNS "A" or "AAAA" record and can resolve it into an IP address at compile or run time.</entry>
	      </row>
	      <row>
		<entry>Address Table</entry>
		<entry>Objects of this type can be configured with the name of an external file that is expected to contain a list of IP addresses (a mix of IPv4 and IPv6 is supported). Addresses can be loaded during policy compile or during the execution of a generated firewall script.</entry>
	      </row>
	      <row>
		<entry>Address Range</entry>
		<entry>A range of IPv4 or IPv6 IP addresses. This range does not have to be a specific subnet, but it does have to be contiguous.</entry>
	      </row>
	      <row>
		<entry>Object Group</entry>
		<entry>A collection of addressable objects (objects that have or contain IP addresses) such as network, interface, and hosts objects. Useful for creating a less cluttered-looking firewall policy and for making sure you have the same objects in every related rule.</entry>
	      </row>
	      <row>
		<entry>Custom Service</entry>
		<entry>Can be used to inject arbitrary code into the generated firewall script.</entry>
	      </row>
	      <row>
		<entry>IP Service</entry>
		<entry>An IP service such as GRE, ESP, or VRRP. IP Service objects cover IP services that are <emphasis>not</emphasis> ICMP, ICMP6, TCP, or UDP services.</entry>
	      </row>
	      <row>
		<entry>ICMP Service</entry>
		<entry>An ICMP service such as a ping request or reply</entry>
	      </row>
	      <row>
		<entry>ICMP6 Service</entry>
		<entry>An ICMP6 service such as "ipv6 packet too big", "ipv6 ping request", or "ipv6 ping reply"</entry>
	      </row>
	      <row>
		<entry>TCP Service</entry>
		<entry>TCP services such as HTTP, SMTP, or FTP</entry>
	      </row>
	      <row>
		<entry>UDP Service</entry>
		<entry>A UDP service such as DNS or NTP</entry>
	      </row>
	      <row>
		<entry>TagService</entry>
		<entry>A service object that lets you examine the tag in an IP header. You can then construct your rule to take appropriate action on a match.</entry>
	      </row>
	      <row>
		<entry>User Service</entry>
		<entry>A User Service object matches the owner of the process on the firewall that send the packet. It translates to the "owner" match in iptables and "user" parameter for PF.</entry>
	      </row>
	      <row>
		<entry>Service Group</entry>
		<entry>A collection of services. For example, Firewall Builder comes with the Useful_ICMP service group that contains the "time exceeded", "time exceeded in transit", "ping reply", and "all ICMP unreachable" ICMP services. It also comes with a "DNS" service group that contains both the UDP and TCP version of DNS. Useful for creating a less cluttered-looking firewall policy and for making sure you have the same objects in every related rule.</entry>
	      </row>
	      <row>
		<entry>Time Interval</entry>
		<entry>A time period such as "weekends" or a range of dates, or a range of times on certain days of the week. Can be used as part of rule matching in Access Policy rulesets to provide or deny access to something based on time. Note that these time intervals are relative to the time on the firewall device itself.</entry>
	      </row>
	  </tbody>
	</tgroup>
      </table>

    </sect1>

    <sect1 id="creating-objects">
      <title>Creating Objects</title>

      <para>New objects can be created using the
      <guimenu>New Object</guimenu> menu, accessed by clicking this icon above the object tree:
	<inlinegraphic scale="70" fileref="new-object-icon.png"/>. Certain objects can also
      be created via a pop-up menu that can be opened by right-clicking on a parent object in the tree.</para>

      <figure float="1" id="menu-new-object">
        <title>Creating Objects Using The Object Menu</title>
            <graphic scale="80" fileref="menu-new-object.png" />
      </figure>

      <para>You can create all objects except physical address objects through the New Object menu. (Physical address objects can only be created by right-clicking on an existing Interface object.) You can also create objects
      by right-clicking on a folder in a tree (though not in the read-only Standard tree). If you right-click a folder, you can only create objects appropriate to that folder. For example, the interface object can only be placed under a
      host or firewall object, so the option <guimenuitem>Add Interface</guimenuitem>
      is available only if you right-click on a host or firewall.</para>

      <figure float="1" id="menu-right-click-new-object">
        <title>Creating Objects by Right-Clicking</title>
            <graphic scale="80" fileref="menu-right-click-new-object.png" />
      </figure>

      <para>Another way to create objects is to use the <guimenuitem>Duplicate</guimenuitem> option when you right click on an object. This allows you to create a copy of the object. For example, you may want to create a firewall policy for one platform, duplicate it, then just change the target platform on the copy. However, copies are not linked in any way. A change to the original has no affect on the copy, and vice versa.</para>
    </sect1>

    <sect1>
      <title>Navigating The Object Tree and Editing Objects in the Object Dialog</title>

      <para>The object selected in the tree automatically appears in the
      dialog area, where it can be reviewed or modified. Objects are opened by
      a single mouse click in the tree. Clicking the right button when the
      mouse cursor is over the object's label in the tree brings up the pop-up
      menu. This menu is context-sensitive and provides items for the
      following functions:</para>

      <table frame='none'><title>Object Right-Click Menu</title>
	<tgroup cols='2' align='left'  rowsep='1'>
	  <colspec colname='c1'/>
	  <colspec colname='c2'/>
	    <thead>
	      <row>
		<entry>Right-Click Menu Entry</entry>
		<entry>Explanation</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>Edit</entry>
		<entry>Opens the Edit dialog for that object. (You can get the same result by left-clicking on the object.)</entry>
	      </row>
	      <row>
		<entry>Duplicate</entry>
		<entry>Places a copy of the object into the specified library. (If no user-created libraries exist, then Firewall Builder puts the object in the User tree by default.) The new object has
            the same name as the original object, unless that object name is already in use in that tree. If so, a "-1" is appended to the object name.</entry>
	      </row>
	      <row>
		<entry>Copy</entry>
		<entry>Copies an object onto the clipboard.</entry>
	      </row>
	      <row>
		<entry>Cut</entry>
		<entry>Copies an object onto the clipboard and removes it from
            the tree.</entry>
	      </row>
	      <row>
		<entry>Paste</entry>
		<entry>Puts a copy of the object on the clipboard into a tree or into the policy, depending on where the mouse is when you click.</entry>
	      </row>
	      <row>
		<entry>Delete</entry>
		<entry>Deletes an object without making a copy on the
            clipboard. If the Deleted Objects tree has been turned on, the object shows up there.</entry>
	      </row>
	      <row>
		<entry>Find</entry>
		<entry><para>Brings up a Find/Find-and-Replace panel. Click <guibutton>Next</guibutton> in the panel to see all instances of the object boxed in red.</para>
		<para>To do a Search and Replace, drag another object into the <guilabel>Replace object</guilabel> box, specify a scope for the replacement using the pull-down menu, and then use the <guibutton>Replace All</guibutton>, <guibutton>Replace</guibutton>, <guibutton>Replace &amp; Find</guibutton>, and <guibutton>Next</guibutton> buttons.</para> <xref linkend="find-replace" /> has details on this dialog.</entry>
	      </row>
	      <row>
		<entry>Used Where</entry>
		<entry>Scans the whole tree, including all groups and policies
            of all firewalls, looking for references to the object. In
            the end the program shows a pop-up dialog with icons corresponding
            to groups and firewalls that use the object. Double-clicking
            an icon opens the corresponding object in the main
            window.</entry>
	      </row>
	      <row>
		<entry>Lock and Unlock</entry>
		<entry>Lock makes an object read-only, which prevents accidental modification. Unlock puts the object back into read/write mode.</entry>
	      </row>
	  </tbody>
	</tgroup>
      </table>

      <para>The pop-up menu can also have items to add interface and address
      objects, depending on what type of object was clicked on.</para>

      <para>In general, the GUI has been designed to "look and feel" like a
      typical file browser (for example, Windows Explorer). It shows object groups as
      a collection of icons, where each icon represents an individual object. You can navigate between objects
      either using the mouse or keyboard arrow keys. The active object is
      highlighted with a different color. Double-clicking on the icon in the
      group view opens the corresponding object. Right-clicking opens a pop-up menu that has <guimenuitem>Open Object</guimenuitem>,
      <guimenuitem>Copy</guimenuitem>, <guimenuitem>Cut</guimenuitem>, and <guimenuitem>Paste</guimenuitem> options.</para>

      <figure float="1" id="interface-dialog">
        <title>Interface Dialog</title>
            <graphic scale="60" fileref="host-interface1.png" />
      </figure>

      <para>Dialogs for objects that can be edited have an
      <guibutton>Apply</guibutton> button
      at the bottom. Initially this button is inactive, but once the
      object's parameters have been modified in the dialog, or group members
      have been added or removed, the button becomes active so you
      can click <guibutton>Apply</guibutton> to save new data.
      If you try to switch to another object without saving, the program shows a pop-up dialog
      asking if you want to save the changes, discard them, or continue editing them. There is also an option to
      make the program automatically save modified data when you switch
      between objects. See the <guimenuitem>Edit>Preferences</guimenuitem> dialog in <xref linkend="gui-menus" />.</para>
    </sect1>

    <sect1 id="policy-rulesets">
      <title>Policy Rulesets</title>

      <para>The main purpose of Firewall Builder is, of course, to create actual firewall policies. For that you use the rule sets view. This figure shows the Access Policy ruleset for a firewall called "guardian":</para>

      <figure float="1" id="policy-rulesets-figure">
        <title>Policy Rule set</title>
            <graphic scale="60" fileref="fwbMainWindow-7.png" />
      </figure>

      <para>You can see on the left that <guilabel>Policy</guilabel> is selected under the "guardian" firewall. The access policy (Policy), NAT, and Routing rulesets exist as leaves under a particular firewall in the object tree. Selecting the rule set in the object tree causes it to appear on the right. The same rule set stays visible when you select other objects in tree, but if you select another policy, then that policy appears instead.</para>

      <para>Each row in the table is a different rule. Rules are processed top-to-bottom. See <xref linkend="firewall-policies" /> for explanations of the rule sets and how to work with them.</para>

    </sect1>

    <sect1 id="multiple-data-files">
      <title>Working with multiple data files</title>

      <para>This section shows an example of working with two data files at the same time.</para>

  <para>
    We start with a data file. Note the
    file name, "test.fwb", is shown in the main window title bar.
  </para>

  <figure float="1">
    <title>Data file</title>
    <graphic scale="50" fileref="multifile_slide_1.png"/>
  </figure>

  <para>
    Use <guimenuitem>File/Open</guimenuitem> to open another data file.
  </para>


  <figure float="1">
    <title>Data file</title>
    <graphic scale="50" fileref="multifile_slide_2.png"/>
  </figure>

  <para>
    Here we see file "1.fwb" opened in the GUI. Its name is now shown in
    the title bar of the window.
  </para>


  <figure float="1">
    <title>1.fwb</title>
    <graphic scale="50" fileref="multifile_slide_3.png"/>
  </figure>


  <para>
    The <guimenu>Window</guimenu> menu supports the usual windows operations: you can
    maximize and minimize them, as well as cascade or tile them and switch
    from one to another.
  </para>

  <figure float="1">
    <title>Window menu</title>
    <graphic scale="50" fileref="multifile_slide_4.png"/>
  </figure>

  <para>
    Here we have both windows shown. The size of the main windows was
    rather small to keep the size of the screen shots down, so two windows do not
    fit well. However even with such a cramped layout we can move objects
    from one to another using copy/paste or drag-and-drop operations. In this
    example we are going to drag firewall object "test" from the top window
    to the bottom one. We are going to drop it onto the folder "Firewalls"
    in the tree.
  </para>

  <para>
    The same result can be achieved using copy/paste operation. 
  </para>

  <figure float="1">
    <title>Dragging between windows</title>
    <graphic scale="50" fileref="multifile_slide_5.png"/>
  </figure>

  <para>
    Here we maximized the window showing data file "1.fwb"; note that
    firewall object "test" is part of the tree.
  </para>

  <figure float="1">
    <title>Second window now has the object</title>
    <graphic scale="50" fileref="multifile_slide_6.png"/>
  </figure>

  <para>
    Firewall "test" used a network IPv6 object created in the data file
    "test.fwb". Copying the firewall object "test" also copied all other
    objects it depended on. This image shows that network "local ipv6 net"
    is now part of the data file "1.fwb".
  </para>

  <figure float="1">
    <title>local ipv6 net</title>
    <graphic scale="50" fileref="multifile_slide_7.png"/>
  </figure>
  
  </sect1>
 
  </chapter>

  <!-- *************************************************************** -->

  <chapter id="working-with-objects">
    <title>Working With Objects</title>

      <para>Firewall Builder supports a variety of object types, both simple and complex. Simple object types include Address, Network, Host, and IP, TCP, UDP and ICMP service objects. More complex object types are Firewall, Address Table, DNS Name, and User Service.</para>

      <para>There are the following types of objects in Firewall Builder:</para>
      <itemizedlist spacing="compact">
              <listitem>
                <para>Addressable objects: <xref linkend="addressable-objects" /> describes objects that have, either directly or indirectly, an address of some kind. This category includes the physical objects (firewalls, hosts, interfaces) as well as some logical objects (networks, address ranges, individual addresses). Addressable objects can be grouped together into Object groups.</para>
		</listitem>
	      <listitem>
                <para>Service objects: <xref linkend="working-with-services" /> describes objects that represent services. They include IP, TCP, UDP, and ICMP services, as well as user services. Service objects can be grouped together into Service groups.</para>
		</listitem>
	      <listitem>
                <para>Time Interval objects: Described in <xref linkend="time-interval-objects" />, these represent a discreet or recurring period of time. They can be used as part of a rule in the firewall. For example, you could have a rule that matches on weekends, but not during the week.</para>
		</listitem>
	      <listitem>
		<para>Rule set objects: Described in <xref linkend="rule-set-objects" />, these represent the various rule sets in a firewall. By default, a firewall starts with one access policy, one NAT, and one routing rule set, but you can add more of each. Rule set objects only exist as child objects of a firewall.</para></listitem>
	</itemizedlist>

      <para>All objects in Firewall Builder have some characteristics in common.</para>
      <para>All objects have a <guilabel>Name</guilabel> field and a <guilabel>Comment</guilabel> field. The Name field can contain white spaces
      and can be arbitrarily long (though shorter names work better in the GUI). The Comment field 
      can contain any text of any length.</para>

   <sect1 id="addressable-objects">
    <title>Addressable Objects</title>
    <para>In this section we examine object types that represent addresses or groups of addresses.</para>

    <sect2>
      <title>Common Properties of Addressable Objects</title>
      <para>Objects that contain IP address fields provide validity checking for the address when the object is saved. Invalid IP addresses produce an error.</para>
    </sect2>

    <sect2 id="firewall-object">
      <title>The Firewall Object</title>
	<para>A firewall object represents a real firewall device in your network. This firewall object will have interface and IP address objects that mirror the real interfaces and IP addresses of the actual device. In addition, the firewall object is where you create the access policy rule sets, NAT rule sets, and routing rule sets that you assign to your firewall device.</para>

	<para>By default, a firewall has one Policy rule set, one NAT rule set, and one routing rule set. However, you can create more than one rule set of each type for a firewall. On the other hand, you don't have to populate all the rule sets. You can, for example, create a Policy ruleset and leave the NAT and Routing rule sets empty. <xref linkend="policies-and-rules" /> explains more about policies and rule sets.</para>

	<para>To speed up the creation of a firewall object, Firewall Builder has a wizard that walks you through creating the object. The wizard has three options for creating a firewall object: </para>

            <para><itemizedlist spacing="compact">
              <listitem>
                <para>From a template: Firewall Builder comes with several pre-defined templates. You can use these to create a firewall that is close to your configuration, then modify it to fit your needs. This method is shown in <xref linkend="gettingstarted" />.</para>
		</listitem>
              <listitem>
                <para>Manually: You can provide interface IP address, subnet mask, gateway, and other parameters manually. You can add this information when you create the firewall, or  you can add it later. <xref linkend="creating_firewall_manually" /> (below) describes this process.</para>
	      </listitem>
              <listitem>
                <para>Via SNMP: Firewall builder uses SNMP queries to learn about the network. <xref linkend="firewall-snmp" /> describes this process.</para>
	      </listitem>
	    </itemizedlist></para>

      <sect3 id="creating_firewall_manually">
        <title>Creating a Firewall Object Manually</title>

        <para>To start the firewall object creation wizard, right-click the <guibutton>Firewalls</guibutton> folder in the User tree and select <guimenuitem>New Firewall</guimenuitem>.</para>

	<para>The first page of this wizard is displayed.</para>
        <figure float="1" id="creating-firewall1-2">
          <title>First Page of the Wizard</title>
              <graphic scale="60" fileref="creating_firewall1.png" />
        </figure>

        <para>Give the firewall object a name. Usually, this name will be the same name as the device, but it doesn't have to be if you're assigning interfaces manually. (If you will use SNMP or DNS to populate the interfaces, then the name must be the same as the device name.) Then specify the firewall software and device OS.</para>

	<para>Leave the <guilabel>Use pre-configured template firewall objects</guilabel> checkbox unchecked.</para>

	<para>Click <guibutton>Next</guibutton>.</para>

        <figure float="1" id="creating-firewall_manual1">
          <title>Choose Configure Interfaces Manually</title>
              <graphic scale="60" fileref="creating_firewall_manual1.png" />
        </figure>

	<para>Select <guibutton>Configure interfaces manually</guibutton> and click <guibutton>Next</guibutton>.</para>

        <figure float="1" id="creating-firewall_manual2">
          <title>Adding Interfaces to the new Firewall Object</title>
              <graphic scale="60" fileref="creating_firewall_manual2.png" />
        </figure>

        <para>Use this screen to add firewall interfaces. Populate the following fields for an interface, then click <guibutton>Add</guibutton> to add the interface. Then, populate the fields again for the next interface. If you make a mistake, click on the interface in the list, make your changes, then click <guibutton>Update</guibutton>.</para>

            <para><itemizedlist spacing="compact">
              <listitem>
                <para><guilabel>Interface type</guilabel>: Indicate the type of interface. <xref linkend="host-interface" /> explains the interface types in more detail. Briefly, though, a <guilabel>Regular interface</guilabel> has a static IP addresses, a <guilabel>Dynamic address</guilabel> interface has a dynamic address provided by something like DHCP, an <guilabel>Unnumbered interface</guilabel> never has an IP address (a PPPoE connection, for example), and a <guilabel>Bridge port</guilabel> is an interface that is bridged in the firewall.</para>
		</listitem>
              <listitem>
                <para><guilabel>Name</guilabel>: The name of the interface object in Firewall Builder must match exactly the name of the interface of the firewall machine it represents. This will be something like "eth0", "eth1", "en0", "br0", and so on.</para>
	      </listitem>
              <listitem>
                <para><guilabel>Label</guilabel>: On most OS's this field is not used and serves the purpose of a descriptive label.  The label is mandatory for Cisco PIX though, where it must reflect the network topology. Firewall Builder GUI uses the label, if it is not blank, to label interfaces in the tree. One of the suggested uses for this field is to mark interfaces to reflect the network topology ('outside', 'inside') or interface purpose ('web frontend' or 'backup subnet').</para>
	      </listitem>
              <listitem>
                <para><guilabel>Address</guilabel>: If the interface has a static IP address, specify it here. (In Firewall Builder version 3.X, this must be an IPv4 address. If you need it to be an IPv6 address, create the interface without an IP address, then add the IPv6 address after you have created the firewall object.)</para>
	      </listitem>
              <listitem>
                <para><guilabel>Netmask</guilabel>: Use either a traditional netmask (255.255.255.0) or slash notation (24, without the actual slash) to specify the interface netmask.</para>
	      </listitem>
              <listitem>
                <para><guilabel>MAC</guilabel>: If you like, you can also specify the interface physical address. The MAC address is not necessary, but it can be used to combat spoofing. If the feature is turned on and available, the firewall will only accept packets from the given IP address if the MAC address also matches the one specified. <xref linkend="using-mac-address" /> has more information.</para>
	      </listitem>
	    </itemizedlist></para>

	<para>Once all the interfaces are configured, click <guibutton>Finish</guibutton> to
        create the new firewall object.</para>

        <note>
          <para>You can always add, modify and delete interfaces later using
          controls provided in the main window.</para>
        </note>
      </sect3>

      <sect3 id="firewall-snmp">
        <title>Creating a Firewall Object using SNMP Discovery</title>
	  <para>If your firewall runs an SNMP daemon, you can save yourself some time by using SNMP discovery to automatically create interfaces of the new firewall object.</para>

        <figure float="1" id="new_firewall_snmp1">
          <title>SNMP 'read' community string</title>
              <graphic scale="70" fileref="new_firewall_wizard_4.png" />
        </figure>

	  <para>Start by checking the <guilabel>Use SNMP to discover interfaces of the firewall</guilabel> checkbox on the second page of the wizard and enter your SNMP 'read' community. Then click <guibutton>Discover interfaces using SNMP</guibutton>.</para>

        <figure float="1" id="new_firewall_snmp2">
          <title>Discovering interfaces via SNMP</title>
              <graphic scale="70" fileref="new_firewall_wizard_5.png" />
        </figure>

	  <para>Firewall Builder runs a series of SNMP queries to the firewall to read the list of interfaces and their addresses. Both IPv4 and IPv6 address can be imported. For IPv6 the firewall must support IP-MIB RFC4293. Once the discovery process finishes, click <guibutton>Next</guibutton>.</para> 

        <figure float="1" id="new_firewall_snmp3">
          <title>Discovering interfaces via SNMP</title>
              <graphic scale="70" fileref="new_firewall_wizard_6.png" />
        </figure>

	  <para>The next page of the wizard offers an opportunity to review the discovered interfaces and make adjustments if necessary. To change something, highlight an interface, edit its parameters in the dialog, then click <guibutton>Update</guibutton>. Finally, when the process is done click <guibutton>Finish</guibutton>. The program creates the new firewall object in the tree and adds all configured interfaces and their addresses.</para>
      </sect3>

      <sect3>
        <title>Editing a Firewall Object</title>

        <para>The Firewall Object represents the firewall machine and is the
        most complex object in Firewall Builder. It has three sets of controls that you can modify, not including the policy rule sets. All these controls become available when you double-click the firewall object in the tree.</para>

        <figure float="1" id="edit_firewall_base_controls">
          <title>Firewall Controls</title>
              <graphic scale="60" fileref="edit_firewall_base_controls.png" />
        </figure>

	<sect4>
	  <title>Basic Firewall Controls</title>
	  <para>These controls let you specify the basic settings of the firewall, such as the name and firewall platform.</para> 
        <para><itemizedlist spacing="compact">
            <listitem>
              <para><guilabel>Name</guilabel>: Specify/change the name of the firewall object.</para>
            </listitem>
            <listitem>
              <para><guilabel>Platform</guilabel>: Specify/change the firewall software.</para>
            </listitem>
            <listitem>
              <para><guilabel>Version</guilabel>: Specify/change the version number of the firewall software. In most cases, you can leave this set to <guilabel>any</guilabel>. In general, setting the version to "any" means the compiler will only support options available in all supported versions of the software. If you need a feature that is only supported by a particular version, then specify that version.</para>
            </listitem>
            <listitem>
              <para><guilabel>Host OS</guilabel>: Specify/change the host operating system of the firewall device.</para>
            </listitem>
            <listitem>
              <para><guilabel>Inactive firewall</guilabel>: Check this box to make the firewall object inactive. The firewall name will change to a regular font (instead of bold) to indicate that it is inactive, and the firewall will not be available for compiling or installation. Essentially, this is a way to "comment out" the firewall object without deleting it.</para>
            </listitem>
            <listitem>
              <para><guibutton>Host OS Settings</guibutton>: Opens the Advanced Settings dialog for the indicated Host OS. Click <guibutton>Help</guibutton> in the dialog for assistance with dialog options. See <xref linkend="host-os-settings-dialog" /> for a screen shot.</para>
            </listitem>
            <listitem>
              <para><guibutton>Firewall Settings</guibutton>: Opens the Advanced Settings dialog for the platform/firewall software. Click <guibutton>Help</guibutton> in the dialog for assistance with dialog options. See <xref linkend="firewall-settings-dialog" /> for a screen shot..</para>
            </listitem>
	    </itemizedlist></para>
	</sect4>

	<sect4 id="host-os-settings-dialog">
	  <title>Host OS Settings Dialog</title>

        <para>For explanations of the various controls, click the <guilabel>Help</guilabel> button in the dialog.</para>

        <figure float="1" id="edit_firewall_howtos_options">
          <title>Firewall Host OS Settings dialog (Linux)</title>
              <graphic scale="70" fileref="edit_firewall_howtos_options.png" />
        </figure>

	</sect4>
	<sect4 id="firewall-settings-dialog">
	  <title>Firewall Settings dialog</title>

	<para>For explanations of the various controls, click the <guilabel>Help</guilabel> button in the dialog.</para>

        <figure float="1" id="edit_firewall_firewallsettings_compiler">
          <title>Firewall Settings dialog (iptables)</title>
              <graphic scale="60" fileref="edit_firewall_firewallsettings_compiler.png" />
        </figure>

	</sect4>

	<sect4 id="rule-set-objects">
	  <title>Editing Rule Set Objects</title>

	    <para>Firewalls can have one or more of the of the following types of rule sets: access policy, NAT, and Routing. A firewall has, by default, one access policy rule set, one NAT rule set, and one routing rule set. However, you can add additional rule sets if you like.</para>

	    <para>Rule sets are child objects of the a firewall object. They cannot stand alone.</para>

	    <para>As objects, rule sets have parameters. In Firewall Builder, rule sets have the following parameters:</para>

      <itemizedlist>
	<listitem><para><guilabel>Name</guilabel>: The name of the rule set. If you only have one of each type of rule set, you can leave this at its default.
	</para></listitem>
	<listitem><para><guilabel>Rule Set family</guilabel>: This pull-down menu lets you specify whether policy compiler should treat the rule set as an IPv4 rule set, an IPv6 rule set, or a combined rule set. If set to IPv4, then only IPv4 rules will be processed and IPv6 rules will be ignored. The opposite is true if you specify an IPv6 rule set. If you select <guimenuitem>This is combined IPv4 and IPv6 rule set</guimenuitem>, then the compiler will process both types of rules and place them into the appropriate places in the install script.
	</para></listitem>
	<listitem><para><guilabel>filter+mangle table</guilabel> or <guilabel>mangle table</guilabel>: These radio buttons let you specify whether the rules will apply to the iptables filter table <emphasis>and</emphasis> mangle table, or just the mangle table. (These radio buttons only appear for access policy rule sets, and only for iptables.) Under most circumstances, the compiler places each rule into the correct table (filter or mangle) automatically. However some combinations of service objects and actions are ambiguous and can be used in both filter and mangle tables. In cases like these, you can clarify things for the compiler by creating a separate Policy ruleset that will be translated only into the mangle table.
	</para></listitem>
	<listitem><para><guilabel>Top ruleset</guilabel>: One of your rule sets must be the "top" rule set. The top ruleset is the one used by the firewall. Other rule sets of that type are used only if you branch to them using branching logic in the top rule set. (If you don't use branching, then only the rule set tagged as "top" is used.)
	</para></listitem>
	<listitem><para><guilabel>Comment</guilabel>: A free-form comment field.
	</para></listitem>
      </itemizedlist>

	    <figure float="1" id="rule-set-options1">
	      <title>Rule set options</title>
              <graphic scale="70" fileref="rule-set-options1.png" />
	    </figure>
	</sect4>
      </sect3>
    </sect2>

    <sect2 id="host-interface">
      <title>Interface Object</title>

      <figure float="1" id="host-interface1">
        <title>Interface Object</title>
            <graphic scale="70" fileref="host_example_1.png" />
      </figure>

      <para>Interface objects belong to firewall or host objects. Interface objects cannot exist alone.</para>

      <para>The dialog for the interface object that belongs to the firewall or host provides controls for the parameters described here. Controls that are only valid for the firewall, and not host objects, are marked as such.</para>

      <figure float="1" id="interface1">
        <title>Interface Object</title>
            <graphic scale="70" fileref="interface-1.png" />
      </figure>

      <itemizedlist>
	<listitem><para><guilabel>Name</guilabel>: The name of the interface object in Firewall Builder must match exactly the name of the interface of the firewall machine it represents. This will be something like "eth0", "eth1", "en0", "br0", and so on.
	</para></listitem>
	<listitem><para><guilabel>Label</guilabel>: On most OS's this field is not used and serves the purpose of a descriptive label. Firewall Builder GUI uses a label, if it is not blank, to show interfaces in the tree. One of the suggested uses for this field is to mark interfaces to reflect the network topology ('outside', 'inside') or the purpose ('web frontend' or 'backup subnet'). The label is mandatory for Cisco PIX though, where it must reflect the network topology.
	</para></listitem>
	<listitem><para><guilabel>Management interface</guilabel>: When a firewall has several network interfaces, one of them can be marked as the "management interface". The management interface is used for all communication between Firewall Builder and the firewall. For example, the built-in policy installer uses the address of the management interface to connect to the firewall via SSH when it copies a generated script or configuration file. (firewall object only)
	</para></listitem>
	<listitem><para><guilabel>External interface (insecure)</guilabel>: Marks an interface that connects to the Internet, or to an area that is outside the network protected by the firewall.  (firewall object only)
	</para></listitem>
	<listitem><para><guilabel>Unprotected interface</guilabel>: Marks interface to which Firewall Builder should not assign any access lists or firewall rules. Unprotected interfaces are recognized by policy compilers for Cisco IOS access lists and PF. Compiler for IOS ACL just skips unprotected interfaces and does not assign any ACL. The compiler for PF generates a "set skip on" clause for unprotected interfaces.  (firewall object only)
	</para></listitem>
	<listitem><para><guilabel>Regular Interface</guilabel>: Use this option if the interface has an IP address assigned to it manually (static IP address).
	</para></listitem>
	<listitem><para><guilabel>Address is assigned dynamically</guilabel>: Use this option if the interface has a dynamic address (obtained by means of DHCP or PPP or another protocol). In this case an address is unknown at the moment when Firewall Builder generates the Firewall policy. Some firewalls allow for using the interface name in the policy instead of its IP address; the firewall engine then picks an address either when the policy is activated or even at run-time. Some other firewalls support special syntax for rules that are supposed to match packets headed to or from the firewall machine. Examples of these two cases are OpenBSD PF and Netfilter. PF rules can be constructed using interface names; PF automatically uses the current interface address when it loads rules into the memory. Netfilter supports special "chains" called "INPUT" and "OUPUT" that are guaranteed to inspect only packets headed for the firewall machine ("INPUT") or originated on it ("OUTPUT"). Both methods allow Firewall Builder to build correct firewall policy rules that affect the interface with a dynamic IP address, however the interface must be marked as such for the policy compiler to use proper technique depending on the target firewall platform. In cases where the rule has to use actual IP address of the interface (example: anti-spoofing rules), compiler emulates this feature by adding shell script fragment to determine the address at the time when firewall script is executed and then uses the address in rules. Such emulation is only possible on platforms where firewall configuration is in the form of the shell script, most notably this is iptables script on Linux. 
	</para></listitem>
	<listitem><para><guilabel>Unnumbered interface</guilabel>: Use this option if the interface can never have an IP address, such as the Ethernet interface used to run PPPoE communication on some ADSL connections or a tunnel endpoint interface. Although an unnumbered interface does not have an address, firewall policy rules or access lists can be associated with it.
	</para></listitem>
	<listitem><para><guilabel>Bridge port</guilabel>: This option is used for a port of a bridged firewall. The compilers skip bridge ports when they pick interfaces to attach policy and NAT rules to. For target firewall platforms that support bridging and require special configuration parameters to match bridged packets, compilers use this attribute to generate a proper configuration. For example, in case of iptables, the compiler uses  <emphasis>-m physdev --physdev-in</emphasis> or  <emphasis>-m physdev --physdev-out</emphasis> for bridge port interfaces. (firewall object only)
	</para></listitem>
	<listitem><para><guilabel>Security level</guilabel>: Depending on the firewall platform, the security level is either <emphasis>External/Internal</emphasis> or a numeric value between 0
	and 100, with 0 being least secure and 100 being most secure. This field in the 
	GUI dialog automatically shows controls appropriate to the current firewall. Not all firewall support the concept of a security zone. (firewall object only)
	</para></listitem>
	<listitem><para><guilabel>Network zone</guilabel>: Used only with Cisco PIX (ASA). The Network zone drop-down list shows all network objects and groups of addresses and networks present in the tree. Choose one of them to tell the compiler which networks and blocks of addresses can be reached through this interface. Usually the external interface (the one
        that connects your firewall to the Internet) has the Network Zone set
        to <emphasis>Any</emphasis>. It is also recommended that you create a
        group of objects to represent Network Zones for all other interfaces on
        the firewall. The compiler uses this information to decide which interface each ACL rule should be associated with based on the addresses used in the destination of the rule. (firewall object only)
	</para></listitem> 
      </itemizedlist>

    <sect3 id="security-levels-and-network-zones">
      <title>More about Security Levels and Network Zones</title>

	<para>Consider the network layout as in <xref
        linkend="network-zones" />. </para>

        <figure float="1" id="network-zones">
          <title>Choosing Network Zones</title>
              <graphic scale="100" fileref="fwbuilder-using-netzone1.jpg" />
        </figure>

	<para>Here the firewall has three interfaces:
        'outside', 'dmz', and 'inside'. Behind the firewall there is a router
        which in turn is connected to three subnets: 'subnet A', 'subnet B',
        and 'subnet C'. Subnet A is shared between the router and the firewall
        (each device has an interface on this subnet). Let's suppose we have created Network objects for each subnet and called them
        'subnet DMZ', 'subnet A', 'subnet B' and 'subnet C' (remember, spaces
        are allowed in object names). For this setup, network zones should be
        configured as follows:</para>

        <para><informaltable frame="none">
            <tgroup cols="2">
              <colspec align="center" colwidth="64pt" />

              <colspec align="center" colwidth="150pt" />

              <thead>
                <row>
                  <entry>Interface</entry>

                  <entry>Network Zone</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><guilabel>outside</guilabel></entry>

                  <entry><emphasis>ANY</emphasis></entry>
                </row>

                <row>
                  <entry><guilabel>dmz</guilabel></entry>

                  <entry><emphasis>subnet DMZ</emphasis></entry>
                </row>

                <row>
                  <entry><guilabel>inside</guilabel></entry>

                  <entry><emphasis>subnet A,</emphasis> <emphasis>subnet
                  B,</emphasis> <emphasis>subnet C</emphasis></entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable></para>

        <para>Since the network zone for the <emphasis>'inside'</emphasis>
        interface consists of multiple objects, you must create a group so
        that you can use this group as a Network Zone object.</para>

        <para><xref linkend="platform-specific-interface-parameters" />
        explains the differences in the way firewall platforms interpret
        values in the Security Level and Network Zone parameters of the
        firewall interfaces.</para>

        <table id="platform-specific-interface-parameters" pgwide="0">
          <title>Platform-specific interface parameters</title>

          <tgroup cols="3">
            <thead>
              <row>
                <entry><para>Firewall Platform</para></entry>

                <entry><para>Security Level Values</para></entry>

                <entry><para>Network Zone</para></entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><para>iptables</para></entry>

                <entry><para>two values: 'External' or
                'Internal'</para></entry>

                <entry><para>N/A</para></entry>
              </row>

              <row>
                <entry><para>ipfilter</para></entry>

                <entry><para>two values: 'External' or
                'Internal'</para></entry>

                <entry><para>N/A</para></entry>
              </row>

              <row>
                <entry><para>pf</para></entry>

                <entry><para>two values: 'External' or
                'Internal'</para></entry>

                <entry><para>N/A</para></entry>
              </row>

              <row>
                <entry><para>Cisco PIX</para></entry>

                <entry><para>numeric, 0 - 100</para></entry>

                <entry><para>a reference to a group or network
                object</para></entry>
              </row>
            </tbody>
          </tgroup>
        </table>

	<para>Note that the "external" interface option may be deprecated in the future versions of the program.</para>

	<para>In PIX, access lists must always be attached to interfaces. The policy compiler for PIX uses information about the network zones of interfaces to decide which interface a rule should be associated with if its "Interface" column does not specify one (is left set to "All"). Instead of placing this rule in access lists attached to all interfaces, it compares addresses in the Source and Destination of the rule with network zones of interfaces and only uses interfaces that match. This helps generate a PIX configuration that is more compact.</para>
    </sect3>
    
    <sect3>
      <title>Using Interface Object in Rules</title>

      <para>Policy rules in Firewall Builder have a rule element called <guilabel>Interface</guilabel>. You can drag-and-drop, or copy/paste interface object into this column of a rule to make the firewall match not only the source and destination address and service, but also the interface of the firewall through which packets enter or exit. The direction of the packet is defined in column <guilabel>Direction</guilabel>. Consider the following example:</para>

      <figure float="1" id="rules_with_interface_1">
        <title>Rule using an Interface object</title>
            <graphic scale="70" fileref="rules_with_interface_1.png" />
      </figure>

      <para>Rule #0 is "anti-spoofing" rule which relies on the ability to define interface and direction. It matches packets with source addresses equal to the addresses of the firewall's interfaces or internal network, but that are coming in from outside, which is determined by comparing the interface through which packets enter the firewall. Packets with "internal" addresses cannot normally come from outside, and if they do, they must be spoofed and should be dropped. This is what this rule does: it drops and logs these packets. Rule #1 permits connections originating from the internal network going out, but it makes sure these packets enter the firewall through its internal interface.</para>

      <para>These two rules generate the following iptables script:</para>
      <screen>
# 
# Rule 0 (eth0)
# 
$IPTABLES -N In_RULE_0
$IPTABLES -A FORWARD  -i eth0  -s 192.0.2.1  -j In_RULE_0 
$IPTABLES -A FORWARD  -i eth0  -s 172.16.22.1  -j In_RULE_0 
$IPTABLES -A FORWARD  -i eth0  -s 192.168.2.1  -j In_RULE_0 
$IPTABLES -A FORWARD  -i eth0  -s 172.16.22.0/24  -j In_RULE_0 
$IPTABLES -A In_RULE_0  -j LOG  --log-level info --log-prefix "RULE 0 -- DENY "
$IPTABLES -A In_RULE_0  -j DROP 
# 
# Rule 1 (eth1)
# 
$IPTABLES -A FORWARD  -i eth1  -s 172.16.22.0/24  -m state --state NEW  -j ACCEPT 
      </screen>

    <para> Here all iptables commands have an "-i eth0"  or "-i eth1" clause, which makes iptables compare the interface and direction.</para>

     <para>Here is what we get if we compile the same rules for PF:</para>

      <screen>
# Tables: (1)
table &lt;tbl.r9999.d&gt; { 192.0.2.1 , 172.16.22.1 , 192.168.2.1 } 

# 
# Rule  0 (eth0)
# 
block in   log  quick on en0 inet  from &lt;tbl.r9999.d&gt;  to any
block in   log  quick on en0 inet  from 172.16.22.0/24  to any
# 
# Rule  1 (eth1)
# 
pass in   quick on en1 inet  from 172.16.22.0/24  to any keep state
# 
      </screen>

      <para> For PF, the compiler generated a "block in log quick on eth0" clause to make the rule match interface and direction.</para>

      <para>In the case of Cisco IOS access lists, defining an interface in the rule makes the compiler place code generated for this rule into the ACL attached to the given interface. The compiler for IOS ACL always generates both inbound and outbound access lists for each interface, but if the rule specifies both interface and direction ("Inbound" or "Outbound"), the generated configuration goes only into the corresponding access list. Here is the output produced for the rules shown above for Cisco IOS ACL:</para>

      <screen>
ip access-list extended inside_in
! Rule  1 (eth1)
! 
  permit ip 172.16.22.0 0.0.0.255 any  
exit

ip access-list extended outside_in
! Rule  0 (eth0)
! 
  deny   ip host 192.0.2.1 any  log 
  deny   ip host 192.168.2.1 any  log 
  deny   ip 172.16.22.0 0.0.0.255 any  log 
exit

interface FastEthernet1
  ip access-group inside_in in
exit
interface FastEthernet0
  ip access-group outside_in in
exit
      </screen>

      <para>So far, the examples in this section have demonstrated how to use Interface objects to associate policy rules with interfaces so as to match packets crossing certain interface. An interface object can be used in the "source" and "destination" of rules just like any other addressable object. In this case, Firewall Builder replaces the interface object with the set of its addresses, picking only those addresses that match the address family (IPv4 or IPv6 or both) assigned to the rule set.</para>

      <para>For example, we start with a firewall configuration where interface eth1 has two IP addresses, one IPv4 and another is IPv6. Note that this could be a host object as well because interfaces can belong either to a Firewall or a Host object.</para>

      <figure float="1" id="interface-2">
        <title>Interface object with both address families</title>
            <graphic scale="70" fileref="interface-2.png" />
      </figure>

      <para>Interface eth1 has IPv4 address 172.16.22.1 and IPv6 address fe80::21d:9ff:fe8b:8e94. It is used in a simple policy rule as follows:</para>

      <figure float="1" id="interface-rule-1">
        <title>Interface object in a rule</title>
            <graphic scale="70" fileref="interface-rule-1.png" />
      </figure>

      <para>This policy rule set is configured as a mixed IPv4+IPv6 rule set. For iptables, the compiler generates the following code:</para>

      <screen>
# ================ IPv4
# Rule 0 (global)
# 
$IPTABLES -A INPUT -p tcp -m tcp  -d 172.16.22.1  --dport 22  -m state \
 --state NEW  -j ACCEPT 

# ================ IPv6

# Rule 1 (global)
# 
$IP6TABLES -A INPUT -p tcp -m tcp  -d fe80::21d:9ff:fe8b:8e94  --dport 22 \
 -m state --state NEW  -j ACCEPT
      </screen>

      <para>For PF we get the following:</para>

      <screen>
# Rule  0 (global)
# 
# 
pass in   quick inet proto tcp  from any  to 172.16.22.1 port 22 keep state
pass out  quick inet proto tcp  from any  to 172.16.22.1 port 22 keep state

# Rule  0 (global)
# 
# 
pass in   quick inet6 proto tcp  from any  to fe80::21d:9ff:fe8b:8e94 port 22 \
keep state
pass out  quick inet6 proto tcp  from any  to fe80::21d:9ff:fe8b:8e94 port 22 \
keep state
      </screen>

      <para>Since the interface has two addresses, one IPv4 and another IPv6, the compiler generates commands in both the IPv4 and IPv6 sections of the script, but it uses only the appropriate address in each. Other than that, the interface object behaves just like a set of addresses when used in the source or destination element of a rule. It can also be used in NAT rules. Here is an example:</para>

      <figure float="1" id="interface-nat-rule-1">
        <title>IPv4 Address object assigned to an interface</title>
            <graphic scale="70" fileref="interface-nat-rule-1.png" />
      </figure>
    
      <para>This generates the following code for iptables:</para>

      <screen>
# Rule 0 (NAT)
# 
$IPTABLES -t nat -A POSTROUTING -o eth0  -s 172.16.22.0/24 -j SNAT \
--to-source 192.0.2.1 
# 
# Rule 1 (NAT)
# 
$IPTABLES -t nat -A PREROUTING  -p tcp -m tcp   -d 192.0.2.1 --dport 80 \
-j DNAT --to-destination 172.16.22.100 
       </screen>

		<para>And for PF:</para>
	<screen>
# Rule  0 (NAT)
# 
nat on eth0 proto {tcp udp icmp} from 172.16.22.0/24 to any -> 192.0.2.1 
# 
# Rule  1 (NAT)
# 
rdr on eth0 proto tcp from any to 192.0.2.1 port 80 -> 172.16.22.100 port 80 
        </screen>
    </sect3>

    <sect3>
      <title>Using Interface Object with Dynamic Address in Rules</title>

		<para>The examples above demonstrated what happens when an interface with one or several IP addresses is used in policy and NAT rules. Let's look at the case when an interface has an address assigned dynamically. This means the address is unknown to the Firewall Builder policy compiler when it generates the configuration script. The compiler uses features of the target firewall to work around this. Here is the configuration of the interface object eth0. The radio-button <guilabel>Address is assigned dynamically</guilabel> is selected.</para>

      <figure float="1" id="interface-3">
        <title>Interface with dynamic address</title>
            <graphic scale="60" fileref="interface-3.png" />
      </figure>

	<para>The following policy rule uses interface eth0  in destination:</para>

      <figure float="1" id="interface-rule-3">
        <title>Interface with dynamic address in a rule</title>
            <graphic scale="70" fileref="interface-rule-3.png" />
      </figure>

      <para> Here is what we get for iptables:</para>
      <screen>
getaddr eth0  i_eth0
getaddr6 eth0  i_eth0_v6

# ================ IPv4

# Rule 0 (global)
# 
test -n "$i_eth0" &amp;&amp; $IPTABLES -A INPUT -p tcp -m tcp  -d $i_eth0  --dport 22 \
  -m state --state NEW  -j ACCEPT 

# ================ IPv6

# Rule 0 (global)
# 
test -n "$i_eth0_v6" &amp;&amp; $IP6TABLES -A INPUT -p tcp -m tcp -d $i_eth0_v6  \
 --dport 22  -m state --state NEW  -j ACCEPT 
        </screen>

	<para>Shell functions "getaddr" and "getaddr6" are defined earlier in the script. The generated script determines IPv4 and IPv6 addresses of interface eth0 at the time of execution and then uses the values in iptables commands. If the interface does not have an address, the corresponding variable gets an empty string for its value and the iptables command using it is skipped.</para>

	<para>PF allows for using interface name in rules and gets its current IP address automatically. Here is what is generated for PF:</para>
	<screen>
# Rule  0 (global)
# 
pass in   quick inet proto tcp  from any  to (en0) port 22 keep state
pass out  quick inet proto tcp  from any  to (en0) port 22 keep state

# Rule  0 (global)
# 
pass in   quick inet6 proto tcp  from any  to (en0) port 22 keep state 
pass out  quick inet6 proto tcp  from any  to (en0) port 22 keep state
         </screen>    

	<para>We still get two separate parts for IPv4 and IPv6 because the rule set is configured as IPv4+IPv6 mix, but in both cases compiler just used the interface name because its actual IP address is dynamic and was unknown at the time the configuration was generated.</para>
    </sect3>
    
    <sect3>
      <title>Using Interface Object in Rules of Bridging iptables Firewall</title>

      <para>In case of the "normal" iptables firewall, Firewall Builder adds an "-i eth0" or "-o eth0" parameter to the generated iptables command to make it match interface and direction. If radio button <guilabel>Bridge port"</guilabel> is turned on in the interface object, the compiler uses a different option to make iptables match packets crossing bridge ports. Here is the interface "eth1" which is configured as a bridge port:</para>

      <figure float="1" id="bridge_interface_dialog_1">
        <title>Bridge interface</title>
            <graphic scale="60" fileref="bridge_interface_dialog_1.png" />
      </figure>

      <para>Consider the following rule in the policy of the firewall this interface belongs to:</para>

      <figure float="1" id="rules_with_interface_2">
        <title>Bridge interface in rule</title>
            <graphic scale="70" fileref="rules_with_interface_2.png" />
      </figure>

      <para> This rule matches interface "eth1" and generates the following iptables command:</para>
      <screen>
$IPTABLES -A FORWARD  -m physdev --physdev-in eth1  -s 172.16.22.0/24 \
 -d 172.16.22.255  -m state --state NEW  -j ACCEPT 
      </screen>

      <para>Since the interface is now a bridge port, the compiler uses "-m physdev --physdev-in eth1" to match it.</para>

    </sect3>
  </sect2>

    <sect2 id="address-object">
      <title>IPv4 Address Object</title>

      <para>The regular address object describes single a IPv4 address. It can be a child of an interface object, in which case it represents an IP address and netmask of the interface, or it can be used as a standalone object. In the latter case it does not have a netmask and is located in the Objects/Addresses branch of the objects tree.</para>

      <sect3>
	<title>IPv4 Address Object When Used as an Address of an Interface</title>

	  <para>In this case the object is a "child" or "leaf" under the an interface object, either on a Host or a Firewall object. To create this kind of an Address, right-click on the interface object to bring up the context menu.</para>

      <figure float="1" id="ipv4-address1">
        <title>IPv4 Address object assigned to an interface</title>
            <graphic scale="50" fileref="ipv4_1.png" />
      </figure>
      <para>Its dialog provides the following entry fields:</para>

      <para><itemizedlist spacing="compact">
          <listitem>
            <para>Name</para>

            <para>This is the name of the object. Use a descriptive name because when the address object is used
            in the firewall policy, it is labeled with this name. It may be
            hard to tell one address from another if their names are
            similar.</para>
          </listitem>

          <listitem>
            <para>Address</para>

            <para>This is an IP address. The GUI widget provides syntax control for the values entered in the
            field. (This syntax control activates when you save the object.)</para>

            <note>
              <para>A typical error is to interpret this object as an address
              of the subnet to which the interface of the host or firewall
              belongs. This object represents an address of the interface, not
              a network address. (So, 192.168.1.1, not 192.168.1.0)</para>
            </note>
          </listitem>

          <listitem>
            <para>Netmask</para>

            <para>This is a netmask assigned to the interface. You can enter the netmask using the traditional method (255.255.255.0) or using network bit length notation ("24"). Bit length notation is converted to a traditional netmask by Firewall Builder.</para>
          </listitem>

          <listitem>
            <para>DNS Lookup</para>

            <para>If the host object has the same name as the actual machine, then clicking this button generates a DNS query that populates the interface IP address and subnet. Only the parent host or firewall object's name is used for the DNS query; the name of the interface is ignored and can be anything.</para>
          </listitem>

          <listitem>
            <para>Comment</para>

            <para>This is free-form text field for a comment.</para>
          </listitem>
        </itemizedlist></para>

	<para>Here we use our IPv4 address in a rule (remember, it belongs to the interface):</para>

      <figure float="1" id="ipv4-address2">
        <title>IPv4 Address object assigned to an interface and used in a rule</title>
            <graphic scale="70" fileref="ipv4_1_rule_1.png" />
      </figure>

	<para>Firewall Builder's iptables compiler, for example, generates the following command from this rule:</para>

	<screen>$IPTABLES -A INPUT -p tcp -m tcp  -d 172.16.22.1  --dport 22  -m state \
	--state NEW  -j ACCEPT</screen>

	<para>Note how even though the Address object has a netmask, the generated command matches the address as a host address, not as a subnet. This is because the netmask is used only to describe the subnet for the interface, not to describe the subnet. When this address object is used in a rule, it is understood that the intention is to match the address of the interface it belongs to rather than any address on the subnet. Use the Network object if you need to match a whole subnet.</para>

	<para>This iptables rule was placed in the INPUT chain because the object in the "Destination" was an address of an interface of the firewall. While processing the policy for the iptables target firewall platform, Firewall Builder compares addresses in the source and destination of a rule to the addresses of all interfaces of the firewall to find rules that control access to and from the firewall. Firewall Builder places these rules into INPUT or OUTPUT chains. This is only necessary for iptables.</para>

      </sect3>
      <sect3>
	<title>IPv4 Address Object When Used as a Stand-alone Object</title>
	  <para>In this case the object is located in the <guimenuitem>Objects / Addresses</guimenuitem> part of the objects tree and does not have a netmask entry field. To create this kind of an Address, use the <guimenu>New Object</guimenu> menu to select <guimenuitem>New Address</guimenuitem> or use the right-click menu associated with the Addresses folder in the tree.</para>

      <figure float="1" id="ipv4-address3">
        <title>Stand-alone IPv4 Address object</title>
            <graphic scale="50" fileref="ipv4_2.png" />
      </figure>

	<para>Dialog fields <guilabel>Name</guilabel>, <guilabel>Address</guilabel>  and <guilabel>Comment</guilabel> have the same purpose and properties as an Address object assigned to an Interface object.</para>

	<para>The DNS Lookup button can be used to automatically populate the address field using a DNS query. The program runs DNS query for the "A" record with the name of the Address object. The object name does not have to match any DNS record if you never plan to use this feature. DNS query function is just a convenience, but to use it, the name of the object must match a DNS record.</para>

      </sect3>
    </sect2>

    <sect2 id="ipv6-address-object">
      <title>IPv6 Address Object</title>

	<para>The IPv6 address object is similar to the IPv4 address object. Like IPv4 address objects, it can be used both as a child of an interface object or as a stand-alone object.</para>

      <sect3>
	<title>IPv6 Address Object When Used as an Address of an Interface</title>

      <figure float="1" id="ipv6-address1">
        <title>IPv6 Address Object assigned to an Interface object</title>
            <graphic scale="60" fileref="ipv6_1.png" />
      </figure>

      <para>If it is used to describe an IPv6 address of an interface, it has a netmask represented as bit length. Unlike with IPv4 address object, an IPv6 netmask is never represented as a colon-separated string of octets.</para>
      </sect3>

      <sect3>
	<title>IPv6 Address Object When Used as Stand-alone Object</title>

      <figure float="1" id="ipv6-address2">
        <title>Stand-alone IPv6 Address Object</title>
            <graphic scale="60" fileref="ipv6_2.png" />
      </figure>

      <para>In this case this object is located in the <guimenuitem>Objects / Addresses</guimenuitem> part of the objects tree (the same place where stand-alone IPv4 addresses are located) and does not have a netmask entry field. To create this kind of an Address, use the <guimenu>New Object</guimenu> menu item <guimenuitem>New Address IPv6</guimenuitem> or the right-click menu associated with the Addresses folder in the tree.</para>

      <para>Policy compilers treat IPv6 addresses in policy rules according to the same algorithms as those for IPv4 rules. For example, just like with IPv4, the compiler for iptables checks if an address matches an address of any interface of the firewall to determine if the rule should be placed in the INPUT or OUTPUT chain.</para>

      <para>Consider the rule shown in the screenshot below where we use two IPv6 address objects. One object belongs to the interface inside of the firewall while another is the IPv6 address of the project's web site.</para>

      <figure float="1" id="ipv6-address3">
        <title>IPv6 Address objects in a rule</title>
            <graphic scale="70" fileref="ipv6_1_rule_1.png" />
      </figure>

      <para>For iptables, Firewall Builder generates the following commands from this rule:</para>

      <screen>
$IP6TABLES -A INPUT -p tcp -m tcp  -d fe80::21d:9ff:fe8b:8e94  --dport 80  \
-m state --state NEW  -j ACCEPT 
$IP6TABLES -A FORWARD -p tcp -m tcp  -d 2001:470:1f0e:162::2  --dport 80  \
-m state --state NEW  -j ACCEPT
      </screen>

      <para>The rule that matches the address described by <emphasis>object guardian-2:eth1:ipv6</emphasis> went to the INPUT chain because compiler detected that this rule matches packets that are headed for the firewall itself, which iptables inspects in the INPUT chain. The rule that matches the address described by the object <emphasis>ipv6.fwbuilder.org</emphasis>  went to the FORWARD chain because these packets go through the firewall.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Physical Address Object</title>

      <figure float="1" id="physAddress1">
        <title>The Physical Address Object</title>

            <graphic scale="60" fileref="physaddress1.png" />

      </figure>

      <para>The Physical Address object describes the hardware, or media, address of an interface. Currently only Ethernet MAC addresses are supported, but support for other kinds of physical addresses may be added in the future.</para>

      <para>The Physical Address object can only be a child of an interface; it cannot exist as a stand-alone object. To create this kind of address object, right-click on an Interface object in the tree, then select <guimenuitem>Add MAC Address</guimenuitem>. Only one Physical Address object is allowed per interface; the program enforces this restriction. If you create a Firewall or Host object using SNMP discovery, all interfaces will be automatically populated with their MAC addresses.</para>

      <para><itemizedlist spacing="compact">
          <listitem>
            <para>Name</para>

            <para>This is the name of the object. The field is populated automatically with a host:interface:addressType descriptive name when the object is created, but you can change it immediately or later. If you change the name, use something descriptive because when the address object is used in the firewall policy, it is labeled with this name. It may be hard to tell one address from another if their names are similar. </para>
          </listitem>

          <listitem>
            <para>Address</para>

            <para>This is a string representation of the physical or media
            address. For many types of media, this will be in a binary
            representation. For example, an Ethernet address would be
            represented as a string of 6 octets.</para>
          </listitem>

          <listitem>
            <para>Comment</para>

            <para>This is free-form text field for a comment.</para>
          </listitem>
        </itemizedlist></para>

      <sect3 id="using-mac-address">
        <title>Using The Physical Address Object in Policy Rules</title>

        <para>Only a few firewall platforms really support physical address
        filtering. Currently, Netfilter/iptables is the only firewall platform supported by Firewall Builder that can
        do physical address filtering.</para>

        <para>As described in <xref linkend="multiple-addresses" />, if an
        Interface object that has multiple child address 
        objects is used in a rule element (either
        <emphasis>Source</emphasis> or <emphasis>Destination</emphasis>), then
        the policy compiler tries to generate a rule using all of them. <xref
        linkend="multiple-addresses" /> explains that the compiler actually does
        this by generating multiple rules using each address in turn. This
        roughly corresponds to using the logical operation "OR" on the IP
        addresses: if our interface has two addresses,
        <emphasis>Address1</emphasis> and <emphasis>Address2</emphasis>, then
        the generated rule would match if the address in the packet is either
        <emphasis>Address1</emphasis> OR <emphasis>Address2</emphasis>. The
        case of a Physical Address is different though. If the Interface has a
        physical address, then the compiler builds a rule that has to match an IP address <emphasis>and</emphasis> the MAC address. The reason is to combat IP spoofing.</para>

        <para>Suppose we have a very important host on the network. We create
        a Host object, then add an interface to it. The interface should have
        both Address and Physical Address objects as shown in <xref
        linkend="host-with-addr-and-physaddr" />. The two child objects are visible in the tree under the Interface "eth0". </para>

        <figure float="1" id="host-with-addr-and-physaddr">
          <title>The Host object with Address and Physical Address</title>
              <graphic scale="60" fileref="using-physaddress-1.png" />
        </figure>

	<note><para>Note how <guilabel>MAC matching</guilabel> is checked in the Host object dialog. This makes the compiler use the MAC addresses of the interfaces of this host.</para></note>

        <para>Because this is a very important host, we would like to be sure that packets whose source IP is that of this host are really coming from it and are not spoofed. The best way to achieve this goal is to use strong authentication, for example with IPSEC protocol. Using IPSEC is outside the scope of this document though; our goal right now is to show that inspecting the MAC address of the packet can improve security. </para>

        <para>Both a real packet originated from this host and a spoofed packet have a source IP address of the interface of this host, but the source MAC address is going to be different if spoofing is going on. We can use this to catch and drop spoofed packets. Here are three possible ways to build security policy in this situation: </para>

        <para><itemizedlist>
            <listitem>
              <para>Using only Address object in the rule element. This means
              the firewall inspects only IP address and ignores the MAC
              address of the packets.</para>

              <figure float="1" id="only-addr">
                <title>Policy rule using only Address object</title>
		  <graphic scale="70" fileref="using-physaddress-4.png" />
              </figure>

	    <para> Firewall Builder generates the following simple iptables command for this rule:</para>
<screen>
$IPTABLES -A FORWARD  -s 10.3.14.44  -m state --state NEW  -j ACCEPT 
</screen>                
            </listitem>

            <listitem>
              <para>Using only Physical Address object. A rule built this way
              permits all kinds of traffic coming from the trusted host even
              if its IP address changes.</para>

              <figure float="1" id="only-phaddr">
                <title>Policy rule using only Physical Address object</title>
		  <graphic scale="70" fileref="using-physaddress-5.png" />
              </figure>

	      <para> For this rule, the following iptables command is generated:</para>
	      <screen>
$IPTABLES -A FORWARD  -m mac --mac-source 00:1D:09:8B:8E:94 -m state --state NEW \
-j ACCEPT 
              </screen>
            </listitem>

            <listitem>
              <para>Using Host or Interface object. This way we end up with a
              rule that matches on a <emphasis>combination</emphasis> of the
              IP address and MAC address. This may be used as a sophisticated
              anti-spoofing rule.</para>

              <figure float="1" id="using-host">
                <title>Policy rule using Host object</title>
		  <graphic scale="70" fileref="using-physaddress-6.png" />
              </figure>

              <figure float="1" id="using-interface">
                <title>Policy rule using Interface object</title>
		  <graphic scale="70" fileref="using-physaddress-3.png" />
              </figure>

	      <para> For this rule, the following iptables command is generated:</para>
	      <screen>
$IPTABLES -A FORWARD  -m mac --mac-source 00:1D:09:8B:8E:94 -s 10.3.14.44  -m state \
--state NEW  -j ACCEPT 
              </screen>
            </listitem>
          </itemizedlist></para>

        <para>Using Address and Physical Address objects in a rule is not the
        same as using the Host or Interface object to which these Address and
        Physical Address belong. Here is what happens if we put objects representing IP address and MAC address in the rule:</para>

        <figure float="1" id="addr-and-phaddr">
          <title>Policy rule using Address and Physical Address
          objects</title>
              <graphic scale="70" fileref="using-physaddress-7.png" />
        </figure>

	<para> For this rule, the following iptables commands are generated:</para>
	<screen>
$IPTABLES -A FORWARD  -s 10.3.14.44  -m state --state NEW  -j ACCEPT 
$IPTABLES -A FORWARD  -m mac --mac-source 00:1D:09:8B:8E:94 -m state --state NEW \
-j ACCEPT 
        </screen>  

	<para>As described in <xref
        linkend="multiple-addresses" />, using an multiple objects in the rule element is like bundling
        them together using logical operation <emphasis>OR</emphasis>. If we
        were to put Address and Physical Address in the rule like in <xref
        linkend="addr-and-phaddr" />, we would end up with a policy matching
        packets that have the source address 10.3.14.44 or MAC address
        00:1D:09:8B:8E:94, but not necessarily both at the same time. Any host
        that manages to pretend to have the IP address 10.3.14.44 would be able
        to send packets through our firewall even if its MAC address is
        different. To achieve our goal and make sure packets with the source
        10.3.14.44 really belong to our important host, we should be checking
        its IP address and MAC address at the same time and let a packet
        through only if its IP address <emphasis>AND</emphasis> MAC address
        are what we expect them to be. That is why Firewall Builder treats
        physical addresses differently and generates firewall code that
        inspects both IP address and physical address.</para>

        <para>Firewall Builder generates firewall code to inspect MAC address
        only for Host objects with the option <guilabel>MAC address filtering</guilabel> turned
        on. If this option is off, the Physical Address object will be ignored
        even if it is present in the Host object's Interface. This is because
        Host objects created using the Network Discovery Druid ( <xref
        linkend="network-discovery" /> ) are often populated with both IP
        address and MAC address information (available through SNMP
        query), but inspection of MAC addresses is rarely needed. Use the <guilabel>MAC address filtering</guilabel> option in the Host
        object to specify that you want the MAC address to be verified for the host.</para>

	<note><para>The target firewall imposes certain restrictions on rules matching the MAC address. For example, only source MAC addresses can be matched. Firewall Builder is aware of these restrictions, and the policy compiler will issue an error if a Physical Address object is used in a rule that would lead to an impossible iptables command.</para></note>
      </sect3>
    </sect2>

    <sect2>
      <title>Host Object</title>

      <para>The Host object in Firewall Builder is designed to represent real
      hosts in the network: workstations, servers, and any other network node
      with an address. Just like real hosts, Host objects have interfaces that represent different physical connections to the network. </para>

      <para>Most hosts have just a single (visible) interface with a single
      IP address. In that case the actual interface and its name do not
      matter. For most foreign hosts, Firewall Builder assigns an arbitrary name, like 
      <quote>interface1</quote>, to the host's interface. However, by using the tree-like
      hierarchy of hosts -&gt; interfaces -&gt; addresses, it is possible
      to specify the exact address and/or interface of a host in cases where it does matter.</para>

      <para>As in the Firewall object, interfaces and addresses are represented
      by objects that are organized in a tree. An interface can have multiple addresses. An example of a host with one interface and multiple addresses
      is shown in <xref linkend="host-in-tree" />. Host <quote>test
      server</quote> is located on the LAN and has three virtual IP addresses
      that all belong to the same interface, <quote>eth0</quote>.</para>

      <para>Note that in Firewall Builder, the host object is an abstraction. It does not have to conform to an individual host. This host object may in fact represent a web farm that
      accepts connections on three IP addresses, each on a different computer.
      </para>

      <figure float="1" id="host-in-tree">
        <title>A Host Object With One Interface And Multiple Virtual
        Addresses</title>
            <graphic scale="70" fileref="host_in_tree.png" />
      </figure>

      <note>
        <para>The host object cannot have any access, NAT or routing policy associated with it; only firewall objects
        can have policies.</para>
      </note>

    <sect3>
      <title>Creating a Host Object</title>

      <para>To speed up the process and make it simpler, creating a new host
      object is aided by a wizard that is similar to the one for creating a new Firewall Objects.</para>

      <para>To launch the wizard, select <guimenuitem>New Host</guimenuitem> from the <guimenu>New Object</guimenu> menu or right-click on <guimenuitem>Hosts</guimenuitem> and select it from there.</para>

      <para><xref linkend="firewall-object" /> shows how to use the Firewall object wizard. The Host object wizard is the same, with the following exceptions:</para>

      <itemizedlist spacing="compact">
          <listitem>
            <para>All methods</para>

            <para>You do not specify the operating system or platform for host objects.</para>
          </listitem>

          <listitem>
            <para>From template</para>

            <para>The Host object templates are different than those for Firewall objects. Browse through the list in Firewall Builder to see what's available.</para>
          </listitem>

          <listitem>
            <para>Manually</para>

            <para>This method works the same as for the Firewall object, though the <guilabel>Add Interfaces</guilabel> page is slightly different. You cannot tag an interface as a "bridge port" interface. You can, however, indicate it is unnumbered or dynamic by selecting the appropriate checkbox. If neither checkbox is selected, then the interface is assumed to have a static IP address. As with the Firewall object wizard, you can only add IPv4 addresses in this way. If you need to use IPv6 addresses, create the host object without IP addresses and add them later.</para>
          </listitem>

          <listitem>
            <para>Via SNMP</para>

            <para>This method works the same as for a Firewall object. The Host object must have the same name as the actual device and the host must respond to SNMP.</para>
          </listitem>
        </itemizedlist>

      <note>
        <para>You can always add, modify and remove interfaces of the new host
        object later using controls provided in the main window and object
        tree view.</para>
      </note>
    </sect3>

    <sect3>
      <title>Editing a Host Object</title>

      <figure float="1" id="host-dialog1">
        <title>Editing The Host Object</title>
            <graphic scale="60" fileref="host_dialog1.png" />
      </figure>

      <para>The Host object dialog allows you to edit the following parameters:</para>

      <para><itemizedlist spacing="compact">
          <listitem>
            <para>Name:</para>

            <para>The Host object name.</para>
          </listitem>

          <listitem>
            <para>MAC matching:</para>

            <para>If this option is activated, the policy compiler uses the
            MAC addresses of all interfaces of this host in the firewall
            rules. Not all firewall platforms support MAC address filtering,
            so this option may have no effect on the generated firewall
            script. This is treated as a non-critical situation, and the
            policy compiler will only generate a warning while processing a
            firewall policy where such a host is used. You cannot enter the physical (MAC) address in this dialog, however. See <xref
            linkend="using-mac-address" />.</para>
          </listitem>

          <listitem>
            <para>Comment:</para>

            <para>This is a free-form text field which can be used to add
            comments.</para>
          </listitem>
        </itemizedlist></para>
      </sect3>
      
      <sect3>
	<title>Using a Host Object in Rules</title>

	<para>When a Host object is used in a rule, it acts as a group of all of the addresses that belong to all of its interfaces. The only exception is the loopback interface; the compiler skips that address when replacing the Host object with its addresses.</para>

	<para>Consider the following Host object. It has interface eth0 with two IP addresses and a MAC address, interface he-ipv6 with an IPv6 address and a MAC address, interface lo (loopback) with its own IP address and interface sit0 (tunnel) with no address.</para>

      <figure float="1" id="host_example_1">
        <title>Host with multiple interfaces, some with multiple addresses</title>
            <graphic scale="70" fileref="host_example_1.png" />
      </figure>

      <para>Let's put this host object in a rule as follows:</para>

      <figure float="1" id="host_example_2">
        <title>Host in a rule</title>
            <graphic scale="70" fileref="host_example_2.png" />
      </figure>

      <para>The rule set is configured as "IPv4 only", so even though interface he-ipv6 has IPv6 address, Firewall Builder will ignore it while generating iptables commands for this rule. Interface eth0 has two IPv4 addresses and both will be used. Here are iptables commands generated for this rule:</para>

      <screen>
$IPTABLES -A FORWARD -p tcp -m tcp  --dport 22  -m state --state NEW \
-j Cid6066X5981.1 
$IPTABLES -A Cid6066X5981.1  -d 10.3.14.44  -j ACCEPT 
$IPTABLES -A Cid6066X5981.1  -d 10.3.14.55  -j ACCEPT 
$IPTABLES -A Cid6066X5981.1  -d  -j ACCEPT 
      </screen>

      <para>Let's see what we get for the same rule if we configure rule set object as "IPv4+IPv6":</para>

      <figure float="1" id="host_example_3">
        <title>Host in a rule with both IPv4 and IPv6</title>
            <graphic scale="70" fileref="host_example_3.png" />
      </figure>

      <para>Since the rule is now configured to compile for both address families, Firewall Builder processes it twice, once for each address family. Here is what we get (these are relevant fragments of the generated script):</para>

      <screen>
# ================ IPv4

$IPTABLES -A FORWARD -p tcp -m tcp  --dport 22  -m state --state NEW  \
-j Cid6066X5981.1 
$IPTABLES -A Cid6066X5981.1  -d 10.3.14.44  -j ACCEPT 
$IPTABLES -A Cid6066X5981.1  -d 10.3.14.55  -j ACCEPT 
$IPTABLES -A Cid6066X5981.1  -d  -j ACCEPT 

# ================ IPv6

$IP6TABLES -A FORWARD -p tcp -m tcp  --dport 22  -m state --state NEW  \
-j Cid6066X5981.1 
$IP6TABLES -A Cid6066X5981.1  -d fe80::a3:e2c  -j ACCEPT 
     </screen>
      </sect3>

        <sect3 id="multiple-addresses">
      <title>Using Objects With Multiple Addresses in the Policy and NAT
      rules</title>

      <para>Host and Firewall objects have child Interface
      objects, which in turn have child Address and Physical Address objects. In fact, an interface object can have more than one associated address object. Let's see how this works:</para>

      <figure float="1" id="multiple-addresses-obj1">
        <title>Host object with an interface that has multiple
        addresses</title>
            <graphic scale="70" fileref="multiple-addresses-obj1.png" />
      </figure>

      <figure float="1" id="multiple-addresses1">
        <title>Using objects with multiple addresses in policy
        rules</title>
            <graphic scale="70" fileref="multiple-addresses-rule1.png" />
      </figure>

      <para>Consider example <xref linkend="multiple-addresses-obj1" />, <xref
      linkend="multiple-addresses1" />. Here interface
      <emphasis>eth0</emphasis> of "test
      server" has three IP addresses (named "test
      server:eth0:0" through "test
      server:eth0:2") and interface <emphasis>eth0</emphasis> of
       "dmz host" has only one IP address:
      "dmz host:eth0". Policy rule #9 says that
      "dmz host" can talk to "test
      server" using any protocol. Since "test
      server" has three different addresses, we need to generate
      policy a rule that will match any of them. (Obviously we cannot match all three at
      once, so the compiler uses a logical "OR", not a logical 
      "AND" here.) Basically, rule #9 is equivalent to three separate rules,
      each of them using one address of "test server" in
      turn. These three rules are represented in <xref
      linkend="multiple-addresses2" /> (original rule #9 also shown there, but
      it is disabled.)</para>

      <figure float="1" id="multiple-addresses2">
        <title>Equivalent rules</title>
            <graphic scale="60" fileref="multiple-addresses-rule2.png" />
      </figure>

      <para>Firewall Builder takes care of this situation automatically and
      generates the firewall policy described in <xref
      linkend="multiple-addresses1" /> as if a user had built a policy in the
      GUI using the three rules as shown in <xref
      linkend="multiple-addresses2" />.</para>

      <para>In fact, the algorithm used is even more general. In the
      example <xref linkend="multiple-addresses1" />, host "test
      server" has a single interface with multiple addresses that the 
      compiler used to generate the target firewall code. The policy compiler
      works in a similar way even if the host or firewall object used in the rule
      has multiple interfaces and each interface, in turn, has multiple
      addresses. If a host (or firewall) object is used in the rule, then the
      compiler scans all its interfaces, finds all corresponding addresses, and
      uses them to generate the firewall configuration. If an interface object is
      used in the rule, then the compiler uses all its addresses. And finally,
      if an Address or Physical Address object is used in the rule, then the compiler
      uses only this parameter to generate the firewall configuration.
      In other words, the compiler always traverses the tree, starting from the
      object found in the policy rule, and uses the parameters of all Address and
      Physical Address objects it finds. Since Address and Physical Address
      objects are the leaf nodes in the tree and have no other objects beneath
      them, the compiler uses the parameters of these objects to
      generate the target code.</para>

      <note>
        <para>There is an exception to this algorithm, see <xref
        linkend="using-mac-address" /></para>
      </note>
    </sect3>
    </sect2>

    <sect2>
      <title>IPv4 Network Object</title>

      <figure float="1" id="network-dialog1">
        <title>The Network Object</title>
            <graphic scale="60" fileref="network_dialog1.png" />
      </figure>

      <para>The network object describes an IP network or subnet. Use main menu <guimenuitem>Net Object / New Network</guimenuitem>  item to create objects of this type. The dialog of the Network object provides the following entry fields: </para>

      <para><itemizedlist spacing="compact">
          <listitem>
            <para>Name:</para>

            <para>Network object name</para>
          </listitem>

          <listitem>
            <para>Address:</para>

            <para>The IPv4 address of the network.</para>
          </listitem>

          <listitem>
            <para>Netmask:</para>

            <para>The Netmask, in combination with an Address, defines the subnet. You can enter either string octet representation of the mask or its bit length here, however the program always converts it to the octet representation. Netmask in the network object is always entered in the "natural" way, such as "255.255.255.0", even if the object is going to be used to build Cisco IOS access lists which require reversed "bit mask" presentation instead (e.g "0.0.0.255" for the netmask above). Firewall Builder policy compiler takes care of the conversion automatically. </para>
          </listitem>

          <listitem>
            <para>Comment:</para>

            <para>This is a free-form text field used for comments</para>
          </listitem>
        </itemizedlist></para>

	<para>Let's use the Network object shown above in a policy rule compiled for different target platforms.</para>

      <figure float="1" id="network_example_1">
        <title>IPv4 Network object used in a rule</title>
            <graphic scale="70" fileref="network_example_1.png" />
      </figure>

	<para> Here is what we get for iptables:</para>
<screen>
$IPTABLES -A FORWARD -p tcp -m tcp  -s 172.16.22.0/24  --dport 80  -m state \
--state NEW  -j ACCEPT 
</screen>

	 <para>Here is the output produced for PF:</para>
<screen>
pass in   quick inet proto tcp  from 172.16.22.0/24  to any port 80 keep state
pass out  quick inet proto tcp  from 172.16.22.0/24  to any port 80 keep state
</screen>          

	  <para>Here is how the output looks like when the rule is compiled into Cisco IOS access-lists (this is one of the generated access lists):</para>
<screen>
ip access-list extended outside_out
  permit tcp 172.16.22.0 0.0.0.255 any  eq 80 
exit
</screen>          

	  <para>Here is what we get when the rule is compiled into Cisco ASA (PIX) configuration. Note how the compiler uses netmask 255.255.255.0 for PIX, while for IOS it was converted to 0.0.0.255. Also, interface "inside" was configured with network zone 172.16.0.0/12, which matched network object used in the source element of the rule. Because of that, the compiler put the rule only into the access list attached to interface "inside".</para>
<screen>
access-list inside_acl_in permit tcp 172.16.22.0 255.255.255.0 any eq 80 
access-group inside_acl_in in interface inside
</screen>          

    </sect2>

    <sect2>
      <title>IPv6 Network Object</title>

      <figure float="1" id="ipv6-network-dialog1">
        <title>IPv6 Network Object</title>
            <graphic scale="60" fileref="ipv6-network_dialog1.png" />
      </figure>

      <para> The network object describes an IPv6 network or subnet. This object is very similar to the IPv4 Network object, except you can only enter netmask as a bit length. Use main menu "Net Object / New Network IPv6" item to create objects of this type.</para>

      <para>Let's see what we get if we use an IPv6 Network object in a policy rule as shown:</para>

      <figure float="1" id="ipv6_network_example_1">
        <title>IPv6 Network object used in a rule</title>
            <graphic scale="70" fileref="ipv6_network_example_1.png" />
      </figure>

      <para> Here is the command generated for iptables:</para>
<screen>
$IP6TABLES -A FORWARD -p tcp -m tcp  -s 2001:470:1f0e:162::/64  --dport 80  \
-m state --state NEW  -j ACCEPT 
</screen>

      <para>Here is what we get for PF:</para>
<screen>
pass in   quick inet6 proto tcp  from 2001:470:1f0e:162::/64  to any port 80 keep state
pass out  quick inet6 proto tcp  from 2001:470:1f0e:162::/64  to any port 80 keep state
</screen>          

      <para>Here is the output for Cisco IOS access lists (only one ACL is shown):</para>
<screen>
ipv6 access-list ipv6_outside_out
  permit tcp 2001:470:1f0e:162::/64 any  eq 80 
exit

interface eth0
  ipv6 traffic-filter ipv6_outside_out out
exit
</screen>             

      <para>There is no IPv6 support for Cisco ASA (PIX) in Firewall Builder at this time.</para>

    </sect2>

    <sect2>
      <title>Address Range Object</title>

      <figure float="1" id="address_range_1">
        <title>The Address Range Object</title>
            <graphic scale="60" fileref="address_range_1.png" />
      </figure>

      <para>The Address Range object describes a continuous range of IPv4
      addresses. (Arbitrary address ranges are unsupported for IPv6.) To create new Address Range object, use main menu <guimenuitem>New Object / New Address Range</guimenuitem>. Its dialog provides the following entry fields:</para>

      <para><itemizedlist spacing="compact">
          <listitem>
            <para>Name:</para>

            <para>The name of the Address Range object</para>
          </listitem>

          <listitem>
            <para>Range start:</para>

            <para>The address of the start of the range</para>
          </listitem>

          <listitem>
            <para>Range end:</para>

            <para>The address of the end of the range</para>
          </listitem>

          <listitem>
            <para>Comment:</para>

            <para>A free-form text field used for comments</para>
          </listitem>
        </itemizedlist></para>

      <para>The Address range is inclusive, that is, both the start and the
      end addresses are included in the range.</para>

      <para> When Address Range object is used in a rule, Firewall Builder replaces it with a list of addresses equivalent to the specified range. The program tries to generate the most economical representation of the range using a combination of subnets of different lengths. Consider the Address Range object shown above. This Address Range object represents IP addresses between 192.168.1.100  and 192.168.1.160 (inclusively). It would be wasteful to generate 61 iptables commands to represent this range. Instead, the compiler uses a combination of several subnets of different lengths and ends up with the following:</para>
<screen>
$IPTABLES -A FORWARD  -s 192.168.1.100/30  -m state --state NEW  -j ACCEPT 
$IPTABLES -A FORWARD  -s 192.168.1.104/29  -m state --state NEW  -j ACCEPT 
$IPTABLES -A FORWARD  -s 192.168.1.112/28  -m state --state NEW  -j ACCEPT 
$IPTABLES -A FORWARD  -s 192.168.1.128/27  -m state --state NEW  -j ACCEPT 
$IPTABLES -A FORWARD  -s 192.168.1.160  -m state --state NEW  -j ACCEPT 
</screen>        

      <para>Here is how the generated configuration looks for PF (this is essentially the same, except it uses tables for brevity):</para>
<screen>
table &lt;tbl.r0.s&gt; { 192.168.1.100/30 , 192.168.1.104/29 , 192.168.1.112/28 , \
192.168.1.128/27 , 192.168.1.160 } 

pass in   quick inet  from &lt;tbl.r0.s&gt;  to any keep state
</screen>

      <para>Just for completeness, let's look at the configuration generated for the same rule for Cisco IOS access lists. This is really just a fragment of the generate router access list configuration because generated ACLs are attached to interfaces and, since the rule in the example was not associated with any interfaces, it got attached to all of them. Here we show only one generated ACL:</para>
<screen>
ip access-list extended inside_in
! 
! Rule  0 (global)
! 
! 
  permit ip 192.168.1.100 0.0.0.3 any  
  permit ip 192.168.1.104 0.0.0.7 any  
  permit ip 192.168.1.112 0.0.0.15 any  
  permit ip 192.168.1.128 0.0.0.31 any  
  permit ip host 192.168.1.160 any  
exit
</screen>
    </sect2>



    <sect2>
      <title>Address Tables Object</title>
      <para>Sometimes you need to apply a rule to a set of addresses, but you don't know what those addresses will be when you're writing the policy. The <guilabel>Address Table</guilabel> object can help.</para>

      <figure float="1" id="address-table-dialog1">
        <title>The Address Table Object</title>
            <graphic scale="70" fileref="address_table_2.png" />
      </figure>

      <para>The <guilabel>Address Table</guilabel> object has the following fields:</para>

<itemizedlist spacing="compact">
          <listitem>
            <para>Name:</para>

            <para>The name of the Address Table object</para>
          </listitem>

          <listitem>
            <para>Compile Time / Run Time:</para>

            <para>Indicate whether you want the file to be loaded with the firewall compiler runs (Compile Time) or when the firewall runs the firewall script (Run Time). </para>
          </listitem>

          <listitem>
            <para>File name:</para>

            <para>The name of the text file you want to load. (The file contains IP addresses or IP address ranges.) The filename can have any extension. If you want the file to load at run time, you must specify the path and name where the file will be on the <emphasis>firewall</emphasis> machine, not the client machine.</para>
          </listitem>

          <listitem>
            <para>Browse button:</para>

            <para>Used to populate the file name and path if the file is on the local machine.</para>
          </listitem>

          <listitem>
            <para>Preview button:</para>

            <para>Once the File name field is populated, use this button to view the file.</para>
          </listitem>

          <listitem>
            <para>Comment:</para>

            <para>A free-form text field used for comments</para>
          </listitem>
        </itemizedlist>

	<para>The <guilabel>Compile Time</guilabel> and <guilabel>Run Time</guilabel> radio buttons define when the addresses will be read from the file: when the firewall script is generated by Firewall Builder or when the firewall runs the script. If object is configured as <guilabel>Compile Time</guilabel>, the Firewall Builder policy compiler opens the file during compilation and replaces the <guilabel>Address Table</guilabel> object in policy rules with the set of addresses from the file. This means the file with addresses must be accessible on the machine where the Firewall Builder GUI and policy compilers run. If the object is configured as <guilabel>Run Time</guilabel>, policy compiler does not try to find and open the file but instead generates a firewall script that will do this when it is activated. This means the file with addresses must be located where it is accessible by the firewall, and the object must be configured with the full path to it on the firewall.</para>

	<para>Here is an example of the file contents (this is what you see if you click "Preview" button in the object dialog):</para>

      <figure float="1" id="address-table-textfile">
        <title>Address Table text file</title>
            <graphic scale="70" fileref="address_table_4.png" />
      </figure>

      <para>Note that comments in the file can start with '#' or ';', that a comment can follow an address on the same line or take the whole line and that lines can start with white space for formatting. This example file contains both IPv4 and IPv6 addresses for illustration purposes.</para>

      <para>Compile-time Address Table objects are supported on all target firewall platforms because addresses are read by the compiler. The compiler then generates normal configuration lines or script commands. Run time Address Table objects require special support from the target firewall and therefore supported only on some of them. Currently Run Time Address Table objects can be used in rules for iptables and PF firewalls.</para>

      <para>Let's look at the firewall script generated by Firewall Builder for the iptables and PF when the Address Table object used in the policy rule is configured first as "Compile Time" and then as "Run Time". The rule is very simple and looks like (<xref linkend="address-table-rule" />):</para> 

      <figure float="1" id="address-table-rule">
        <title>Rule using an Address Object</title>
            <graphic scale="70" fileref="address_table_3.png" />
      </figure>

      <para>This rule, with the object set to <guilabel>Compile Time</guilabel>, generates the following output:</para>

      <figure float="1" id="address-table-compile-iptables">
        <title>Compile Time, iptables compile output</title>
            <screen>
# Rule 0 (global)
# 
$IPTABLES -A INPUT  -d 192.168.1.1  -j DROP 
$IPTABLES -A FORWARD  -d 192.168.1.2  -j DROP 
$IPTABLES -A FORWARD  -d 192.168.1.3/30  -j DROP 
$IPTABLES -A FORWARD  -d 192.168.2.128/25  -j DROP 
$IPTABLES -A FORWARD  -d 192.168.1.200  -j DROP 
$IPTABLES -A FORWARD  -d 192.168.1.201  -j DROP 
</screen>
      </figure>

      <para>The compiler replaced object <guilabel>address_table_1</guilabel> in the Destination with addresses it took from the file. Option <guilabel>assume firewall is part of any</guilabel> was turned off in the firewall object settings, which is why compiler did not generate rules in the OUTPUT chain. However one of the addresses in the file matched the address of one of the interfaces of the firewall (192.168.1.1) and the corresponding rule went into the INPUT chain. Other addresses were copied from the file verbatim, including netmask specifications. The Policy object of this firewall was configured as "IPv4 rule set", because of this the compiler dropped the IPv6 addresses it found in the file. If the rule set was configured as a mix of IPv4 and IPv6, compiler would use IPv4 addresses in IPv4 rules and IPv6 addresses in IPv6 rules.</para>

      <figure float="1" id="address-table-compile-pf">
        <title>Compile Time, PF compile output</title>
            <screen>
# Tables: (1)
table  { 192.168.1.1 , 192.168.1.2 , 192.168.1.3/30 , 192.168.2.128/25 , \
192.168.1.200 , 192.168.1.201 }

# Rule  0 (global)
# 
block in   quick inet  from any  to &lt;tbl.r0.d&gt;
block out  quick inet  from any  to &lt;tbl.r0.d&gt;

</screen>
      </figure>

      <para>The output for PF is simple because Firewall Builder can use the built-in table facility. All addresses are copied from the file verbatim into the table tbl.r0.d.</para>

      <figure float="1" id="address-table-run-iptables">
        <title>Run Time, iptables compile output</title>
            <screen>
# Using 1 address table files
check_file "address_table_1" "/home/vadim/addr-table-1.tbl"

# Rule 0 (global)
# 
grep -Ev '^#|^;|^\s*$' /home/vadim/addr-table-1.tbl | while read L ; do
  set $L; at_address_table_1=$1; $IPTABLES -A FORWARD  -d $at_address_table_1  -j DROP 
done
</screen>
      </figure>

      <para> First, the generated script checks if the file specified in the Address Table object exists on the firewall machine. If the file is not found, the script aborts execution to avoid loading incomplete iptables rules. However, the script cannot verify that the file is the one you intended it to be, it just assumes that if the file with this name exists it is the right one and tries to interpret it as a list of IP addresses, with one address per line. Then the script reads the file line by line, skipping comments, and assigns IP addresses to the shell variable at_address_table_1, which it then uses in the iptables command.</para>

      <para>Since the compiler did not see the addresses from the file, it could not detect that one of them matched an address of the firewall and all iptables commands went to the FORWARD chain. The file /home/vadim/addr-table-1.tbl should be located on the firewall where the generated iptables script will be executed so the script can find it.</para>

      <para>Here is what you get if the option <guilabel>Assume firewall is part of any"</guilabel> is turned on in the firewall object settings:</para>

      <figure float="1" id="address-table-run-iptables-assume">
        <title>Run Time, iptables compile output, assume firewall is part of "any"</title>
            <screen>
# Rule 0 (global)
# 
grep -Ev '^#|^;|^\s*$' /home/vadim/addr-table-1.tbl | while read L ; do
  set $L; at_address_table_1=$1; $IPTABLES -A OUTPUT  -d $at_address_table_1  -j DROP 
done
grep -Ev '^#|^;|^\s*$' /home/vadim/addr-table-1.tbl | while read L ; do
  set $L; at_address_table_1=$1; $IPTABLES -A FORWARD  -d $at_address_table_1  -j DROP 
done
</screen>
      </figure>

      <para>The difference is that compiler generated two sets of commands, one in chain OUTPUT and another in chain FORWARD. The original rule has "any" in source, and if option <guilabel>Assume firewall is part of any</guilabel> is turned on, the compiler assumes the source of the rule can have either an unknown address or the firewall. The former makes it generate iptables command in the FORWARD chain and the latter makes it generate iptables command in the OUTPUT chain. This logic is not specific to the Address Table object type; the compiler does this regardless of the type of the object used in destination if source is "any" and option <guilabel>Assume firewall is part of any</guilabel> is turned on.</para>

      <figure float="1" id="address-table-run-pf">
        <title>Run Time, PF compile output</title>
            <screen>
# Tables: (1)
table  persist file "/home/vadim/addr-table-1.tbl"
# Rule  0 (global)
# 
# 
block in   quick inet  from any  to &lt;address_table_1&gt;
block out  quick inet  from any  to &lt;address_table_1&gt;
</screen>
      </figure>

      <para>PF is even easier in the case of run time address tables. Compiler just uses <emphasis>table</emphasis> facility with <emphasis>persist</emphasis> and <emphasis>file</emphasis> options to direct pfctl to open the file and read its contents. In this case the file should follow formatting requirements of PF.</para>

      <para>Policy compiler for PF treats Address Table objects with empty file name specially. It just generates the line "table &lt;table_name&gt;" at the beginning of the .conf file with no file specification. This table will not be populated when .conf file is loaded and therefore will remain empty, but it can be used in the rules.</para>

      <para>Addresses can be added to the table later using external scripts that call pfctl like this:</para>

            <screen>
pfctl -t bad_hosts -T add 192.0.2.1
</screen>

      <para>Another interesting possibility is to automatically populate the table if option "overload" is used in combination with other rate limiting options on a rule. Taking an example from the man page for pf.conf, here is how it looks:</para>

            <screen>
block quick from &lt;bad_hosts&gt;
pass in on $ext_if proto tcp to $webserver port www keep state \
                   (max-src-conn-rate 100/10, overload &lt;bad_hosts&gt; flush global)
</screen>

      <para>The idea behind these rules is that if some host tries to connect to the web server too often&mdash;more often than is allowed by max-src-conn-rate 100/10&mdash;its address will be added to the table &lt;bad_hosts&gt; by PF. The next time this host tries to connect, the packet coming from it will be denied by the blocking rule right away.</para>

      <para>To implement these rules in Firewall Builder, you would create an Address Table object with name "bad_hosts" but a blank file name, configured to resolve at run time:</para>

      <figure float="1" id="address-table-bad-hosts">
        <title>Address Table Object bad_hosts</title>
            <graphic scale="70" fileref="address_table_5.png" />
      </figure>

      <para>Then, use this Address Table object in the source field of a policy rule with action "Deny". This is rule #0 in the screenshot below. Another rule, rule #1 in the screenshot, has action "Accept" and matches destination against address of the web server, protocol http, and has limiting options set up to restrict the number of connections and to turn <guilabel>overload table</guilabel> on, with the name of the overload table "bad_hosts" that matches the name of the Address Table object.</para>

      <figure float="1" id="address-table-bad-hosts-rules">
        <title>Address Table Object bad_hosts Rules</title>
            <graphic scale="60" fileref="address_table_6.png" />
      </figure>

      <para>These two rules, as shown on the screen shots, yield the following PF configuration that matches the one given in the man page:</para>

            <screen>
# Tables: (1)
table &lt;bad_hosts&gt; persist

# Rule  0 (global)
# 
block in   log  quick inet  from &lt;bad_hosts&gt;  to any 
# 
# Rule  1 (global)
# 
pass in   quick inet proto tcp  from any  to 192.168.1.1 port 80 \
   keep state  (  max-src-conn-rate 100/10, overload &lt;bad_hosts&lt; flush global ) 

</screen>

    </sect2>

    <sect2>
      <title>Special case addresses</title>

	<para>Policy compilers treat some addresses in policy rules in special ways, depending on the requirements of the target firewall platform. For example, the compiler for iptables checks if the address found in "Destination" or "Source" of a rule matches the address of any interface of the firewall to determine if the rule should be placed in INPUT or OUTPUT chain. The compiler for PIX uses the command ssh &lt;address&gt; &lt;netmask>&gt; inside when it detects such an address in the destination of a rule where the service is TCP Service object "SSH". There are other special cases as well.</para>

      <sect3>
	<title>Broadcast and Multicast Addresses, iptables Firewall</title>

	<para>One important special case is broadcast and multicast addresses. It is important to place rules in the correct chain in generated iptables script because even though these addresses are not equal to those of the firewall's interfaces, iptables processes packets with broadcast or multicast destination in the INPUT chain. Firewall Builder is aware of this and generates the correct iptables commands.</para>

	<para>In order to match broadcast or multicast addresses in the rules, we need to create objects to describe them. The choice of object type to describe broadcast or multicast address depends on whether this is just a single address, a range or a block. An Address object is good for defining a single address, Address Range is good for sets of consecutive addresses and Network object is good for describing a block. For example, you can use an Address object with address "255.255.255.255" to describe a broadcast. Address Range with addresses "224.0.0.5 - 224.0.0.6" would work well to describe two multicast groups used by OSPF. A Network object with address "224.0.0.0" and netmask "240.0.0.0" can be used to describe a whole multicast address block.</para>

	<para>Here are few examples:</para>

      <figure float="1" id="multicast_object_1">
        <title>Multicast object</title>
            <graphic scale="60" fileref="multicast_object_1.png" />
      </figure>

	<para>Object "all multicasts" is part of the Standard Objects library that comes with the program. It describes an entire address block allocated for multicasts. Consider a simple policy rule that permits all multicasts:</para>

      <figure float="1" id="multicast_rule_1">
        <title>Multicast rule</title>
            <graphic scale="70" fileref="multicast_rule_1.png" />
      </figure>

	<para>For iptables, this rule translates into the following script:</para>
<screen>
$IPTABLES -A INPUT  -d 224.0.0.0/4  -m state --state NEW  -j ACCEPT 
</screen>        

	 <para>The rule went into the INPUT chain because iptables processes multicast there.</para>

	  <para>Here is another example, this time it involves broadcast addresses. Interface "inside" of the test firewall has address 172.16.22.1 with netmask 255.255.255.0. This defines subnet 172.16.22.0/255.255.255.0 with broadcast address 172.16.22.255. We create an Address object with the name "net-172.16.22 broadcast" and address "172.16.22.255" and use it in the destination field of a policy rule. Another rule in the same example will match broadcast address "255.255.255.255"; an Address Range Object that defines this address is present in the Standard Objects library under the name "broadcast". Here are the rules:</para>

      <figure float="1" id="broadcast_rules_1">
        <title>Broadcast rules</title>
            <graphic scale="70" fileref="broadcast_rules_1.png" />
      </figure>

	  <para> these two rules translate into the following script for iptables:</para>
<screen>
# Rule 0 (global)
# 
$IPTABLES -A INPUT  -d 255.255.255.255  -m state --state NEW  -j ACCEPT 
# 
# Rule 1 (global)
# 
$IPTABLES -A INPUT  -d 172.16.22.255  -m state --state NEW  -j ACCEPT 
</screen>

	  <para>Both rules went into INPUT chain as expected.</para>
      </sect3>

      <sect3>
	<title>Broadcast and Multicast Addresses and Bridging iptables Firewall</title>

	<para>Compilers treat broadcast and multicast addresses differently if the firewall object is set to be a bridging firewall. In this case the checkbox "Bridging firewall" should be turned on in the firewall settings dialog and one or more interface objects should be marked as "Bridge port":</para>

      <figure float="1" id="bridge-broadcast-multicast">
        <title>Broadcast and Multicast address in a bridging firewall</title>
            <graphic scale="50" fileref="bridge_interface_dialog_1.png" />
      </figure>

	<para>Now the rule that matches the broadcast destination address will be treated differently:</para>

      <figure float="1" id="broadcast_rules_2">
        <title>Broadcast and Multicast address in a rule</title>
            <graphic scale="70" fileref="broadcast_rules_2.png" />
      </figure>

	<para>This produces the following iptables commands:</para>
<screen>
$IPTABLES -A FORWARD  -d 172.16.22.255  -m state --state NEW  -j ACCEPT 
$IPTABLES -A INPUT  -d 172.16.22.255  -m state --state NEW  -j ACCEPT 
</screen>        

	<para>Rules went into both INPUT and FORWARD chains because the bridging firewall passes broadcasts through, but at the same time accepts them as packets headed for itself. Since the rule did not specify which interface it should look at, Firewall Builder assumed that the generated rule should inspect packets crossing all interfaces, both bridge ports and "normal" ones, and therefore placed the rule in both INPUT and FORWARD chains.</para>

      </sect3>
    </sect2>

    <sect2>
      <title>DNS Name Objects</title>
      <para>A DNS Name object represents a DNS "A" or "AAAA" record. The object resolves into IP address at compile or run time. The address (IPv4 or IPv6) the object resolves to depends the address family or families of the ruleset it is used in. That is, if the object is used in a rule that is part of IPv4 rule set, the compiler will try to resolve the object using DNS query for the "A" record, but if the object is used in a rule that is part of an IPv6 rule set, the compiler will run a "AAAA" query. If the rule set where the object is used is a mixed type (IPv4+IPv6), the compiler will resolve the same object twice using different queries.</para>

      <para>The <guilabel>DNS Name</guilabel> object dialog looks like this:</para>

      <figure float="1" id="dns-name">
        <title>DNS Name Object</title>
            <graphic scale="70" fileref="dns_name_2.png" />
      </figure>

<itemizedlist spacing="compact">
          <listitem>
            <para>Name:</para>

            <para>The name of the DNS Name object</para>
          </listitem>

          <listitem>
            <para>DNS Record:</para>

            <para>The DNS record you want to resolve.</para>
          </listitem>

          <listitem>
            <para>Compile Time / Run Time:</para>

            <para>Indicate whether you want to resolve the IP address when you create the firewall script (compile time) or when you run the script on the firewall (run time).</para>
          </listitem>

          <listitem>
            <para>Comment:</para>

            <para>A free-form text field used for comments</para>
          </listitem>
        </itemizedlist>

	<para> The <guilabel>DNS Record</guilabel> parameter is the name of the A or AAAA record we want to resolve. In this example it is the host name of the Firewall Builder project web site "www.fwbuilder.org". Note that IPv6 web server for the project is accessible as "ipv6.fwbuilder.org" so we are going to need second DNS Name object for IPv6 examples. <guilabel>Compile Time</guilabel> and <guilabel>Run Time</guilabel> options have the same meaning as those in the Address Table object, that is, compile time DNS Name object is converted to the IP address by the policy compiler, while run time DNS Name object is not. In the latter case, the compiler puts DNS record name into the generated script or configuration file and leaves it up to the firewall to resolve it when the script is activated.</para>

	<para>Both compile time and run DNS Name objects are supported on all target firewall platforms.</para>

	<para>Let's look at how the simple rule shown in <xref linkend="group-dialog1" /> compiles for iptables and PF, both for compile time and run time DNS Name object.</para>

      <figure float="1" id="dns-name-3">
        <title>Rule using DNS Name object</title>
            <graphic scale="70" fileref="dns_name_3.png" />
      </figure>

      <figure float="1" id="dns-name-compile-iptables">
        <title>DNS Name Compile Time, iptables compile output</title>
            <screen>
# Rule 0 (global)
# 
$IPTABLES -A FORWARD  -d 70.85.175.170  -m state --state NEW  -j ACCEPT  
</screen>
      </figure>

      <para>In this trivial case, the compiler simply resolved "www.fwbuilder.org" to an IP address and used it in the iptables command. However, if the policy rule was in a ruleset configured as an IPv6-only rule set, the rule would not produce any iptables command at all because there is no AAAA DNS record with name "www.fwbuilder.org". If the rule set was both IPv4+IPv6, then the rule would generate iptables command only in the IPv4 part. The opposite is also true, the DNS Name object with record "ipv6.fwbuilder.org" will only produce iptables commands when used in IPv6 rule set because there is only AAAA record with this name.</para>

      <figure float="1" id="dns-name-compile-pf">
        <title>DNS Name Compile Time, PF compile output</title>
            <screen>
# Rule  0 (global)
# 
pass in   quick inet  from any  to 70.85.175.170 keep state
</screen>
      </figure>

      <para>The same is true in the case of PF: the compiler simply resolved the name "www.fwbuilder.org" and put the address in the generated pf.conf file. Since this name does not resolve into any IPv6 address, IPv6 PF policy would not have any line for this rule. DNS record "ipv6.fwbuilder.org" resolves only into an IPv6 address, and therefore DNS Name object with this record would only produce pf.conf configuration for IPv6 and not for IPv4.</para>

      <figure float="1" id="dns-name-run-iptables">
        <title>DNS Name Run Time, iptables compile output</title>
            <screen>
# Rule 0 (global)
# 
$IPTABLES -A FORWARD  -d www.fwbuilder.org -m state --state NEW  -j ACCEPT
</screen>
      </figure>

      <para>Here the compiler used the line entered in the DNS record parameter literally, leaving it up to iptables on the firewall machine to resolve this name into an IP address. Using a run time DNS Name object in IPv6 policy generates the following iptables command:</para>
            <screen>
# Rule 0 (global)
# 
$IP6TABLES -A FORWARD  -d ipv6.fwbuilder.org -m state --state NEW  -j ACCEPT 
</screen>

      <para>$IP6TABLES is the shell variable defined at the beginning of the generated script, the value of this variable is the full path to the <command>ip6tables</command> command line utility. <command>ip6tables</command> will try to resolve given name to an IPv6 address since it processes IPv6 iptables policy.</para>

      <figure float="1" id="dns-name-run-pf">
        <title>DNS Name Run Time, PF compile output</title>
            <screen>
# Rule  0 (global)
#
pass in   quick inet  from any  to www.fwbuilder.org keep state
pass out  quick inet  from any  to www.fwbuilder.org keep state
	   </screen>
      </figure>

      <para>Run time DNS Name object translates into PF configuration lines that also use the name of the DNS record and leave it up to PF to actually resolve it to an IP address when the configuration is loaded.</para>

    </sect2>

    <sect2>
      <title>A Group of Addressable Objects</title>

      <figure float="1" id="group-dialog1">
        <title>Group of Objects</title>
            <graphic scale="50" fileref="group-view1.png" />
      </figure>

      <para>The group of objects holds references to Hosts, Networks, Address
      Ranges, Firewalls and other groups of addressable objects (<xref
      linkend="group-dialog1" />). Use <guimenuitem>New Object / New Object Group</guimenuitem> to create a new group. Objects can be added to the group using the
      following methods:</para>

      <para><itemizedlist spacing="compact">
          <listitem>
            <para>Using drag and drop:</para>

            <para>Objects can be dragged from the tree into the group dialog.
            Click, hold down the mouse button, and drag the object to add it to the group.</para>
          </listitem>

          <listitem>
            <para>Using the popup menu:</para>

            <para>You can use the Copy/Paste operations between the tree
            and group dialog. Right-clicking on the object in the tree
            brings a pop-up menu. Choose <guimenuitem>Copy</guimenuitem> in this
            menu, then move the mouse to the group dialog and right-click in the
            icon field. This also brings up a pop-up menu, where you choose
            <guimenuitem>Paste</guimenuitem>. This inserts a reference to the object in the
            group.</para>
          </listitem>

          <listitem>
            <para>Using the <guimenu>Edit</guimenu> main menu:</para>

            <para>Select the object in the tree, select 
            <guimenu>Edit</guimenu>/<guimenuitem>Copy
            Object</guimenuitem> from the menu bar, then click on the group dialog, and then select <guimenuitem>Edit</guimenuitem>/<guimenuitem>Paste
            Object</guimenuitem> from the menu bar.</para>
          </listitem>
        </itemizedlist></para>
    </sect2>
   </sect1>

  <sect1 id="working-with-services">
    <title>Service Objects</title>

      <para>In Firewall Builder, service objects represent IP, ICMP, TCP, and UDP services such as "host unreachable" in ICMP, HTTP in TCP, GRE in IP, and DNS in UDP. Firewall Builder provides service objects for hundred of well-known and frequently used services in ICMP (IP protocol number 1), TCP (IP protocol number 6), and UDP (IP
      protocol number 17). </para> 

    <sect2>
      <title>IP Service</title>

      <para>    
                The IP service object describes protocols that are not
                ICMP, TCP, or UDP. (ICMP, TCP, and UDP have their own
                service objects.) An IP protocol is defined by the
                8-bit field in the IP packet header. The screenshot
                below represents the ESP object (Encapsulating
                Security Payload, part of the IPSEC protocol family)
                which uses the IP protocol number 50.</para>

        <figure float="1"><title/><graphic scale="50" fileref="ip_service_1.png"/></figure>
      
      <note>
	<para>Protocol numbers are assigned by IANA; one can look up the number for a
      particular protocol at the following URL:
      http://www.iana.org/assignments/protocol-numbers/</para>
      </note>

      <para>Besides the protocol number, the header of the IP packet also has
      a field called "options" which is a variable-length list of optional
      information for the packet. Not all firewalls can examine options, and
      those that can usually have certain limitations as to what options they
      can match against. Firewall Builder tries to provide controls for many
      popular options supported by the most sophisticated firewalls. Not all
      options supported by Firewall Builder are supported by all target
      firewall platforms (<xref linkend="support-for-ip-options" />).</para>

      <table id="support-for-ip-options">
        <title>Support for IP options and fragmentation on various firewall
        platforms</title>

        <tgroup cols="7">
          <colspec align="center" />

          <colspec align="center" colwidth="64pt" />

          <colspec align="center" colwidth="64pt" />

          <colspec align="center" colwidth="64pt" />

          <colspec align="center" />

          <colspec align="center" />

          <colspec align="center" />

          <thead>
            <row>
              <entry>Firewall</entry>

              <entry>lsrr</entry>

              <entry>ssrr</entry>

              <entry>rr</entry>

              <entry>timestamp</entry>

              <entry>all fragments</entry>

              <entry>'short' packets</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>iptables</entry>

              <entry>+</entry>

              <entry>+</entry>

              <entry>+</entry>

              <entry>+</entry>

              <entry>+</entry>

              <entry>-</entry>
            </row>

            <row>
              <entry>ipfilter</entry>

              <entry>-</entry>

              <entry>+</entry>

              <entry>+</entry>

              <entry>+</entry>

              <entry>+</entry>

              <entry>+</entry>
            </row>

            <row>
              <entry>pf</entry>

              <entry>-</entry>

              <entry>-</entry>

              <entry>-</entry>

              <entry>-</entry>

              <entry>+</entry>

              <entry>-</entry>
            </row>

            <row>
              <entry>Cisco PIX</entry>

              <entry>-</entry>

              <entry>-</entry>

              <entry>-</entry>

              <entry>-</entry>

              <entry>-</entry>

              <entry>-</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <informaltable frame="none">
        <tgroup cols="2">
          <colspec align="left" colwidth="150pt" />

          <tbody>
            <row>
              <entry><filename>Source route options: LSRR,
              SSRR</filename></entry>

              <entry>Normally IP routing is dynamic with each router making decisions about which next hop router to send the packet to. However, another option exists where the sender can choose the route. In the case of the Loose Source Route, the sender (host) can specify a list of routers the packet must traverse, but it may also pass through other routers between any two addresses in the list. The Strict Source Route works very much the same way, except the packet must traverse only through the specified addresses. Source routing can potentially be used to reach hosts behind the firewall even if these hosts use private IP addresses, which normally are not reachable over the Internet. </entry>
            </row>

            <row>
              <entry><filename>Record route option: RR</filename></entry>

              <entry>This option causes every router that handles the packet on the way to add its IP address to a list in the options field. This option is used by the ping utility when it is called with the "-R" command line switch; it can potentially be exploited to discover the internal network addressing and layout behind the firewall. Although the risk is low, some firewall administrators prefer to block packets with this option set. </entry>
            </row>

            <row>
              <entry><filename>Timestamp option:</filename></entry>

              <entry>This option tells routers that handle the packet to record their timestamps and sometimes addresses (like in the case of the record route option). This option is seldom used, but can potentially be exploited to gather information about the protected network, so some firewall administrators prefer to block packets with this option set. </entry>
            </row>

            <row>
              <entry><filename>Fragment options:</filename></entry>

              <entry>IP packets may sometimes become fragmented. This happens if the original datagram is larger than what a physical
		network layer can transmit. The IP packet header has special fields (called "Flags" and "Fragmentation Offset") that
		detect fragmented packets and help reassemble them. Many firewalls can check these bits as well. Certain combinations
		of flags and fragmentation offsets can never happen during normal operation but were seen to be used by attackers. 
		Firewall Builder provides two options for handling the most commonly used cases: the "all fragments" option matches 
		the second and further fragments, while the "short" option is used to match packets that are too short to contain even a complete IP header.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>Standard IP Service objects that come with Firewall Builder appear
      in the <guilabel>Standard</guilabel> tree, in the <guimenuitem>Services/IP</guimenuitem>
      branch.</para>

      <para>You can create your own IP Service objects in the <guilabel>User</guilabel> library.</para>


      <figure float="1" id="ip-service-dialog2">
        <title>Creating/Editing an IP Service Object</title>

            <graphic scale="50" fileref="ip_service_dialog2.png" />

      </figure>

      <para>Service objects in the <guilabel>Standard</guilabel> are not editable. However, you can copy-and-paste a copy of a service object into the <guilabel>User</guilabel> tree and edit it there, or you can right-click the <guilabel>IP</guilabel> folder in the <guilabel>User</guilabel> tree and select <guimenuitem>New IP Service</guimenuitem> to create a service object from scratch.</para>

      <para>In either case, the controls are the same.</para>

      <para>The IP Service dialog provides the following controls:</para>

      <para><itemizedlist spacing="compact">
          <listitem>
            <para>Name:</para>

            <para>This is the name of the object</para>
          </listitem>

          <listitem>
            <para>Protocol:</para>

            <para>This is the protocol number.</para>
          </listitem>

          <listitem>
            <para>DiffServ</para>

            <para>You can specify DSCP or TOS using the radio buttons. In either case, specify a code (or class) in the field. If you do not specify a code or class, Firewall Builder ignores the DiffServ type (DSCP or TOS).</para>
          </listitem>

          <listitem>
            <para>Options:</para>

            <para>These flags represent 'Options' flags in the IP
            header:</para>

            <para><simplelist>
                <member>lsrr (loose source route)</member>

                <member>ssrr (strict source route)</member>

                <member>rr (record route)</member>

                <member>timestamp</member>

                <member>all fragments</member>

                <member>short fragments</member>
              </simplelist></para>
          </listitem>

          <listitem>
            <para>Comments:</para>

            <para>This is a free-style text field used for comments.</para>
          </listitem>
        </itemizedlist></para>

      <sect3>
	<title>Using IP service objects in policy rules</title>

          <para>
                Consider the following IP Service objects:
          </para>
  

        <table frame='all'><title></title>
	<tgroup cols="2">
	  <tbody>
                <row>
        <entry>
        <inlinegraphic scale="50" fileref="ip_service_2.png"/></entry>

        <entry>
        <inlinegraphic scale="50" fileref="ip_service_5.png"/></entry>
                </row>

                <row>
        <entry>

        <inlinegraphic scale="50" fileref="ip_service_3.png"/></entry>
                  
        <entry>
        <inlinegraphic scale="50" fileref="ip_service_4.png"/></entry>
                </row>
	</tbody></tgroup></table>

          <para>
  
                Object <emphasis>EF</emphasis> has DSCP matching turned on, matching
                traffic class <emphasis>EF</emphasis>. Object <emphasis>TOS 0x10</emphasis> matches
                packets with TOS bits set to 0x10 (low delay).
                Object <emphasis>all_fragments</emphasis> has flag "all fragments"
                turned on, and finally object
                <emphasis>lsrr</emphasis> matches "loose source routing"
                option. Here is what we get for iptables when we use
                these objects in policy rules as follows:
              
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="ip_service_rule_1.png"/></figure>

          <para>
  
          </para>
  

  <screen>

# Rule 0 (global)
# 
$IPTABLES -N RULE_0
$IPTABLES -A FORWARD -p all  -f   -j RULE_0 
$IPTABLES -A FORWARD -p all  -m ipv4options  --lsrr  -j RULE_0 
$IPTABLES -A RULE_0  -j LOG  --log-level info --log-prefix "RULE 0 -- DENY "
$IPTABLES -A RULE_0  -j DROP 
# 
# Rule 1 (global)
# 
$IPTABLES -A FORWARD  -o + -p all  -m dscp --dscp-class EF  -m state \
--state NEW  -j ACCEPT 
$IPTABLES -A FORWARD  -o + -p all  -m tos --tos 0x10  -m state --state NEW  \
-j ACCEPT 

              </screen>

          <para>
  
                The compiler for iptables uses module <emphasis>ipv4options</emphasis>
                to match <emphasis>lsrr</emphasis>, command line option <emphasis>-f</emphasis> to
                match all fragments, module <emphasis>tos</emphasis> to match TOS
                and module <emphasis>dscp</emphasis> to match dscp class.
              
          </para>
  

          <para>
  
                When compiled for IPv6, these rules yield the
                following iptables commands:
              
          </para>
  

  <screen>

# Rule 0 (global)
# 
$IP6TABLES -N RULE_0
$IP6TABLES -A FORWARD  -m frag --fragmore  -j RULE_0 
$IP6TABLES -A RULE_0  -j LOG  --log-level info --log-prefix "RULE 0 -- DENY "
$IP6TABLES -A RULE_0  -j DROP 
# 
# Rule 1 (global)
# 
$IP6TABLES -A FORWARD  -o +  -m dscp --dscp-class EF  -m state --state NEW  -j ACCEPT 
$IP6TABLES -A FORWARD  -o +  -m tos --tos 0x10  -m state --state NEW  -j ACCEPT 

              </screen>

          <para>
  
                <emphasis>ip6tables</emphasis> does not have the command line
                flag <emphasis>-f</emphasis>, instead it uses module <emphasis>frag</emphasis> to
                match fragments. Firewall Builder currently does not support
                ip6tables module <emphasis>ipv6header</emphasis>, and source routing
                options do not exist in IPv6, so object "lsrr" cannot
                be used in rules.
              
          </para>
  

          <para>
  
                PF cannot match DSCP bits and source routing options
                but can match TOS. Trying the same IP Service object "tos 0x10"
                in policy rules for PF:
              
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="ip_service_rule_2.png"/></figure>

          <para>
  
          </para>
  

  <screen>

pass out  quick inet  from any  to (eth0)  tos 0x10 keep state

              </screen>

          <para>
  
                Cisco IOS access lists cannot match source route
                options but can match fragments and TOS and DSCP bits.
                Here is what we get if we try to compile the same
                rules using the same IP Service objects for Cisco IOS:
              
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="ip_service_rule_3.png"/></figure>

          <para>
  
          </para>
  

  <screen>

ip access-list extended e1_0_out
! 
! Rule  0 (global)
! 
  deny   ip any  any  log fragments 
! 
! Rule  1 (global)
! 
  permit ip any  any  tos 0x10
  permit ip any  any  dscp EF
exit

              </screen>

      </sect3>
    </sect2>

    <sect2>
      <title>Using ICMP and ICMP6 Service Objects   in Firewall Builder</title>

        <para>
  
                The ICMP Service object is a generalized
                representation of the ICMP protocol. ICMP packets
                are often used to communicate error messages that
                are acted upon by either the IP layer or higher
                layer protocols (TCP or UDP). ICMP can also be used
                as a simple query protocol.
              
  </para>
  

        <para>
  
                Firewall Builder has service objects for both IPv4
                and IPv6. ICMP Service objects for IPv6 are called
                ICMP6 Service. The standard ICMP Service objects
                that come with Firewall Builder appear in
                the <emphasis>Standard Objects</emphasis> library, in
                the <emphasis>Services/ICMP</emphasis> branch. User-defined ICMP
                and ICMP6 service objects will appear in the
                library <emphasis>User</emphasis> in the same <emphasis>Services/ICMP</emphasis>
                branch.
              
  </para>
  

        <para>
  
                Service objects in the Standard are not
                editable. However, you can copy-and-paste a copy of a
                service object into the User tree and edit it there,
                or you can right-click the ICMP folder in the User
                tree and select New ICMP Service to create a service
                object from scratch.
              
  </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="icmp_service_tree.png"/></figure>

        <para>
  
                As a firewall administrator, you need to understand
                the nature and purpose of ICMP in order to properly
                configure the firewall to block unwanted ICMP messages
                while permitting useful ones.
              
  </para>
  

        <para>
  
                ICMP packets have two header fields that distinguish
                particular ICMP messages: the type and code
                fields. There are many different types and classes of
                ICMP messages. See
                http://www.iana.org/assignments/icmp-parameters for
                IPv4 types and classes and
                http://www.iana.org/assignments/icmpv6-parameters
                (http://www.iana.org/assignments/icmpv6-parameters)
                for IPv6 types and classes. 
              
  </para>
  

        <para>
  
                Any combination of the <emphasis>type</emphasis> and <emphasis>code</emphasis>
                values is allowed in the ICMP or ICMP6 Object. For
                example the following two screen shots illustrate
                definitions of ICMP and ICMP6 objects for the
                request packet of well known ping protocol. The type
                codes are different for IPv4 and IPv6 variants,
                although the code is equal to 0 in both:
              
  </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="icmp_service_1.png"/></figure>

        <figure float="1"><title/><graphic scale="50" fileref="icmp6_service_1.png"/></figure>

        <para>
  
                Both ICMP and ICMP6 allow value "any" in type or
                code fields. For example, this can be used to build
                an object to match a family of ICMP messages with
                the same type but any code:
              
  </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="icmp_service_2.png"/></figure>

        <para>
  
                Both IPv4 and IPv6 ICMP Service dialogs provide the
                following controls:
              
  </para>
  

  <itemizedlist>

  <listitem><para>
  Name: This is the name of the object. 
                </para>
  </listitem>
  

                

  <listitem><para>
  ICMP Type and Code:
                  

  <itemizedlist>

  <listitem><para>
  Type: The ICMP message type. This control
                      consists of a numeric selector that lets you
                      specify the message type. To specify "any" type,
                      set the control to any.
                    </para>
  </listitem>
  

                    

  <listitem><para>
  Code: The ICMP message code. This control
                      consists of a numeric selector that lets you
                      specify the message code. To specify "any" code,
                      set the control to any.
                    </para>
  </listitem>
  
                  </itemizedlist></para>
  </listitem>
  

                

  <listitem><para>
  Comment: This is a free-style text field used
                  for comments.
                </para>
  </listitem>
  

              </itemizedlist>

  <sect3>
        <title>Using ICMP and ICMP6 Service Objects in Rules</title>

        <para>
  
                Consider the following rule where we use two ICMP
                objects, one for IPv4 and another for IPv6:
              
  </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="icmp_service_rule_1.png"/></figure>

        <para>
  
                If the rule set this rule belongs to is configured as
                combined IPv4 and IPv6, then policy compiler will pick
                ICMP service that matches address family on each
                separate pass, one for IPv4 and then for IPv6. Here is
                what we get for iptables:
              
	</para>
  

  <screen>
# ================ IPv4

# Rule 0 (global)
# 
$IPTABLES -A FORWARD  -i + -p icmp  -m icmp  --icmp-type 8/0 \
     -m state --state NEW  -j ACCEPT 
 
# ================ IPv6

# Rule 0 (global)
# 
$IP6TABLES -A FORWARD  -i + -p ipv6-icmp  -m icmp6 --icmpv6-type 128/0 \
     -m state --state NEW  -j ACCEPT 

              </screen>

        <para>
  
                Here is generated PF 4.x configuration:
              
	</para>
  

  <screen>

# Rule  0 (global)
# 
pass in   quick inet proto icmp  from any  to any icmp-type 8 code 0

# Rule  0 (global)
# 
pass in   quick inet6 proto icmp6  from any  to any

              </screen>
  </sect3>
    </sect2>

    <sect2 id="tcp-service">
      <title>TCP Service</title>


  

          <para>
  
                  The TCP Service object is a generalization of the
                  TCP protocol, which provides a connection-oriented
                  reliable byte stream service. Many well-known,
                  frequently used application protocols use TCP
                  protocol: FTP (File Transfer Protocol), SMTP (Simple
                  Mail Transfer Protocol), HTTP (Hyper Text Transfer
                  Protocol), and so on. The TCP header contains
                  special fields indicating source and destination port
                  numbers that are used to identify the sending and
                  receiving application. These two values, along with
                  the source and destination IP addresses in the IP
                  header, uniquely identify each connection.
                
          </para>
  

          <para>
  
                  Since port numbers are used to distinguish
                  applications using the data stream provided by the
                  TCP protocol, each application should use a unique
                  port number. To ensure interoperability, these
                  numbers must be assigned by a central authority in a
                  coordinated manner. Internet Assigned Numbers
                  Authority (IANA) does just that. Assigned TCP and
                  UDP port numbers can be looked up at
                  http://www.iana.org/assignments/port-numbers. Most
                  Unix systems also come with a /etc/services file that
                  contains a list of assigned port numbers.
                
          </para>
  

          <para>
  
                  Firewall Builder comes with a collection of
                  predefined TCP Service objects with port numbers
                  already configured. You can simply use these objects
                  in your policy rules, so you do not have to look up
                  port numbers every time you need them. These objects
                  are part of the <emphasis>Standard Objects</emphasis> library and
                  are located in the <emphasis>Services / TCP</emphasis> branch.
                
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="tcp_service_1_1.png"/></figure>

          <para>
  
                  The typical TCP Service object is represented in the
                  following screenshot:
                
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="tcp_service_1.png"/></figure>

          <para>
  
                In Firewall Builder, the TCP Service object is a
                generalization of TCP protocol. The TCP header of a
                packet carries only one fixed value for the source port
                and one fixed value for the destination port. The TCP
                Service object allows a range of values to be used for
                the source and destination ports. This allows a single
                TCP Service object to describe either a family of
                protocols using consecutive port numbers, or a
                protocol that may use variable port numbers or simply
                many protocols that use port numbers from a certain
                range. For example, on Unix systems, TCP sessions
                opened by a privileged process always have their
                source port number assigned from a range below 1024,
                while unprivileged processes use source port numbers
                from a range starting from 1024 and above. The TCP
                Service object with a source port range defined as
                shown in the following screenshot describes all
                privileged TCP sessions.
              
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="tcp_service_2.png"/></figure>

          <para>
  
                Using "0" as both start and end values for a range
                means "any value" for that range. The source port
                range of the "privileged TCP" object starts from 0 and
                ends at 1023 (port ranges are inclusive in Firewall
                Builder), while its destination port range's start and
                end are both set to zero, which means "any destination
                port". This object describes any TCP protocol with a
                source port in range 0-1023 and any destination port.
              
          </para>
  

          <para>
  
                If all you need is to create an object to describe the
                TCP protocol with a particular destination port, just
                use the same port number for both the start and end of
                a destination port range (which effectively creates a
                range that consists of a single value). The example in
                Figure 6-70 shows such a service.
              
          </para>
  

          <para>
  
                The TCP header also contains a collection of one-bit
                fields, or flags, that carry a variety of control
                information. For example, the SYN and ACK flags are
                used for connection establishment and the FIN flag is
                used for connection termination. Certain combinations
                of flags are not allowed during the normal protocol
                operation and may cause unpredicted reactions in some
                systems; because of this, the firewall administrator
                may want to block TCP packets with unwanted
                combination of flags.
              
          </para>
  

          <para>
  
                There are six flags in the TCP header. We just briefly
                mention them here; more information can be found in
                TCP/IP Illustrated, vol 1 by W. Richard Stevens,
                chapter 17.
              
          </para>

      <informaltable frame="none">
        <tgroup cols="2">
          <colspec align="center" colwidth="64pt" />

          <colspec align="left" />

          <tbody>
            <row>
              <entry><filename>U (URG)</filename></entry>

              <entry>The "urgent" pointer is valid</entry>
            </row>

            <row>
              <entry><filename>A (ACK)</filename></entry>

              <entry>The acknowledgment number is valid</entry>
            </row>

            <row>
              <entry><filename>P (PSH)</filename></entry>

              <entry>The receiver should pass this data to the application as
              soon as possible</entry>
            </row>

            <row>
              <entry><filename>R (RST)</filename></entry>

              <entry>Reset the connection</entry>
            </row>

            <row>
              <entry><filename>S (SYN)</filename></entry>

              <entry>Synchronize sequence numbers to initiate a
              connection.</entry>
            </row>

            <row>
              <entry><filename>F (FIN)</filename></entry>

              <entry>The sender is finished sending data.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

          <para>
  
                "Established" is not a TCP flag. Instead,
                checking this box causes the firewall to match any
                packet in an established session. Checking this
                checkbox disables the other TCP flag controls.
              
          </para>
  

          <para>
  
                Firewall Builder supports all six flags, although not
                all target firewall platforms can match all
                combinations of TCP flags or any flags at all. For
                example, iptables, pf, ipfilter and ipfw can match
                flags and their combinations, but Cisco PIX cannot.
              
          </para>
  

          <para>
  
                Usually the firewall cannot only match a combination
                of flags, but can also examine only a given subset of
                TCP flags. Firewall Builder provides two sets of
                checkboxes for TCP flags and flag masks (see screenshot
                below). Checkboxes in the first row control TCP flags
                that we want the firewall to examine and checkboxes in
                the second row tell it whether they should be set or
                cleared. Only flags whose checkboxes in the first row
                are set will be looked at by the firewall. (If you check a box in the bottom row while leaving the checkbox above it unchecked, the flag will be ignored.) 
								</para>
					<para>The object
                in the screenshot matches a TCP packet with any
                combination of port numbers, the TCP flag SYN set, and
                all other flags cleared. The firewall will examine all
                TCP flags.
              
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="tcp_service_3.png"/></figure>

          <para>
  
                A Combination of flags and a mask can be used in a rule
                that looks for some flags to be set or unset and
                ignores other ones regardless of their state. For
                example, we can create a rule that detects a so called
                "null scan" which is done using TCP packets with all
                flags cleared. For this rule we create a TCP Service
                object "tcp null scan" where all flag masks are set but
                all TCP flags are cleared. This means we examine all
                flags but only match them if they are all cleared. This
                object is represented in the following screenshot:
              
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="tcp_service_4.png"/></figure>

          <para>
  
TCP Service dialog provides the following controls: 
              
          </para>
  

          <para>
  
                
          </para>
  

  <itemizedlist>

  <listitem>        <para>
  Name:  This is the name of the object 
                          </para>
  </listitem>
  

                  

  <listitem>        <para>
  Source port range: These two controls define the
                    start and end of the source port range. They
                    accept values 0 through 65535.
                          </para>
  </listitem>
  

                  

  <listitem>        <para>
  Destination port range: These two controls define
                    the start and end of the destination port
                    range. They accept values 0 through 65535.
                          </para>
  </listitem>
  

                  

  <listitem>        <para>
  TCP Flags: TCP flags and masks, see above. The
                    Established checkbox causes the firewall to match
                    packets in established sessions. Selecting this
                    checkbox disables the other TCP flag controls.
                          </para>
  </listitem>
  

                  

  <listitem>        <para>
  Comments: This is a free-style text field used
                  for comments.
                          </para>
  </listitem>
  
                </itemizedlist>

<sect3>
        <title>Using TCP Service in rules</title>

  


    <sect4>
        <title>Single destination TCP port</title>

          <para>
  
                Let's start with an example of using simple TCP service
                that describes HTTP protocol. Both the beginning and
                the end of the source port range in this service
                object are set to "0" which means the program will
                leave these out when it generates target firewall
                configuration.  The destination port range is defined
                as "80-80" which means the object describes just
                single destination tcp port "80". All flag checkboxes
                are unchecked which means no flag-matching
                configuration will be generated.
              
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="tcp_service_5.png"/></figure>

          <para>
  
                Now we put this object in the "Service" element of a
                rule as shown on the next screenshot. To make this
                trivial example just a little bit more interesting, 
                we configured the policy rule set as "Combined IPv4 and IPv6"
                and put two address objects in destination, one is IPv4
                address and another is IPv6 address.
              
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="tcp_service_rule_1.png"/></figure>

          <para>
  
                This rule compiles into the following for iptables:
              
          </para>
  

  <screen>

# ================ IPv4

# Rule 0 (global)
# 
$IPTABLES -A FORWARD -p tcp -m tcp  -d 70.85.175.170 \
     --dport 80  -m state --state NEW  -j ACCEPT 

# ================ IPv4

# Rule 0 (global)
# 
$IP6TABLES -A FORWARD -p tcp -m tcp  -d 2001:470:1f0e:162::2 \
     --dport 80  -m state --state NEW  -j ACCEPT 
              </screen>

          <para>
  
                And for PF we get the following. Note that PF version
                was set to "any" or "3.x", this is why "keep state"
                was added. "Keep state" is default for PF 4.x and if
                version was configured as "4.x" in this firewall
                object, policy compiler would have dropped "keep
                state" from generated configuration.
              
          </para>
  

  <screen>
# Rule  0 (global)
# 
pass in   quick inet proto tcp  from any  to 70.85.175.170 port 80 keep state
pass out  quick inet proto tcp  from any  to 70.85.175.170 port 80 keep state

# Rule  0 (global)
# 
pass in   quick inet6 proto tcp  from any  to 2001:470:1f0e:162::2 port 80 keep state
pass out  quick inet6 proto tcp  from any  to 2001:470:1f0e:162::2 port 80 keep state

              </screen>
    </sect4>
    <sect4>
        <title>Source port range</title>

          <para>
  
                In the next example we look at the TCP service object
                that defines specific source port range to match
                source ports greater than or equal to 1024:
              
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="tcp_service_6.png"/></figure>

          <para>
  
                Using this object in a rule as follows:
              
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="tcp_service_rule_2.png"/></figure>

          <para>
  
                To make the rule slightly more realistic, we made it
                stateless using its options dialog (double-click in
                the column "Options" of this rule and check checkbox
                "Stateless" in the first tab of the dialog). Let's see
                what the program generates when this rule is compiled
                for iptables:
              
          </para>
  

  <screen>

# Rule 0 (global)
# 
$IPTABLES -A FORWARD  -i + -p tcp -m tcp  --sport 1024:65535  -j ACCEPT 

              </screen>

          <para>
  
                Here is what is generated for PF 3.x:
              
          </para>
  

  <screen>
# Rule  0 (global)
# 
pass in   quick inet proto tcp  from any port &gt;= 1024  to any
              </screen>

          <para>
  
                And for PF 4.x we get "no state" because the rule is
                stateless and state matching is the default in PF 4.x:
              
          </para>
  

  <screen>

pass in   quick inet proto tcp  from any port &gt;= 1024  to any no state

              </screen>

          <para>
  
                Cisco IOS access list statement looks like this:
              
          </para>
  

  <screen>

ip access-list extended e1_1_in
! 
! Rule  0 (global)
! 
  permit tcp any  gt 1024 any  
exit

              </screen>
    </sect4>
    <sect4>
        <title>Established</title>

          <para>
  
                Some of the supported firewalls understand special
                flag "established" intended to match reply packets of
                the TCP session. Stateless systems, such as Cisco IOS
                extended access lists, match combination of tcp flags
                where flag "ACK" is set but flag "SYN" is cleared when
                this keyword is used in the acl rule. Stateful
                firewalls such as iptables or PF offer much better way
                to track and match reply packets because they can
                follow the states a tcp session goes through when it
                is opened, data transferred and finally session is
                closed. Firewall Builder provides an option of using
                flag "established" but supports it only for those
                firewall platforms where there is no better
                alternative. Attempt to use TCP service object with
                this flag set in rules for the firewall that supports
                stateful inspection causes an error.
              
          </para>
  

          <para>
  
                Here is an example of the TCP service object with flag
              "Established" set and source port range "80-80", that
              is, this object describes TCP packets coming from the
              web server operating on the standard port 80 back to the
              client.
              
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="tcp_service_7.png"/></figure>

          <para>
  
                Using this object in a rule:
              
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="tcp_service_rule_3.png"/></figure>

          <para>
  
                Here is the access list generated for Cisco IOS:
              
          </para>
  

  <screen>
ip access-list extended e1_0_in
! 
! Rule  0 (global)
! 
  permit tcp any  eq 80 any  established 
! 
              </screen>

          <para>
  
                Here we have source port specification "eq 80" and
                keyword "established"
              
          </para>
  

          <para>
  
                Attempt to compile this rule for iptables or PF causes an error:
              
          </para>
  

  <screen>

Error (pf): TCPService object with option "established" is not supported 
   by firewall platform "pf". Use stateful rule instead.

              </screen>
	</sect4>
      </sect3>
    </sect2>

    <sect2>
      <title>UDP Service</title>

          <para>
  
                The UDP Service object is a generalization of the UDP
                protocol, which is a connectionless transport layer
                protocol. Many well-known applications use UDP as
                their transport, such as DNS (Domain Name System),
                DHCP (Dynamic Host Configuration Protocol), NTP
                (Network Time Protocol), and SNMP (Simple Network
                Management Protocol)..
              
          </para>
  

          <para>
  
                As in TCP, UDP uses port numbers to distinguish
                applications from one another. The UDP packet header
                carries two port numbers: the source port and the
                destination port. The UDP Service object in Firewall
                Builder allows for a definition of ranges for both the
                source and the destination ports. The meaning of
                values assigned to the start and end of the range is
                the same as in the TCP Service object: ranges are
                inclusive, that is, both start and end ports of the
                range are included. Using "0" for both the start and
                end of the range means "any port". These rules work
                for both the source and destination ranges. The
                following screenshot shows the "dns" UDP Service
                object that represents the Domain Name System protocol
                which uses destination port 53.
              
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="udp_service_1.png"/></figure>

          <para>
  
                Service objects in the Standard are not
                editable. However, you can copy-and-paste a copy of a
                service object into the User tree and edit it there,
                or you can right-click the ICMP folder in the User
                tree and select New ICMP Service to create a service
                object from scratch.
              
          </para>
  

          <para>
  
                The UDP Service dialog provides the following controls: 
              
          </para>
  

          <para>
  
                
          </para>
  

  <itemizedlist>

  <listitem>        <para>
  Name: This is the name of the object 
                          </para>
  </listitem>
  

                  

  <listitem>        <para>
  The Source port range: These two controls define
                    the start and the end of the source port
                    range. They accept values 0 through 65535.
                          </para>
  </listitem>
  

                  

  <listitem>        <para>
  The Destination port range: These two controls
                    define the start and the end of the destination
                    port range. They accept values 0 through 65535.
                          </para>
  </listitem>
  

                  

  <listitem>        <para>
  Comments: This is a free-style text field used for comments. 
                          </para>
  </listitem>
  
                </itemizedlist>

     <sect3>
        <title>Using UDP Service in rules</title>

  

       <sect4>
        <title>Single destination UDP port</title>

          <para>
  
                In this example we'll use the UDP service object
                "domain" shown on screenshot above. The rule looks
                like this:
              
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="udp_service_rule_1.png"/></figure>

          <para>
  
                Here is iptables command generated for this rule:
              
          </para>
  

  <screen>

# Rule 0 (global)
# 
$IPTABLES -A FORWARD  -i + -p udp -m udp  --dport 53  -m state --state NEW  -j ACCEPT 

              </screen>

          <para>
  
                This rule got a <emphasis>"-i +"</emphasis> clause because direction
                was set to <emphasis>Inbound</emphasis> but <emphasis>"Interface"</emphasis>
                column was left empty. To enforce inbound direction
                compiler uses "-i" option but since interface was not
                specified, the rule got attached to all interfaces
                which is defined by the <emphasis>+</emphasis>.
              
          </para>
  

          <para>
  
                Here is generated PF 4.x configuration:
              
          </para>
  

  <screen>

# Rule  0 (global)
# 
pass in   quick inet proto udp  from any  to any port 53

              </screen>

          <para>
  
                In the pf configuration, direction is defined by
                the <emphasis>"in"</emphasis> keyword, and since no interface was
                requested, there is no <emphasis>"on &lt;interface&gt;"</emphasis>.
              
          </para>
  

          <para>
  
                Generated Cisco access list statement is quite trivial:
              
          </para>
  

  <screen>

ip access-list extended fe0_0_in
! 
! Rule  0 (global)
! 
  permit udp any  any  eq 53 
! 
exit
              </screen>

       </sect4>

       <sect4>
        <title>Source port range</title>

          <para>
  
                The following UDP service object defines source port
                range of the ports with values greater than or equal to 1024:
              
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="udp_service_2.png"/></figure>

          <para>
  
                Using this object in policy rule yields the following
                code for iptables:
              
          </para>
  

  <screen>
# Rule 0 (global)
# 
$IPTABLES -A FORWARD  -i + -p udp -m udp  --sport 1024:65535  -m state \
--state NEW  -j ACCEPT 

              </screen>

          <para>
  
                And for PF:
              
          </para>
  

  <screen>

# Rule  0 (global)
# 
# 
pass in   quick inet proto udp  from any port &gt;= 1024  to any

              </screen>

          <para>
  
                Cisco access list statement:
              
          </para>
  

  <screen>

ip access-list extended e1_0_in
! 
! Rule  0 (global)
! 
  permit udp any  gt 1024 any  
!
exit
              </screen>
       </sect4>
     </sect3>
    </sect2>

    <sect2 id="user-service">
      <title>User Service</title>

	<para>User Service object matches the owner of the process on the firewall that send the packet. It translates to the "owner" match in iptables and "user" parameter for PF.</para>

      <figure float="1" id="user-service-dialog">
          <title>User Service Dialog</title>
              <graphic scale="70" fileref="user_service_2.png" />
        </figure>

<itemizedlist spacing="compact">
          <listitem>
            <para>Name:</para>

            <para>This is the name of the object</para>
          </listitem>

          <listitem>
            <para>User id</para>

            <para>The user ID of the user account on the firewall device that the firewall should use to match packets.</para>
          </listitem>

          <listitem>
            <para>Comments:</para>

            <para>This is a free-style text field used for comments.</para>
          </listitem>
        </itemizedlist>

	<para> User Service object has only one parameter besides the name and comment: it is user id that the firewall should use to match packets.</para>

	<para>The User Service object is only supported for iptables and PF.</para>

	<para>Let's look at how the simple rule shown in <xref linkend="user-service-rule" /> compiles for iptables and PF.</para>
 
      <figure float="1" id="user-service-rule">
          <title>User Service Rule Example</title>
              <graphic scale="70" fileref="user_service_3.png" />
        </figure>

	<para>The firewall can associate a packet with a user only if the packet originated on the firewall. Packets that transit the firewall have no information about the user who owned the process that created these packets and sent them out because this process ran on an entirely different computer. For this reason, the object in the <guilabel>Source</guilabel> column must be the firewall.</para>

       <figure float="1" id="user-service-iptables">
        <title>User Service, iptables compile output</title>
            <screen>
# Rule 0 (global)
# 
$IPTABLES -A OUTPUT -m owner --uid-owner 500  -j DROP 
	</screen>
      </figure>

      <para> The User Service translated into the <emphasis>owner</emphasis> match for iptables. See the iptables man page for a more detailed explanation of this match.</para>

       <figure float="1" id="user-service-pf">
        <title>User Service, PF compile output</title>
            <screen>
# Tables: (1)
table  { en0 , 192.168.1.1 }

# Rule  0 (global)
# 
# 
block out  quick inet  from   to any user 500 
	</screen>
      </figure>

      <para>Here the table <emphasis>tbl.r0.s</emphasis> was created to hold IP addresses that belong to the firewall. The rule matches source addresses and also the user ID of the owner using the "user" clause.</para>

      <para>User Service is actually one of the simplest service object types in Firewall Builder, but it provides the facility for a basic per-user control on Linux and BSD machines. This service object can be used in rules with actions that reroute packets ("Route" action) or in the NAT rules, for example to redirect web access via proxy.</para>

    </sect2>

    <sect2 id="custom-service">
      <title>Custom Service</title>

        <para>
  
                  The Custom Service object can be used to inject
                  arbitrary code into the generated firewall
                  script. Any combination of options allowed in the
                  target firewall command line language that does not
                  fit into a strict model of standard service object
                  types can be expressed using the Custom Service
                  object. For example, iptables comes with a
                  collection of modules that adds an ability to match
                  complex combinations of packet parameters or header
                  fields that are not supported by a standard
                  code. One of the modules adds the ability to match
                  any string in the packet's payload which can be
                  quite useful to quickly build firewall rule to block
                  some new protocol that uses non-specific combination
                  of ports and other parameters. This ability is
                  sometimes used to write rules to block network
                  trojans or viruses with known signatures.
                
        </para>
  

        <para>
  
                  The following screenshot represents a Custom Service
                  object that uses the capabilities of
                  the <emphasis>string</emphasis> module. Command line options
                  specific for this module are in the "Code String"
                  field.
                
        </para>
  

        <note><para>
                  Note: The code specified in the Custom Service is
                  used literally; no validation is done either by
                  Firewall Builder GUI or the policy compilers.
                      </para></note>
  

        <figure float="1"><title/><graphic scale="60" fileref="custom_service_1.png"/></figure>

        <para>
  
                  The Custom Service dialog provides the following controls: 
                
        </para>
  

  <itemizedlist>

  <listitem><para>
  Name: This is the name of the object. 
                        </para>
  </listitem>
  

                  

  <listitem><para>
  Platform: This is a pull-down menu that shows a
                  list of all firewall platform targets available in
                  Firewall Builder.
                        </para>
  </listitem>
  

                  

  <listitem><para>
  Code String: This is a line of code in the
                  target firewall language. (This is the heart of the
                  Custom Service object.)
                        </para>
  </listitem>
  

                  

  <listitem><para>
  Protocol Name: Use this if you want to restrict
                    the Custom Service Object to a particular
                    protocol: TCP, UDP, or ICMP. Default is "any". For
                    example, if this field is set to "tcp", then
                    policy compiler for iptables generates command
                    with parameter "-p tcp" and then inserts code
                    defined in the "Code String" field of the custom
                    service object.
                        </para>
  </listitem>
  

                  

  <listitem><para>
  Address Family: Specify IPv4 or IPv6. Policy
                  compilers use information about address family to
                  properly use the object while compiling IPv4 or IPv6
                  rule sets.
                        </para>
  </listitem>
  

                  

  <listitem><para>
  Comments: This is a free-style text field used for comments. 
                        </para>
  </listitem>
  
                </itemizedlist>

  <sect3>
        <title>Using Custom Service Object in Rules</title>

        <para>
  
                  The following example uses iptables module
                  "recent". Quoting from the iptables manual, this module
                  "allows you to dynamically create a list of IP
                  addresses and then match against that list in a few
                  different ways". We can use this module to throttle
                  brute-force ssh scanning attacks where an attacker
                  repeatedly connects to the ssh daemon trying to
                  guess login name and password. The full explanation
                  of how to use Custom Service object in combination
                  with <emphasis>swatch</emphasis> script on Linux to stop these
                  attacks can be found in the Firewall Builder
                  Cookbook (<xref linkend="cookbook" />). Here we focus only on the Custom Service
                  object and iptables rules that can be obtained with
                  it.
                
        </para>
  

        <figure float="1"><title/><graphic scale="60" fileref="custom_service_2.png"/></figure>

        <para>
  
                  The code string defined in this object is "--dport
                  22 -m recent --set". This matches port 22 (ssh),
                  activates the module and adds source address of the
                  packet to the default list maintained by the module.
                
        </para>
  

        <para>
  
                  The second Custom Service object also matches port
                  22 and checks if the address is already on the list
                  and was seen during the past 1 minute twice:
                
        </para>
  

        <figure float="1"><title/><graphic scale="60" fileref="custom_service_3.png"/></figure>

        <para>
  
                  Note that our goal is to match protocol ssh (tcp
                  port 22) and at the same time activate iptables
                  module "recent" and add some parameters for it.
                  Both are done by means of a service object in
                  fwbuilder, however placing two service objects in
                  the "Service" field of a rule joins them by OR. That
                  is, if we were to put TCP service object "ssh" and
                  Custom Service object that defines parameter for
                  module "recent" in the "Service" field of the same
                  rule, we would end up with two iptables commands,
                  one matching tcp port 22 and another trying to use
                  module "recent". Since we need to match both in the
                  same rule, we have to add "--dport 22" to the code
                  defined in the Custom Service object.
                
        </para>
  

        <para>
  
                  Now, the rules using these objects:
                
        </para>
  

        <figure float="1"><title/><graphic scale="60" fileref="custom_service_rule_1.png"/></figure>

        <para>
  
                  Here are the iptables commands generated for these two
                  rules:
                
        </para>
  

  <screen>

# Rule 0 (global)
# 
$IPTABLES -N In_RULE_0
$IPTABLES -A INPUT  -i + -p tcp -m tcp  --dport 22 \
      -m recent --rcheck --seconds 60 --hitcount 2  -j In_RULE_0 
$IPTABLES -A In_RULE_0   -j LOG  --log-level info --log-prefix "RULE 0 -- DENY "
$IPTABLES -A In_RULE_0  -j DROP 
# 
# Rule 1 (global)
# 
$IPTABLES -A INPUT  -i + -p tcp -m tcp  --dport 22 -m recent --set \
      -m state --state NEW  -j ACCEPT 
# 

                </screen>

        <para>
  
                  First, we match port 22 and check if we have seen
                  this source address during the past minute at least 2
                  times. If yes, module "recent" returns a match and the
                  packet matches the first iptables rule. Iptables
                  passes control to the rules in chain "In_RULE_0"
                  where the packet is logged and dropped. If the
                  packet does not match the conditions set for the module
                  "recent", it does not match the first iptables rule
                  and will be inspected by the next one (generated for
                  the original rule #1). If this is the opening packet
                  of a new session, it matches state "NEW" and will be
                  permitted. Since module "recent" was also called in
                  this rule, the source address of the packet was
                  added to the internal table of the module "recent"
                  so it can be used in the previous iptables rule.
                
        </para>
  

        <para>
  
                  Custom Service allows you to inject arbitrary
                  strings into the generated firewall configuration in
                  the place where normally port matching
                  occurs. Another feature in Firewall Builder that
                  also allows for insertion of a code in the generated
                  code is Custom Action. The combination of Custom Service
                  with Custom Action provides for a very flexible
                  system where you can compose pretty much any
                  required configuration line if it is not otherwise
                  supported by the standard means. Suppose instead of
                  just dropping ssh scan connections coming to our
                  system we want to slow them down, thus tying up the 
                  attacker's resources. Iptables has a target just for
                  that called TARPIT. Unfortunately this target
                  is specific for iptables and is absent on other
                  firewalls supported by fwbuilder and it did not make
                  sense to introduce a standard action for it. However,
                  Custom Action is the mechanism we can use to
                  generate iptables command with this target. Here is
                  the rule, the action in it was set to "Custom
                  Action". Double-clicking on the action in the rule
                  opens a dialog with its parameters (if any). Custom
                  Action has one parameter, it is a freestyle string
                  where you enter the code you want to appear in the 
                  generated command:
                
        </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="custom_service_rule_2.png"/></figure>

        <para>
  
                  Here is what we now get when we compile this policy
                  for iptables:
                
        </para>
  

  <screen>

# 
# Rule 0 (global)
# 
$IPTABLES -N In_RULE_0
$IPTABLES -A INPUT  -i + -p tcp -m tcp  --dport 22 \
      -m recent --rcheck --seconds 60 --hitcount 2  -j In_RULE_0 
$IPTABLES -A In_RULE_0   -j LOG  --log-level info --log-prefix "RULE 0 -- CUSTOM "
$IPTABLES -A In_RULE_0 -j TARPIT
# 
# Rule 1 (global)
# 
$IPTABLES -A INPUT  -i + -p tcp -m tcp  --dport 22 -m recent --set \
      -m state --state NEW  -j ACCEPT 
# 

                </screen>

        <para>
  
                  Now the first rule ends up sending the packet to the
                  "TARPIT" target rather than to "DROP", which is what we wanted.
                
        </para>
  </sect3>
    </sect2>
  </sect1>

  <sect1 id="time-interval-objects">
    <title>Time Interval Objects</title>

      <para>Time Interval objects allow you to create a rule that only matches during certain periods of time, such as on weekend days, during work hours, or other periods. Time intervals operate based on the time as known <emphasis>by the firewall device</emphasis>.</para>

      <figure float="1" id="time-interval2">
          <title>Time Interval dialog</title>
              <graphic scale="60" fileref="time-interval2.png" />
        </figure>

      <para>Time intervals can be certain days of the week (only on Mondays, for example), only certain times, and/or only during a certain range of dates. You can combine these options to create an object that represents, for example, Tuesday afternoons from 1 to 3 PM during March of 2011.</para>

<itemizedlist spacing="compact">
          <listitem>
            <para>Name:</para>

            <para>This is the name of the object.</para>
          </listitem>

          <listitem>
            <para>Start date checkbox:</para>

            <para>Indicates that the time interval has a starting date. If this is not checked, the <guilabel>Start date</guilabel> field is inaccessible and is not included in the object.</para>
          </listitem>

          <listitem>
            <para>Start date:</para>

            <para>Indicates the day the time interval will start.</para>
          </listitem>

          <listitem>
            <para>Start time:</para>

            <para>Indicates the beginning of the daily interval. Only applies to days after <guilabel>Start date</guilabel> (if specified) and before <guilabel>End date</guilabel> (if specified) and on indicated days of the week. For example, if <guilabel>Sunday</guilabel> is not checked, then the time interval does not apply on Sundays.</para>
          </listitem>

          <listitem>
            <para>End date checkbox:</para>

            <para>Indicates that the time interval has an ending date. If this is not checked, the <guilabel>End date</guilabel> field is inaccessible and is not included in the object.</para>
          </listitem>

          <listitem>
            <para>End date:</para>

            <para>Indicates the day the time interval will end.</para>
          </listitem>

          <listitem>
            <para>End time:</para>

            <para>Indicates the end of the daily interval. Only applies to days after <guilabel>Start date</guilabel> (if specified) and before <guilabel>End date</guilabel> (if specified) and on indicated days of the week. For example, if <guilabel>Sunday</guilabel> is not checked, then the time interval does not apply on Sundays.</para>
          </listitem>

          <listitem>
            <para>Mon, Tue, Wed, Thu, Fri, Sat, Sun</para>

            <para>Indicates on which days of the week the time interval should be applicable. For example, if <guilabel>Mon</guilabel> is checked and <guilabel>Tue</guilabel> is not, then the time interval object will apply to Mondays, but not Tuesdays.</para>
          </listitem>

          <listitem>
            <para>Comments:</para>

            <para>This is a free-style text field used for comments.</para>
          </listitem>
        </itemizedlist>

	<para>In <xref linkend="time-interval2" />, the object would be valid from the beginning of Dec. 19, 2009 and end the beginning of Jan. 4, 2010. This would hypothetically correspond to a "winter break" at some institution when access to some networks would be restricted.</para>

	<para>Another possibility is to limit recreational activities to non-work hours.</para>

      <figure float="1" id="time-interval1">
          <title>Time Interval rule example</title>
              <graphic scale="50" fileref="time-interval1.png" />
        </figure>

      <para>In this rule, the "quake" protocol is allowed from the internal network after hours and during weekends. Otherwise, the final "deny all" rule in the rule set would prevent it during other times (during work hours).</para>
   </sect1>

   <sect1 id="new-library">
    <title>Creating and Using a User-Defined Library of Objects</title>

      <para>The User library that comes with Firewall Builder is all you need if you're the only one administering firewalls in your enterprise. But, if you have several administrators, each with a different workstation, then you may want to create a user library that you can distribute. That way, user-defined objects only have to be created once, by one person.</para>

      <para>Let's create and distribute a simple user-defined library. Start by selection <guimenuitem>New Object/New Library</guimenuitem> from the <guimenu>Object</guimenu> menu.</para>

      <para>The library pull-down menu switches to <guilabel>New Library</guilabel>, which is empty by default, except for the standard folders.</para>

      <figure float="1" id="user-defined-library1">
          <title>A new, empty user-defined library</title>
              <graphic scale="70" fileref="user-defined-library1.png" />
        </figure>

      <para>Click on the New Library icon to bring up the library dialog.</para>

      <figure float="1" id="user-defined-library2">
          <title>Library dialog</title>
              <graphic scale="70" fileref="user-defined-library2.png" />
        </figure>

      <para>The Library dialog has three controls: Name, Color, and Comments. Enter a new name for the library in the Name field. (Here we are calling it ACME Library.) If you want, you can also specify a color for the library. This helps you notice when you're in that particular library. In this case, we have set the color to a shade of blue.</para>

      <figure float="1" id="user-defined-library3">
          <title>ACME library with blue background</title>
              <graphic scale="70" fileref="user-defined-library3.png" />
        </figure>

      <para>Use the normal object creation procedures to create objects in the library. Here we have created a Web server object with a interface that has a dynamically assigned IP address. We've also created a network object for the 192.168.3.0/24 subnet.</para>

      <figure float="1" id="user-defined-library4">
          <title>Library with user-created objects</title>
              <graphic scale="70" fileref="user-defined-library4.png" />
        </figure>

      <para>Click <guimenuitem>File/Save</guimenuitem> to save the object file.</para>

      <para>To export the library to a file, select <guimenuitem>File/Export Library</guimenuitem>. The following dialog appears:</para>

      <figure float="1" id="user-defined-library5">
          <title>Export your library</title>
              <graphic scale="70" fileref="user-defined-library5.png" />
        </figure>

      <para>If you want to make the library read-only, leave the <guilabel>Make exported libraries read-only</guilabel> checked. Otherwise, uncheck it.</para>

      <para>Click <guibutton>OK</guibutton>.</para>

      <para>A file system Save dialog appears. Here you can specify a name and location for the file. Be sure the file has a <emphasis>.fwl</emphasis> file extension.</para>

      <figure float="1" id="user-defined-library6">
          <title>Save dialog box</title>
              <graphic scale="60" fileref="user-defined-library6.png" />
        </figure>

      <para>You can now move or email the library to someone else.</para>

      <para>To load a library, copy the file to the directory where you have Firewall Builder store your object files. Then, select <guimenuitem>Import Library</guimenuitem> from the Firewall Builder <guimenu>File</guimenu> menu. (You may have to restart Firewall Builder to get it to locate the file. Until then, the "Import Library" option may be grayed out.)</para>
      
     <para>You can now use this library like any other library. Keep in mind that changes to one copy of the user-defined library has no effect on other copies. To propagate changes, you have to redistribute the library.</para>
   </sect1>

   <sect1 id="find-replace">
    <title>Finding and Replacing Objects</title>

      <para>Imagine you have an access policy that looks something like this:</para>

      <figure float="1" id="find-replace1">
          <title>Policy before the Find/Replace</title>
              <graphic scale="70" fileref="find-replace1.png" />
        </figure>

      <para>Further, imagine that you are reassigning all the IP addresses in 192.168.2.0/24 to be in the 192.168.3.0/24 subnet and that you need to modify the firewall rules to match.</para>

      <para>One way to handle this is to manually browse through every rule in your firewall, removing the .2.0 addresses where you find them and replacing them with the equivalent .3.0 addresses. Or, you could do a Find and Replace.</para>

      <para>Select <guimenuitem>Find Object</guimenuitem> from the <guimenu>Object</guimenu> menu to open the Find and Replace dialog, shown here:</para>

            <figure float="1" id="find-replace2">
          <title>Find/Replace dialog</title>
              <graphic scale="50" fileref="find-replace2.png" />
        </figure>

      <para>To replace every net-192.168.2.0 object with the net-192.168.3.0 object, first create the new network object. Then, drag (or Copy/Paste) a net-192.168.2.0 object into the <guilabel>Find object</guilabel> field and the net-192.168.3.0 object into the <guilabel>Replace object</guilabel> field. Then, set the <guilabel>Scope for search and replace</guilabel> pull-down menu to <guimenuitem>policy of the opened firewall</guimenuitem>, as shown here:</para>

            <figure float="1" id="find-replace3">
          <title>Objects to find and replace</title>
              <graphic scale="50" fileref="find-replace3.png" />
        </figure>

      <para>Click <guibutton>Replace All</guibutton> to replace all instances.</para>

            <figure float="1" id="find-replace4">
          <title>Policy with objects replaced</title>
              <graphic scale="60" fileref="find-replace4.png" />
        </figure>

      <para>The Find object dialog has a number of controls you can use to constrain your searches:</para>

      <itemizedlist>
        <listitem>
            <para>Object parameter pull-down menu</para>

            <para>Allows you to specify how you search for objects. You can search by Name (usable on all objects), Address (usable on all addressable objects), TCP/UDP port (usable on TCP and UDP objects), Protocol Number (usable on IP service objects) and ICMP type (usable on ICMP service objects).</para>
          </listitem>

          <listitem>
            <para>Text field</para>

            <para>The text field is populated automatically if you drag an object into the Find object field. Otherwise, you can type the text in manually.</para>
          </listitem>

          <listitem>
            <para>Use regular expressions</para>

            <para>Checking the <guilabel>Use regular expressions</guilabel> checkbox causes the text field to be interpreted as a Perl regular expression. You can only do searches based on a regular expression. You cannot do replaces based on a regular expression.</para>
          </listitem>

          <listitem>
            <para>Search field</para>

            <para>Drag an object into the field to find instances of that object.</para>
          </listitem>

          <listitem>
            <para>Replace field</para>

            <para>Drag an object into the field to use it as the replacement object in a search and replace.</para>
          </listitem>

          <listitem>
            <para>Scope of search and replace</para>

            <para>Allows you to specify whether a search or search and replace will cover just the object tree, the tree and the policies of all firewalls in the object file, just the policies in the object file, or just the current open policy.</para>
          </listitem>

          <listitem>
            <para>Buttons</para>

            <para>The <guibutton>Next</guibutton> button finds the next instance of the object. It does not do a replace. <guibutton>Replace All</guibutton> replaces all instances of the object in the given scope. <guibutton>Replace</guibutton> replaces the current instance. <guibutton>Replace &amp; Find</guibutton> replaces the current instance and jumps to the next one.</para>
          </listitem>
        </itemizedlist>

   </sect1>
  </chapter>


  <!-- ***************************************************************
  -->

  <chapter id="network-discovery">
    <title>Network Discovery: A Quick Way to Create Objects</title>

    <para>One of the distinguishing features that Firewall Builder provides is
    support for automated object creation. This helps populate the objects
    tree for large networks with lots of hosts and subnets. What might take hours to do manually, the
    Discovery Druid wizard can help you do in minutes.</para>

    <para>To start the Discovery Druid, select 
    <guimenuitem>Tools</guimenuitem>/<guimenuitem>Discovery
    Druid</guimenuitem>.</para>

    <para>The Discovery Druid supports three main methods for automated object
    creation:</para>

    <para><itemizedlist spacing="compact">
        <listitem>
          <para>Reading file /etc/hosts</para>
        </listitem>

        <listitem>
          <para>Network discovery using SNMP queries</para>
        </listitem>

        <listitem>
          <para>Import the configuration of a firewall or router</para>
        </listitem>
      </itemizedlist></para>

    <para>You choose the method on the first page of the Druid ( <xref
    linkend="discovery-page1" />. )</para>

    <figure float="1" id="discovery-page1">
      <title>Calling The Object Discovery Druid</title>
          <graphic scale="70" fileref="discovery-druid1.png" />
    </figure>

    <para>Just check the radio-button next to the method you want to use and
    click <guibutton>'Next</guibutton>.</para>

    <sect1>
      <title>Reading the /etc/hosts file</title>

      <para>This method imports the host records present in the standard
      <emphasis>/etc/hosts</emphasis> file or any other file that contain
      records in the following format (this format is actually described in
      the manual page hosts(5)).</para>

      <para>IP_Address host_name</para>

      <para>The IP address must be separated from the host name with any
      number of spaces or tab symbols. Lines starting with '#' are considered
      comments and are ignored.</para>

      <para>When you choose the import from /etc/hosts on the first page, the
      Druid asks you for the file path and name on the next page. Once that
      information is entered, it reads the contents of that file and presents
      a table of new networks (<xref linkend="discovery-hosts-2" />).</para>

      <figure float="1" id="discovery-hosts-2">
        <title>Creating networks using gathered information</title>
            <graphic scale="70" fileref="discovery-druid8.png" />
      </figure>

      <para>This part of the druid is the same for all discovery methods.</para>

      <para>The left column shows the networks that were discovered. The right column shows the network objects that will be created. To start with, the right column is empty.</para>

      <para>This page of the Druid also has the following buttons:</para>

      <itemizedlist spacing="compact">
          <listitem>
            <para><guibutton>Select All</guibutton></para>

            <para>Selects all records in the column.</para>
          </listitem>

          <listitem>
            <para><guibutton>Unselect All</guibutton></para>

            <para>Deselects all records in the column.</para>
          </listitem>

          <listitem>
            <para><guibutton>Filter</guibutton></para>

            <para>Brings up a filter dialog. Filtering helps manage long lists
            of objects.</para>
          </listitem>

          <listitem>
            <para><guibutton>"Remove Filter"</guibutton></para>

            <para>Removes the currently applied filter and shows all records
            in the table.</para>
          </listitem>
        </itemizedlist>

      <para>The Druid can filter records in the table either by their address,
      by their name, or by both. To filter by address enter part of it in the
      "Address" field. The program compares the text entered in the filter
      dialog with an address in the table and shows only those records whose
      address starts with the text of the filter. For example, to only filter
      out hosts with addresses on the net 10.3.14.0 we could use the filter
      "10.3.14". Likewise, to remove hosts "bear" and "beaver" (addresses
      10.3.14.50 and 10.3.14.74) we could use the filter "10.3.14.6". Note
      that the filter string does not contain any wildcard symbols like "*".
      The filter shows only records that have addresses which literally match
      the filter string.</para>

      <para>Filtering by the object name uses the POSIX regular expressions
      syntax described in the manual page regex(7). For example, to find all
      records whose names start with "f" we could use the regular expression
      "^f". The "^" symbol matches the beginning of the string, so this
      regular expression matches any name that starts with "f". To find all
      names that end with "somedomain.com", we could use the regular
      expression ".*somedomain.com$"</para>

      <para>Once you have reviewed the discovered networks, decide which ones you want to turn into Network objects. Then, copy those networks to the right column.</para>

      <para>To populate the right column with objects, select the networks you want, then click the right arrow (--&gt;) to put them in the right column.</para>

      <figure float="1" id="discovery-hosts-2a">
        <title>Creating networks using gathered information (more)</title>
            <graphic scale="70" fileref="discovery-druid9.png" />
      </figure>

      <para>Click <guibutton>Next</guibutton>. The discovered Hosts list displays:</para>

      <figure float="1" id="discovery-hosts-2b">
        <title>Creating Hosts using gathered information</title>
            <graphic scale="70" fileref="discovery-druid10.png" />
      </figure>

      <para>Again, populate the right column with the objects you want to create:</para>

      <figure float="1" id="discovery-hosts-2c">
        <title>Creating Hosts using gathered information (more)</title>
            <graphic scale="70" fileref="discovery-druid11.png" />
      </figure>

      <para>Click <guibutton>Next</guibutton>. The final object list displays:</para>

      <figure float="1" id="discovery-hosts-2d">
        <title>List of Objects</title>
            <graphic scale="70" fileref="discovery-druid12.png" />
      </figure>

      <para>Here you can specify which type of object will be created for each discovered item: Address, Host, or Firewall. Here we are changing the object "sveasoft (10.3.14.202)" from a host to a firewall:</para>

      <figure float="1" id="discovery-hosts-2e">
        <title>Specify type of object</title>
            <graphic scale="70" fileref="discovery-druid13.png" />
      </figure>

      <para>Click <guibutton>Next</guibutton>. The target library control appears:</para>

       <figure float="1" id="discovery-hosts-2f">
        <title>Target Library</title>
            <graphic scale="70" fileref="discovery-druid14.png" />
      </figure>

      <para>Here you can specify which library the objects will appear in. Normally this would be User, unless you have created a user-defined library. Click <guibutton>Next</guibutton>.</para>

      <para>The wizard finishes processing, and your new objects appear in your library:</para>

       <figure float="1" id="discovery-hosts-2g">
        <title>Target Library</title>
            <graphic scale="70" fileref="discovery-druid15.png" />
      </figure>
    </sect1>

    <sect1>
      <title>Network Discovery</title>

      <figure float="1" id="discovery-snmp-seed">
        <title>Initial Parameters for the Network Discovery program</title>
            <graphic scale="70" fileref="discovery-druid2.png" />
      </figure>

      <para>The Network discovery program (sometimes referred to as the
      "Network Crawler") needs a host to start from. This host is called the
      "seed host"; you enter it in the first page of the Druid (<xref
      linkend="discovery-snmp-seed" />). The crawler implements the following
      algorithm (this is a somewhat simplified explanation):</para>

      <para>First, it runs several SNMP queries against the seed host trying
      to collect the list of its interfaces and its ARP
      and routing tables. This host is then added to the table of discovered
      network objects, together with its interfaces, their addresses and
      netmasks, and the host's "sysinfo" parameters. Then the crawler analyses
      the routing table of that host; this allows it to discover the networks
      and subnets, which in turn are also added to the list of discovered
      objects. Then it analyses the ARP table, which holds MAC and IP
      addresses of neighboring hosts. It takes one host at a time from this table and repeats the same algorithm, using the new host as a seed host. When it
      pulls an ARP table from the next host, it discards entries that describe
      objects it already knows about. However if it finds new entries, it
      tries them as well and thus travels further down the network. Eventually
      it will visit every host on all subnets on the network.</para>

      <para>This algorithm relies on hosts answering to the SNMP queries. If
      the very first host (the "seed" host) does not run SNMP agent, the
      crawler will stop on the first run of its algorithm and won't find
      anything. Therefore it is important to use a host which does run SNMP
      agent as a "seed" host. Even if most of the hosts on the network do not
      run SNMP agents, but a few do, the crawler will most likely find all of
      them. This happens because it discovers objects when it reads the ARP
      tables from the host which answers; so even if discovered hosts do not
      answer to SNMP queries, the crawler already found them anyway.</para>

      <para>One of the ways to limit the scope of the network that the crawler
      will visit is to use the "Confine scan to the network" parameter. You
      need to enter both a network address and a netmask; the crawler will
      then check if the hosts it discovers belong to this network and if they
      do not, discard them.</para>

      <figure float="1" id="discovery-snmp-options">
        <title>Parameters for Network Discovery: Page 1</title>
            <graphic scale="70" fileref="discovery-druid3.png" />
      </figure>

      <figure float="1" id="discovery-snmp-options2">
        <title>Parameters for Network Discovery: Page 2</title>
            <graphic scale="70" fileref="discovery-druid4.png" />
      </figure>

      <para>There are a few settings that affect the crawler's algorithm (see
      <xref linkend="discovery-snmp-options" /> and <xref
      linkend="discovery-snmp-options2" />). Here is the list:</para>

      <para><itemizedlist spacing="compact">
          <listitem>
            <para>Run network scan recursively</para>

            <para>As was described above, the crawler starts with the "seed"
            host and then repeats its algorithm using every discovered host as
            a new "seed". If this option is turned OFF, then the crawler runs
            its algorithm only once and stops.</para>
          </listitem>

          <listitem>
            <para>Follow point-to-point links</para>

            <para>If a firewall or router has a point-to-point interface
            (for example, PPP interface), then the crawler can automatically
            calculate the IP address of the other side of this interface. It
            then continues the discovery process by querying a router on the
            other side. Very often, the point-to-point link connects the
            organization's network to an ISP and you are not really interested
            in collecting data about your ISP network. By default crawler
            won't cross point-to-point links, but this option, if activated,
            permits it.</para>
          </listitem>

          <listitem>
            <para>Include virtual addresses</para>

            <para>Sometimes servers or routers have more than one IP address
            assigned to the same interface. If this option is turned on, the
            crawler "discovers" these virtual addresses and tries to create
            objects for them.</para>
          </listitem>

          <listitem>
            <para>Run reverse name lookup queries to determine host
            names</para>

            <para>If the host discovered by the crawler answers to SNMP
            queries, it will report its name, which the crawler will use to
            create an object in Firewall Builder. However, if the host does
            not answer the query, the crawler cannot determine its name and
            only knows its IP address. The crawler can use DNS to back-resolve
            such addresses and determine host names if this option is turned
            ON.</para>
          </listitem>

          <listitem>
            <para>SNMP (and DNS) query parameters</para>

            <para>You must specify the SNMP "read" community string which will
            be used for SNMP queries. You can also specify the number of
            retries and a timeout for the query. (The number of retries and timeout parameters also apply to DNS and reverse DNS queries.)</para>
          </listitem>
        </itemizedlist></para>

      <para>Once all parameters are entered, the crawler actually gets to
      work, which may take a while. Depending on the size of the network and
      such parameters as the SNMP timeout value, scanning may take minutes or
      even hours. The progress of the scanner can be monitored on the page in
      the Druid (<xref linkend="discovery-snmp-crawler" />) and (<xref linkend="discovery-snmp-crawler2" />). You can always
      stop the crawler using the <guibutton>"Stop network scan"</guibutton>
      button. Data does not get lost if you do this as the Druid will use
      whatever objects the crawler discovered before you stopped it.</para>

      <figure float="1" id="discovery-snmp-crawler">
        <title>The SNMP crawler status</title>
            <graphic scale="70" fileref="discovery-druid6.png" />
      </figure>

      <figure float="1" id="discovery-snmp-crawler2">
        <title>The SNMP crawler status (more)</title>
            <graphic scale="70" fileref="discovery-druid7.png" />
      </figure>

      <para>The <guibutton>"Save scan log to file"</guibutton> button saves
      the content of the progress window to a text file and is mostly used for
      troubleshooting and bug reports related to the crawler.</para>

      <para>If the crawler succeeded and was able to collect information it
      needed to create objects, you can switch to the next page where you
      choose and create objects. That page is the same as the one shown in
      <xref linkend="discovery-hosts-2" />.</para>
    </sect1>

    <sect1>
      <title>Policy Importer</title>
	<para>The Policy Importer is described in <xref linkend="policy-importer" />.</para>
    </sect1>
  </chapter>

  <!-- *************************************************************** -->

  <chapter id="firewall-policies">
    <title>Firewall Policies</title>

    <sect1 id="policies-and-rules">
      <title>Policies and Rules</title>

      <para>Each firewall object has several sets of rules associated
      with it: Access Policy (just "Policy" in the GUI), Network
      Address Translation (NAT), and Routing rules. Rules in the
      access policy control access to and from the firewall machine
      and the machines behind it.  NAT rules describe address and port
      transformations that the firewall should make to packets flowing
      through it. Routing rules establish static routes in the
      firewall.</para>

      <para>Firewall software varies widely in the way it can process
      packets.  For example, some firewalls perform address and port
      transformations first and then apply policy rules, while some
      others do it the other way around. There are many other
      variations and features specific to particular
      implementations. In Firewall Builder though, you work with an
      abstract firewall that looks and behaves the same regardless of
      the target firewall platform. You can build and install firewall
      polices for one platform, then switch the target and use the
      exact same policies to generate rules for an entirely different
      platform. (This assumes both platforms support the features you
      need.)</para>

      <para>Firewall Builder compensates for differences in
      implementation between firewall platforms.  For example, Cisco
      PIX applies its Access List rules to the packet before it
      performs address and port transformations according to the NAT
      rules. As a result, a policy rule that controls access to a
      server behind the firewall doing NAT should be written using the
      firewall object instead of the server object. The meaning of
      such a rule is not obvious at a glance since you have to keep in
      mind all the NAT rules as well as remember that this policy rule
      controls access not to the firewall machine, but rather to the
      server behind it. Firewall Builder compensates for variations
      like this by using smart algorithms to transform rules defined
      in the GUI into rules that achieve the desired effect in the
      target firewall platform. Using Firewall Builder, you can write
      your rules as if NAT translation will happen before the access
      rules are applied.</para>

      <figure float="1" id="policies-seq">
        <title>The sequence in which NAT and Policy rules are applied to the packet
        in Firewall Builder</title>
            <graphic width="150" fileref="policies-seq.png" />
      </figure>

      <para><xref linkend="policies-seq" /> represents the logical
      sequence in which rules defined in Firewall Builder affect the
      network packet. This diagram describes an abstract firewall that
      Firewall Builder represents for the user. In some cases the
      target firewall may work the same way, in some other cases it
      won't. Either way, you can build your rules as if all your
      firewalls, regardless of platform, work like
      <xref linkend="policies-seq" />.
      </para>

    </sect1>

    <sect1 id="global-policy">
      <title>Firewall Access Policy Rulesets</title>

      <figure float="1" id="global-policy1">
        <title>Access Policy</title>
            <graphic scale="60" fileref="policy_example_1.png" />
      </figure>

      <para>The main Firewall access policy consists of a set of
      rules. Packets are analysed by comparing their parameters with
      rules in the policy, one after the other, from top to bottom.
      The first rule that matches the packet has
      it's <guilabel>Action</guilabel> applied to the packet.</para>

      <para>Each rule includes a standard set of parameters,
      or <emphasis>Rule Elements</emphasis>, that are used for
      comparison with the packet. Rule elements include "Source",
      "Destination", "Service", "Interface", "Direction", and
      "Time". For example, if a packet entering the firewall has a
      source address that matches the object in
      the <guilabel>Source</guilabel> field of the rule, its
      destination address matches the object
      in <guilabel>Destination</guilabel>, its protocol and port
      numbers match the object in <guilabel>Service</guilabel>, the
      interface it passes through matches
      the <guilabel>Interface</guilabel> field, its direction matches
      that specified in <guilabel>Direction</guilabel>, and it's time
      matches <guilabel>Time</guilabel>, then the firewall will take
      action, specified in the <guilabel>Action</guilabel> field of
      the matching rule. Of course, a field with "Any" or "All" in it
      will match all packets for that field.</para>

      <para>
        For example, in <xref linkend="global-policy1" />, rule #0 is
        "anti-spoofing", it denies all packets coming throuh the
        outside interface with source address claiming to be that of
        the firewall itself or internal network it protects. This rule
        utilizes interface and direction matching in addition to the
        source address. Rule #2 says that connection from the internal
        network (object <emphasis>net-192.168.1.0</emphasis>) to the
        firewall itself (object <emphasis>firewall</emphasis>)
        using <emphasis>ssh</emphasis> is allowed
        (action <emphasis>Accept</emphasis>). The "Catch all" rule #6
        denies all packets that have not been matched by any rule
        above it. The access policy in <xref linkend="global-policy1"
        /> is built to allow only specific services and deny
        everything else, which is a good practice.
      </para>

      <para>Access Policy rules represent access control because they
      define which packets will be permitted and which will be
      denied. Access Policy rules operate on the packet's source and
      destination addresses and protocol parameters. These rules work
      regardless of the interface and direction of the packet, unless
      a particular interface or direction, or set of interfaces, is
      assigned to the rule.</para>

      <sect2>
	<title>Source and Destination</title>

	<para>
          The <guilabel>Source</guilabel>
	  and <guilabel>Destination</guilabel> fields allow you to
	  match a packet to a rule based on source and destination IP
	  address.
        </para>

	<para>
          Either field may be set to "any", which means that the
	  packet will match on that field regardless. Or, you can set
	  a field to a particular IPv4 address (Address object), IPv6
	  address (Address IPv6 object), the IP address or addresses
	  associated with all interfaces of a host (Host object), a
	  range of IP addresses (Address Range object), all the
	  addresses in a particular subnet (Network object), an
	  address configured as DNS "A" record for a given host name
	  (DNS Name object), or a group of any of the above. You can
	  place more than one object in either field,
	  too. <xref linkend="addressable-objects" /> has more
	  detailed information on these address objects.
        </para>

	<para>
          In addition, you can "negate" an object by dragging it to a
	  field, then selecting <guimenuitem>Negate</guimenuitem> from
	  the right-click menu. In
	  <xref linkend="policies-rule-negate-rfc1918" />, the RFC
	  1918 address range object has been negated, so the rule
	  matches any destination address that
	  is <emphasis>not</emphasis> part of private address
	  space.
        </para>

      <figure float="1" id="policies-rule-negate-rfc1918">
        <title>Destination matches any IP that is <emphasis>not</emphasis> an RFC 1918 address</title>
            <graphic scale="60" fileref="policy_rule_negate_rfc1918.png" />
      </figure>
      </sect2>

      <sect2>
	<title>Service</title>

	<para>
          The <guilabel>Service</guilabel> field is also used to
	  match packets to rules. Use Service Objects
	  (<xref linkend="working-with-services" />) to specify what
	  services should be matched.
        </para>

        <para>
          As in the Source and Destination fields, you can
          "negate" an object by dragging it to a field, then
          selecting <guimenuitem>Negate</guimenuitem> from the
          right-click menu.
        </para>

      </sect2>

      <sect2>
	<title>Interface</title>

	<para>
          By default, all rules created in Firewall Builder affect all
	  firewall interfaces, regardless of the target
	  platform. However, sometimes you want to assign a rule to a
	  particular interface, or set of interfaces, only. To
	  populate this field, drag an interface from the firewall
	  object.
        </para>

	<para>
          If you also want to assign a "direction" to the rule, use
          the next field.
        </para>

	<para>
          This field applies to <emphasis>firewall</emphasis>
	  interfaces only, not host interfaces.
        </para>

      </sect2>

      <sect2 id="direction">
        <title>Direction</title>

        <para>
          The "direction" for a rule is defined with respect to the
          firewall machine, not to the network behind it. For example,
          packets that leave the internal network through the firewall
          are considered "inbound" on firewall's internal interface
          and "outbound" on its external interface. Likewise, packets
          that come from the Internet are "inbound" on the firewall's
          external interface and "outbound" on its internal
          interface. <xref linkend="f-directions" /> illustrates
          directions for packets entering or exiting the firewall
          interface.
        </para>

        <figure float="1" id="f-directions">
          <title>Directions</title>
              <graphic scale="70" fileref="directions.png" />
        </figure>
      </sect2>

      <sect2 id="action">
        <title>Action</title>

	<para>
          The Action is the action taken on a rule that matches on
	  the Source, Destination, Service, Interface, Direction, and
	  Time fields.
        </para>

        <para>
          The policy rule action can be one of the options listed
          below. Not all firewalls support all options, but the GUI
          will only allow options that are valid for the indicated
          firewall target. In addition, the same action may have a
          different name on different platforms.
        </para>

	<para>
          Some actions can have parameters. To set a parameter for an
	  action, first select the action, then double-click on the
	  icon. (You can also right-click and
	  select <guimenuitem>parameters</guimenuitem>.) The
	  parameters dialog appears:
        </para>

        <figure float="1" id="action-parameters-reject">
          <title>Parameter options for the Reject action</title>
              <graphic scale="70" fileref="action-parameters-reject.png" />
        </figure>


        <itemizedlist spacing="compact">
          <listitem>
            <para>Accept:</para>

            <para>
              Allows the packet through the firewall. No
              subsequent rules are applied. This action has no
              parameters.
            </para>
          </listitem>

          <listitem>
            <para>Deny:</para>

            <para>
              Silently drops the packet. No subsequent rules are
              applied. This action has no parameters.
            </para>
          </listitem>

          <listitem>
            <para>Reject:</para>

            <para>
              Packet is dropped and an appropriate message is sent
              back to the sender. No subsequent rules are
              applied. This action has a parameter that lets you
              specify how the firewall reacts to the packet. Parameter
              options include TCP RST and a number of ICMP
              messages.
            </para>
          </listitem>

          <listitem>
            <para>Accounting/Count:</para>

            <para>
              Counts packets that match the rule, but makes no
	      decision on the packet. Even if the packet matches, the
	      inspection process continues with other rules below
	      it. This action has a parameter for specifying the rule
	      name for accounting.
            </para>
          </listitem>

          <listitem>
            <para>Queue/Pipe:</para>

            <para>
              Passes the packet to a user space process for
              inspection. It is translated into QUEUE for iptables and
              "divert" for ipfw. This action is only supported by
              compilers for iptables and ipfw. This action has no
              parameters.
            </para>
          </listitem>

          <listitem>
            <para>Tag/Mark:</para>

            <para>
              Associates a tag with the packet. The tag can later be
              inspected using service object TagService. This action
              is translated into MARK target with
              corresponding --set-mark parameter and optionally
              additional an rule with a CONNMARK --save-mark target
              for iptables. If the option that activates CONNMARK
              target is used, the compiler also adds a rule at the
              very top of the policy to restore the mark. Rules are
              placed in INPUT,OUTPUT and FORWARD chain of the "mangle"
              table, which ensures that DNAT happens before rules in
              the mangle table see the packet. The PREROUTING chain in
              the mangle table is executed before the PREROUTING chain
              in the NAT table, so placing tagging rules in the
              PREROUTING chain would make them fire before DNAT. The
              POSTROUTING chain of the mangle table, as well as its
              FORWARD and OUTPUT chains, work before corresponding
              chains of the NAT table. In all cases the goal is to
              make sure DNAT rules process the packet before, and SNAT
              rules process it after, filtering and tagging
              rules.
            </para>

	    <para>
              For PF this action is translated into tag. Supported
	      only by compilers for iptables and PF. This action's
	      parameter lets you specify which TagService service
	      object to apply to the matching packet.
            </para>
          </listitem>

          <listitem>
            <para>Classify:</para>

            <para>
              Allows the firewall to define a QoS class for the packet
              that matches the rule. It is translated into CLASSIFY
              for iptables, with parameter --set-class. For PF it is
              translated into "queue". The compiler for ipfw can use
              "pipe", "queue" or "divert" depending on how the action
              is configured in the GUI. This action is only supported
              by compilers for iptables, PF and ipfw. This action has
              a parameter that lets you specify a Classify
              string.
            </para>
          </listitem>

          <listitem>
            <para>Custom:</para>

            <para>
              Allows you to specify an arbitrary piece of code to be
              used in place of an action. Supported by compilers for
              iptables, ipf and ipfw. A parameter lets you specify the
              string.
            </para>
          </listitem>

          <listitem>
            <para>Branch/Chain/Anchor:</para>

            <para>
              Used to branch to a different rule set. It works on
              target platforms that provide suitable syntax and allow
              control to return to the higher level rule set if the
              branch cannot make a final decision about the
              packet. For iptables this action is translated into a
              user-defined chain. The name of the chain is the name of
              the branch chosen by the administrator. For PF this
              action is translated into an anchor with the same name
              as the branch rule set. This action is only supported by
              compilers for iptables and PF. A parameter lets you
              specify which other rule set to branch into.
            </para>
          </listitem>

          <listitem>
            <para>Routing:</para>

            <para>
              Makes the firewall route matching packets through a
              specified interface or a gateway. This action is
              translated into ROUTE target for iptables and route
              option for PF and ipfilter. Compilers for PF and
              ipfilter support "fastroute", "route-to", "reply-to" and
              "dup-to" options. Parameters let you change the inbound
              and outbound interface and route the packet through a
              specified gateway. You can also tell the firewall to
              continue inspecting the packet after a match, and you
              can tell the firewall to make these changes to
              a <emphasis>copy</emphasis> of the packet while allowing
              the original packet to proceed normally.
            </para>
          </listitem>

          <listitem>
            <para>Continue:</para>

            <para>
              Essentially an empty action. Can be used when you want
              to assign an option, such as logging, to a match but
              take no other action in that rule. This action has no
              parameters.
            </para>
          </listitem>
        </itemizedlist>

        <figure float="1" id="actions">
          <title>Rule Actions</title>
              <graphic scale="70" fileref="actions.png" />
        </figure>
      </sect2>

      <sect2>
	<title>Time</title>

	<para>
          The <guilabel>Time</guilabel> field allows you to restrict a
	  match to a particular time
	  interval. <xref linkend="time-interval-objects" /> has
	  information on creating and using Time Interval objects in a
	  rule.
        </para>

      </sect2>

      <sect2 id="options">
	<title>Options</title>

	<para>
          The <guilabel>Options</guilabel> field allows you to specify
	  certain options with regard to packets that match the
	  rule. Almost all platforms have options related to logging,
	  and some platforms have more extensive
	  options. Click <guibutton>Help</guibutton> in the Options
	  dialog for platform-specific help.
        </para>

	<para>
          If the options of a particular rule have been changed from
	  their default, a <inlinegraphic scale="70"
	  fileref="option-icon.png"/> appears in the Option field for
	  that rule. Keep in mind that not all rules have the same
	  default options. For example, by default a Deny rule is
	  stateless, because there is no reason to keep state on a
	  connection that won't be allowed. So, if you turn on state
	  for a Deny rule, you'll see the icon.
        </para>

	<para>
          An Accept rule has the opposite behaviour. By default, state
	  is kept for Accept rules, so no icon appears when state is
	  on. If you turn state keeping off, in other words, if you
	  change the default behaviour for that rule, then the icon is
	  displayed.
        </para>

      </sect2>

      <sect2>
	<title>Working with multiple policy rule sets</title>

	  <para>
            Every Firewall object created in Firewall Builder has a
	    single Policy rule set to start. For many firewalls, this
	    is all you need. However, with Firewall Builder, you can
	    create multiple access policy rule sets, and, if you
	    platform supports it, branch between them. This can help
	    you modularize your policy.
          </para>

	  <para>
            Here we have Firewall object "fw" with three policy rule
	    sets, Policy, Policy_2 and mgmt:
          </para>

          <figure float="1" id="policy-rulesets1">
            <title>Firewall with more than one Policy rule set</title>
            <graphic scale="70" fileref="policy-rulesets1.png" />
          </figure>

	<para>
          To create an additional rule set, right-click on the
	  Firewall object in the tree and select <guimenuitem>Add
	  Policy Rule Set</guimenuitem>.
        </para>

	<para>
          All Policy rule sets have configurable parameters. To see a
	  Policy rule set's parameters, double-click on it in the tree
	  to open it in the editor.
        </para>

        <figure float="1" id="policy-rulesets2">
          <title>Policy Rule Set Dialog (iptables)</title>
          <graphic scale="70" fileref="policy-rulesets2.png" />
        </figure>

	<para>
          This dialog has
	  a <guilabel>Name</guilabel>, <guilabel>IPv4/IPv6
	  setting</guilabel> and a <guilabel>Top ruleset</guilabel>
	  checkbox. For iptables firewalls, there is also a pair of
	  radio buttons that indicates whether the policy should
	  affect <guilabel>filter+mangle</guilabel> tables or
	  just <guilabel>mangle</guilabel> table.
        </para>

	<para>
          The IPv4/IPv6 pull-down menu lets you select whether the
	  rule set should be compiled for IPv4 only (ignoring any
	  IPv6-related rules), IPv6 only (ignoring any IPv4-related
	  rules), or for both IPv4 and IPv6. If both IPv4 and IPv6 are
	  selected, the compiler "does the right thing" and puts each
	  rule into the correct part of the configuration.
        </para>

        <para>
          Only one rule set can be tagged as the "top" rule set. The
          "top" rule set is the primary rule set that is assigned to
          the device. Only one rule set of each type, can be marked as
          "top". The "top" rule set is always used (if it has any
          rules). Other rule sets are only used if they are the
          targets of branching. (In Firewall Builder 3.X, only the
          Policy rule set can branch.)
        </para>

      <itemizedlist>
          <listitem>
            <para>iptables: rules defined in the "top" rule set will
            go into built-in chains INPUT,OUTPUT,FORWARD. Rules
            defined in rule sets where this checkbox is not checked go
            into a user-defined chain with the same name as the rule
            set.</para>
          </listitem>

          <listitem>
            <para>PF: rules defined in the rule set with <guilabel>top
            rule set</guilabel> checkbox turned off go into an anchor
            with the name of the rule set.</para>
          </listitem>

          <listitem>
            <para>Cisco IOS access lists: if the <guilabel>top rule
            set</guilabel> checkbox is turned off, the rules go into
            access list with the name prefixed with the name of the
            rule set; this access list will not be assigned to
            interfaces via "ip access-group" command. Rulesets with
            checkbox <guilabel>top rule set</guilabel> checked
            generate ACLs with names consisting of the shortened name
            of interface and direction abbreviation ("in" or
            "out"). Only these lists are assigned to
            interfaces.</para>
          </listitem>
        </itemizedlist>

	<para>You can fork processing between rule sets with the
	"Branch/Chain/Anchor" (depending on platform) Action in a
	rule. This rule causes packets headed for the "fw-mgmt" host
	to be passed to the "mgmt" rule set.</para>

        <figure float="1" id="policy-rulesets3">
          <title>Passing a packet to the "mgmt" rule set</title>
              <graphic scale="70" fileref="policy-rulesets3.png" />
        </figure>

	<para>A packet directed to the "mgmt" rule set leaves the main
	rule set and begins matching against rules in the "mgmt" rule
	set. If it matches in the "mgmt" rule set, then that action is
	taken. If it does not match in the "mgmt" rule set, then
	processing is passed back to the calling rule set.</para>
      </sect2>
    </sect1>

    <sect1 id="nat">
      <title>Network Address Translation Rules</title>

      <note><para>As with Access Policy rule sets, you can create
      multiple NAT rule sets. However, in Firewall Builder 3.X, you
      cannot branch between the rule sets. Only the rule set marked as
      "top" is used.</para></note>

      <sect2>
        <title>Basic NAT Rules</title>
				
	<para>Address translation is useful when you need to provide
	Internet access to machines on the internal network using
	private address space (10.0.0.0/8, 172.16.0.0/12, and
	192.168.0.0/16 as defined in RFC1918). Private addresses are
	not routable on the Internet, which means clients out on the
	Internet cannot connect to servers with private
	addresses. Conversely, machines on the network using one of
	these addresses cannot connect to servers on the Internet
	directly. In order to allow internal machines to establish
	connections with external machines, we need the firewall to
	convert the private addresses to public addresses and vice
	versa. In other words, we need the firewall to perform Network
	Address Translation (NAT). In Firewall Builder, NAT rules are
	added in the NAT ruleset, located under the firewall object in
	the tree:</para>

      <figure float="1" id="nat-rule-set-in-fw">
          <title>NAT rule set</title>
              <graphic scale="50" fileref="fwobj-rulesets-nat.png" />
        </figure>

        <figure float="1" id="nat-policy">
          <title>Network Address Translation Rules</title>
              <graphic scale="50" fileref="nat_policy.png" />
        </figure>

        <para>Just like the firewall policy, the Network Address Translation
        (NAT) rules are inspected by the firewall in the order they appear in
        the NAT policy. Each NAT rule consists of the following rule
        elements:</para>

        <itemizedlist spacing="compact">
            <listitem>
              <para>Original Src</para>

              <para>An address object to compare to the the source address of the incoming packet.</para>
            </listitem>

            <listitem>
              <para>Original Dst</para>

              <para>An address object to compare to the the destination address of the incoming packet.</para>
            </listitem>

            <listitem>
              <para>Original Srv</para>

              <para>One or more service objects to compare to the packet's service.</para>
            </listitem>

            <listitem>
              <para>Translated Src</para>

              <para>If the original source, destination, and service
              all matched, this object becomes the new source address
              of the packet.</para>
            </listitem>

            <listitem>
              <para>Translated Dst</para>

              <para>If the original source, destination, and service
              all matched, this object becomes the new destination
              address of the packet.</para>
            </listitem>

            <listitem>
              <para>Translated Srv</para>

              <para>If the original source, destination, and service
              all matched, this object is the new service (port
              number) of the packet.</para>
            </listitem>

            <listitem>
              <para>Options</para>

              <para>This field lets you specify platform-specific
              options for the packet. Right-click in the field and
              select <guimenuitem>Rule Options</guimenuitem> to see
              options for your
              platform. Click <guibutton>Help</guibutton> in the
              Options dialog to see help for available parameters for
              your platform. See <xref linkend="options" /> for more
              information.</para>
            </listitem>

            <listitem>
              <para>Comment</para>
            </listitem>
          </itemizedlist>

        <para>Here is how it works:</para>

        <para>The original packet is compared with NAT rules, one at a
        time, starting with the topmost rule. Once a rule that matches
        a packet's source address, destination address and service is
        found, the firewall takes parameters from the second half of
        that rule and makes the indicated substitutions. Some rule
        elements in the first half of the rule may be set to match
        "any", which means that that element matches no matter what is
        in the packet. Some rule elements in the second half of the
        rule may be set to <emphasis>original</emphasis>, which means
        that parameter is not changed even if the rule matches. (No
        substitution happens for that element.)</para>

        <para>In addition to making the substitution, the firewall
        also makes a record in its internal table of the original and
        modified values. The firewall uses this information to perform
        a reverse translation when the reply packet comes back.</para>

        <para>The NAT rules in the screenshot (<xref linkend="nat-policy" />)
        tell the firewall to do the following:</para>

        <para><itemizedlist spacing="compact">
            <listitem>
              <para>Rule #0:</para>

	      <para>If the original packet originated on the internal
	      subnet 192.168.2.0/24 and is destined for the internal
	      subnet 192.168.1.0/24, then there is no need to
	      translate the packet.</para>
            </listitem>

            <listitem>
              <para>Rule #1:</para>

              <para>If a packet is headed to the Internet from either
              the 192.168.2.0/24 or 192.168.1.0/24 subnet, then the
              source IP address should be set to the IP address of the
              firewall's "outside" interface.</para>
            </listitem>

            <listitem>
              <para>Rule #2:</para>

              <para>If any packet was originally destined for the
              "outside" interface on the firewall, the destination IP
              address should be re-written to be the IP address of the
              "server on dmz" host IP (in this case,
              192.168.2.10).</para>
            </listitem>
          </itemizedlist></para>

        <para>Some firewall platforms support negation in NAT
        rules. If it is supported, this feature can be activated by
        right-clicking on the rule element in the NAT
        rule. <xref linkend="rule-elements" /> shows what firewall
        platforms support negation in NAT.</para>

        <para>You can create NAT rules and edit them using the same methods as
        described in <xref linkend="editing-policy-and-nat" /></para>
      </sect2>

      <sect2>
        <title>Source Address Translation</title>

       <para>
        Using NAT to translate private IP addresses to public, and vice versa, is often called
        "masquerading". When configured this way, the firewall rewrites the source
        IP address of each packet sent by internal machines to the Internet,
        replacing the private IP address with the address of its external
        interface.</para>

        <para>In Firewall Builder this type of NAT rule is composed as
        shown in Rule 1 in <xref linkend="nat-policy" />.</para>

        <para>In this rule objects representing internal networks are
        placed in
        <guilabel>Original Src</guilabel> and the firewall's outside
        interface object is placed in <guilabel>Translated
        Src</guilabel>, indicating that we want the source address of
        the packets to be translated. As before, we do not need to
        worry about reply packets because the underlying firewall
        software keeps track of translations done for all the
        connections opened through the firewall and rewrites addresses
        in all reply packets automatically.</para>

        <para>In <xref linkend="nat-policy" />, Rule 1 uses the
        firewall interface object in the Translated Src, which means
        the source address of the packet will be substituted with the
        address of firewall outside interface. If there is more than
        one external interface, the decision of which interface to use
        is made by the firewall's routing table.</para>

        <para>One of the consequences of this design is that rule #1 on <xref
        linkend="nat-policy" /> provides translation for packets coming from
        internal subnets going out to the Internet.</para>

        <note>
          <para>Interface object can be used in the NAT rules even if the
          address of this interface is obtained dynamically and is not known
          beforehand.</para>
        </note>

        <figure id="src-nat">
            <title>Translations done to packets going in different directions:
            (A) when firewall object is used in TSrc in the NAT rule; (B) when
            interface eth1 is used in TSrc in the NAT rule; (C) when host
            object with address 192.0.2.50 is used in TSrc in the NAT
            rule</title>

            <graphic scale="50" fileref="src-translations.png" />

          </figure>
					
					     <sect3>
      <title>Examples of Source Address Translation Rules</title>

        <para>
          This section demonstrates examples of NAT rules that
          manipulate the source address and ports of packets.                
        </para>

	<sect4>
        <title>Basic Source Address Translation Rule</title>

        <para>
          Source address translation is useful when you need to let
          machines using private address space (e.g., as defined in
          RFC1918) access the Internet. The firewall manipulates the
          source address of IP packets to make them appear to come
          from one of the public addresses assigned to the firewall
          instead of coming from the actual, private address on the
          internal network.
	</para>
  

        <para>
          In the following examples we will use a firewall
          object configured as follows:
	</para>
  

        <figure float="1"><title/><graphic scale="50" fileref="fwobj-dnat-2.png"/></figure>

        <para>
          The external interface of the firewall is <emphasis>eth0</emphasis>,
          it has a static IP address 192.0.2.1 (this is an
          example address, normally external interface would
          have a publicly routable address).
	</para>
  

        <para>
          The simplest source address translation rule looks
          like this:
	</para>
  

        <figure float="1"><title/><graphic scale="50" fileref="snat-rule-1.png"/></figure>

        <para>
          We put the interface of the firewall
            into <guilabel>Translated Src</guilabel> and an object
            representing the internal network in the
          <guilabel>Original Src</guilabel> element of the rule. This tells
          the firewall to replace the source address of packets
          that match the "Original" side of the rule with the 
          address of the interface <emphasis>eth0</emphasis>.  
	</para>
  

        <para>
          This rule translates into the following simple iptables
          command:
	</para>
  

  <screen>

# Rule 0 (NAT)
# 
$IPTABLES -t nat -A POSTROUTING -o eth0  -s 172.16.22.0/24  \
    -j SNAT --to-source 192.0.2.1 

  </screen>

        <para>
          Note that Firewall Builder uses the chain <emphasis>POSTROUTING</emphasis>
          for the source address translation rules. It will
          use <emphasis>PREROUTING</emphasis> for the destination
          translation rules.   
	</para>
  

        <para>
          For PF, Firewall Builder uses <emphasis>nat</emphasis> rule:       
	</para>
  

  <screen>

# Rule  0 (NAT)
# 
nat on en0 proto {tcp udp icmp} from 172.16.22.0/24 to any -&gt; 192.0.2.1 

  </screen>

        <para>
          Finally, for PIX, Firewall Builder knows to use global pool
          in combination with "nat" command and automatically
          determines which interfaces to
          associate <emphasis>global</emphasis>
          and <emphasis>nat</emphasis> commands with:
	</para>
  

  <screen>

! Rule  0 (NAT)
! 
global (outside) 1 interface
access-list id43442X30286.0 permit ip 172.16.22.0 255.255.255.0  any 
nat (inside) 1 access-list id43442X30286.0 tcp 0 0

  </screen>

        <para>
          Note that the generated PIX configuration has been optimized
          and the "global" command takes address from the interface
          "outside" regardless of how this address is assigned,
          statically or dynamically.
	</para>
  

	</sect4>

	<sect4>
        <title>Source Address Translation Using Interface with Dynamic Address</title>

        <para>
          The generated configurations in the previous examples used
          the IP address of the external interface for
          translation. Let's see what configuration Firewall Builder
          will produce if the external interface has a dynamic address
          that is not known at the time when configuration is
          generated.
	</para>
  

        <figure float="1"><title/><graphic scale="50" fileref="fwobj-snat-2.png"/></figure>

        <para>
          The NAT rule looks exactly the same as in examples above: we
          still put interface <emphasis>eth0</emphasis> in
          <guilabel>Translated Src</guilabel> even though its address is
          unknown. 
	</para>
  

        <para>
          Iptables uses target MASQUERADE when the source NAT is
          requested with a dynamic interface. Firewall Builder
          generates the following command:
	</para>
  

  <screen>

# Rule 0 (NAT)
# 
$IPTABLES -t nat -A POSTROUTING -o eth0  -s 172.16.22.0/24 -j MASQUERADE  

  </screen>

        <para>
          PF supports special syntax for the dynamic
          interface, <emphasis>(en0)</emphasis>, which makes it take
          the address of the interface automatically:
	</para>
  

  <screen>

# Rule  0 (NAT)
# 
nat on en0 proto {tcp udp icmp} from 172.16.22.0/24 to any -&gt; (en0) 

                </screen>

        <para>
          There is no difference in the generated PIX configuration
          because fwbuilder optimizes it and uses the "global
          (outside) 1 interface" command which takes the address from
          the outside interface regardless of whether the address is
          assigned statically or dynamically.
	</para>
  

	</sect4>

	<sect4>
        <title>Port Translation</title>

        <para>
          Firewall Builder can generate configurations for the NAT
          rules that manipulate not only addresses, but also ports and
          port ranges. Consider this hypothetical example where we
          want to squeeze source port range from the whole
          unprivileged range 1024 - 65535 to rather limited range
          10000 - 20000 on all connections from internal network to
          the server on DMZ:
        </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="snat-rule-3.png"/></figure>

        <para>
          TCP Service object "sport range 10000-20000" is defined as
          follows:
        </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="snat-tcp-service-1.png"/></figure>

        <para>
          For iptables fwbuilder generates the following command for
          this rule:
        </para>
  

  <screen>

# Rule 0 (NAT)
# 
$IPTABLES -t nat -A POSTROUTING -o eth+ -p tcp -m tcp  -s 172.16.22.0/24 \
    --sport 1024:65535  -d 192.168.2.10 -j SNAT --to-source :10000-20000 

  </screen>

        <para>
          This rule matches source port range "1024-65535" and
          original destination address 192.168.2.10 and only
          translates source ports to the range 10000-20000. Firewall
          Builder generated SNAT rule because the object in the
          Translated Source requested a change in the source port
          range. If this object had zeros in the source port range but
          defined some non-zero destination port range, the program
          would have generated DNAT rule to translate destination
          ports.
        </para>
  
	</sect4>

	<sect4>
        <title>Load Balancing NAT Rules</title>

  

        <para>
          
          Many firewall platforms can use NAT to perform
          simple load balancing of outgoing sessions across a
          pool of IP addresses. To set this up in fwbuilder,
          we start with an address range object:
                
        </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="snat-address-range-1.png"/></figure>

        <para>
  
                  We then use it in the "Translated Source" of the NAT rule:
                
  </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="snat-rule-4.png"/></figure>

        <para>
  
                  Here is what we get for the iptables firewall:
                
  </para>
  

  <screen>

# Rule 0 (NAT)
# 
$IPTABLES -t nat -A POSTROUTING -o eth+  -s 172.16.22.0/24 \
    -j SNAT --to-source 192.0.2.10-192.0.2.20 

                </screen>

        <para>
  
                  In case of PIX, fwbuilder builds complex global pool
                  to reflect requested address range:
                
  </para>
  

  <screen>

! Rule  0 (NAT)
! 
global (outside) 1 192.0.2.10-192.0.2.20 netmask 255.255.255.0
access-list id54756X30286.0 permit ip 172.16.22.0 255.255.255.0  any 
nat (inside) 1 access-list id54756X30286.0 tcp 0 0

                </screen>

        <para>
  
                  For PF, compiler converted range
                  192.0.2.10-192.0.2.20 to the minimal set of subnets
                  and produced the following configuration line:
                
  </para>
  

  <screen>

# Rule  0 (NAT)
# 
nat proto {tcp udp icmp} from 172.16.22.0/24 to any -&gt; \
    { 192.0.2.10/31 , 192.0.2.12/30 , 192.0.2.16/30 , 192.0.2.20 } 

                </screen>

        <para>
  
                  It is possible to use network object of smaller size
                  in <guilabel>Translated Source</guilabel> which is equivalent to using
                  a small address range:
                
  </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="snat-small-net-1.png"/></figure>

        <para>
  
                  We can use it in the rule just like the range object:
                
  </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="snat-rule-5.png"/></figure>

        <para>
  
                  This yields for PF:
                
  </para>
  

  <screen>

# Rule  0 (NAT)
# 
nat proto {tcp udp icmp} from 172.16.22.0/24 to any -&gt; 192.0.2.0/27

                </screen>

        <para>
  
                  Unfortunately, the smaller network object in Translated
                  Source is not supported for iptables because in
                  iptables, SNAT target can only accept a single IP
                  address or a range of addresses,  but not a subnet
                  specification.
                
  </para>
  

        <para>
  
                  PF supports different modes of load balancing for
                  rules like this. To add configuration parameters
                  that control this, open the NAT rule options dialog by
                  double-clicking in the column "Options" of the NAT rule:
                
  </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="snat-nat-rule-options-pf-1.png"/></figure>

        <para>
  
                  When option "source-hash" is checked, the generated command becomes
                
  </para>
  

  <screen>

# Rule  0 (NAT)
# 
nat proto {tcp udp icmp} from 172.16.22.0/24 to any -&gt; 192.0.2.0/27 source-hash 

                </screen>

	</sect4>

	</sect3>
      </sect2>

      <sect2>
        <title>Destination Address Translation</title>

        <para>Suppose we have a network using private IP addresses behind the
        firewall, and the network contains a server. We need to provide access to this server
        from the Internet in a such way that connections will be established
        to the address of the firewall. In this case we need destination
        address of packets to be rewritten so packets would reach the server
        on internal network. The simplest rule that translates destination
        address of incoming packets looks like the one on <xref linkend="nat-policy" />, Rule 2.</para>

        <para>Basically this rule says "if destination address of the
        packet matches the external address of the firewall, replace
        it with the address defined by the object <emphasis>server on
        dmz</emphasis>". If we had used the "firewall" object as the
        original destination, instead of the interface, then all
        external interfaces would be mapped to the DMZ
        server. <xref linkend="dst-nat" /> (A) illustrates this. The
        red, green and blue packets come to the firewall from
        different subnets and all have destination addresses that
        match address of the corresponding interface. If it were not
        for our NAT rule, packets like that would have been accepted
        by the firewall and sent to a process expecting them. However
        NAT rule comes to play and changes destination address of all
        three packets to 10.3.14.100 (the address of server). Packets
        with this address do not match any address belonging to the
        firewall and therefore get sent out of the firewall according
        to the rules of routing.</para>

        <para>A rule that does not specify
        any service for the translation translates addresses in
        packets of all protocols. This approach can make some rules impractical
        impractical because they will translate and bounce any packets that are
        headed for the firewall, making it impossible to connect to the
        firewall itself using telnet or any other protocol. This is especially
        inconvenient since as we saw earlier translation happens for packets
        coming from all directions; this means that you won't be able to
        connect to the firewall even from inside of your network. To alleviate
        this problem we just add an appropriate service object to the rule as
        shown in <xref linkend="basic-nat-10" />:</para>

        <figure id="basic-nat-10">
            <title>Translation limited to packets of HTTP protocol</title>
                <graphic scale="60" fileref="basic-nat-10.png" />
          </figure>

        <para>Rule #0 in <xref linkend="basic-nat-10" /> has limited scope
        because of the service object "http" in Original Service; it matches
        and performs address translation only for packets of HTTP protocol,
        while other packets are processed by TCP/IP stack on the firewall as
        usual. Very often we only want to translate address for packets coming
        from particular side of the firewall, typically from the Internet, and
        do not change other packets. Rule #0 on <xref
        linkend="basic-nat-11" /> achieves this goal by using firewall's
        interface object in Original Destination. Only packets with
        destination address the same as that of interface eth1 of the firewall
        match this rule and get their address translated. Packets coming from
        other directions will have different destination address and won't
        match the rule (see <xref linkend="dst-nat" /> (B) ).</para>

        <figure id="basic-nat-11">
            <title>Destination Address Translation Rule Using Interface of the
            Firewall</title>
                <graphic scale="60" fileref="basic-nat-11.png" />
          </figure>

        <figure id="dst-nat">
            <title>Translations done to packets going in different directions:
            (A) when firewall object is used in ODst in the NAT rule and (B)
            when interface eth1 is used in ODst in the NAT rule</title>
                <graphic scale="50" fileref="dst-translations.png" />
          </figure>
					
	<sect3>
          <title>Examples of Destination Address Translation Rules in  Firewall Builder</title>

        <para>
  
                This section demonstrates examples of NAT rules that
                manipulate the destination address and ports of packets.
              
        </para>

	<sect4>
        <title>Configuring NAT for the server using an IP address that
              belongs to the firewall</title>

        <para>
  
                In case when we have no public IP addresses to spare,
                we can still use NAT to permit access to the
                server. In this case we will use address that belongs
                to the firewall's external interface. Here is a
                screenshot showing the firewall object, its interfaces
                and an address object that belongs to the external
                interface:
              
        </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="fwobj-dnat-2.png"/></figure>

        <para>
  
                We can either use an interface object or a corresponding
                address object in the rule. The following two examples
                of rules are equivalent:
              
  </para>
  

        <para>
  
                Using interface object:
              
  </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="dnat-rule-1.png"/></figure>

        <para>
  
                Using an address object:
              
  </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="dnat-rule-2.png"/></figure>

        <para>
  
                External interface <emphasis>eth0</emphasis> of the firewall has
                just one IP address, therefore these two variants of
                the NAT rule are equivalent.
              
  </para>
  

        <para>
  
                If the firewall has multiple public IP addresses, then
                you can add them as additional Address objects to the
                external interface object and then use them in the NAT
                rules. All Address objects attached to an interface
                are equivalent from a NAT rule standpoint.
              
  </para>
  

        <para>
  
                Both NAT rules demonstrated in this example provide
                translation for the destination address of the packet
                so it can reach the server behind the firewall. We
                still need a policy rule to actually permit this kind
                of connection. This rule can be added to the global
                policy as follows:
              
  </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="dnat-rule-3.png"/></figure>

        <para>
  
                You always need a combination of the NAT rule and a
                policy rule to do both address translation and then
                permit translated packet.
              
  </para>
  

        <para>
  
                Here is what Firewall Builder generates for iptables
                using these NAT and policy rules:
              
  </para>
  

  <screen>

# Rule 0 (NAT)
# 
$IPTABLES -t nat -A PREROUTING  -p tcp -m tcp -m multiport   -d 192.0.2.1 \
    --dports 21,25 -j DNAT --to-destination 172.16.22.100 

# Rule 0 (global)
# 
$IPTABLES -A FORWARD  -i + -p tcp -m tcp  -m multiport  -d 172.16.22.100 \
    --dports 21,25  -m state --state NEW  -j ACCEPT 

              </screen>

        <para>
  
                For PF:
              
  </para>
  

  <screen>

# Rule  0 (NAT)
# 
# 
rdr on eth0 proto tcp from any to 192.0.2.1 port 21 -&gt; 172.16.22.100 port 21 
rdr on eth0 proto tcp from any to 192.0.2.1 port 25 -&gt; 172.16.22.100 port 25 

# Rule  0 (global)
# 
# 
pass in quick inet proto tcp  from any  to 172.16.22.100 port { 21, 25 }

              </screen>

        <para>
  
                These are rather standard destination translation
                rules. Let's look what Firewall Builder generates for
                the same rules in the GUI when target firewall
                platform is set to "PIX":
              
  </para>
  

  <screen>

class-map inspection_default
  match default-inspection-traffic

policy-map global_policy
  class inspection_default
    inspect ftp
    inspect esmtp

service-policy global_policy global

clear config access-list
clear config object-group
clear config icmp
clear config telnet
clear config ssh

object-group service outside.id13228X30286.srv.tcp.0 tcp
 port-object eq 21
 port-object eq 25
 exit

! Rule  0 (global)
! 
! 
access-list outside_acl_in  remark 0 (global)
access-list outside_acl_in permit tcp any host 172.16.22.100 object-group 
      outside.id13228X30286.srv.tcp.0 
access-list inside_acl_in  remark 0 (global)
access-list inside_acl_in permit tcp any host 172.16.22.100 object-group 
      outside.id13228X30286.srv.tcp.0 
access-list dmz50_acl_in  remark 0 (global)
access-list dmz50_acl_in permit tcp any host 172.16.22.100 object-group 
      outside.id13228X30286.srv.tcp.0 


access-group dmz50_acl_in in interface dmz50
access-group inside_acl_in in interface inside
access-group outside_acl_in in interface outside

! NAT compiler errors and warnings:
! 

clear xlate
clear config static
clear config global
clear config nat
! 
! Rule  0 (NAT)
! 
! 
access-list id13242X30286.0 permit tcp host 172.16.22.100  eq 21 any 
static (inside,outside) tcp interface 21  access-list id13242X30286.0 tcp 0 0
access-list id13242X30286.1 permit tcp host 172.16.22.100  eq 25 any 
static (inside,outside) tcp interface 25  access-list id13242X30286.1 tcp 0 0

              </screen>

        <para>
  
                PIX configuration is considerably more complex. First,
                protocol inspectors have been activated to set up
                protocol support. TCP ports were arranged in an
                object group that is then used in all rules. Access
                lists were created and attached to all interfaces with
                "access-group" commands. Destination address
                translation in PIX configuration is done using
                "static" commands, which use small access lists to
                match packets that should be translated. All of this,
                however, was generated from exactly the same rules and
                objects in the GUI. All we did is change the firewall
                platform in the firewall object dialog and make sure
                network zones and security levels were configured
                properly. We did not have to configure two interfaces
                for each NAT rule for PIX: Firewall Builder figured
                out which interfaces it should use for the "static"
                command automatically.
              
  </para>
  

	</sect4>

	<sect4>
        <title>Configuring NAT for the server using dedicated public IP
              address</title>

        <para>
  
                Suppose for some reason you do not want to add an
                address that should be used for NAT to an interface of
                the firewall. You can use any Address object in the
                "Original Destination" even if this Address object is
                not attached to the interface of the firewall. The
                problem with this is that the firewall must "own"
                public address used for NAT in order for it to answer
                ARP requests for this address from the upstream
                routers. If the firewall does not "own" the address
                and does not answer ARP requests, the router will not
                know where to send packets with this address in
                destination. To help you solve this problem, Firewall
                Builder can automatically add virtual address to the
                firewall's interface when you use an address in a NAT
                rule. This is controlled by a checkbox <guilabel>Add virtual
                addresses for NAT</guilabel> in the "Script" tab of the
                firewall's platform "advanced" settings dialog. If
                this checkbox is turned on, and you use an address
                object that does not belong to any interface of the
                firewall, the program adds a code fragment to the
                generated script to create virtual address of the
                interface of the firewall to make sure NAT rule will
                work. If this is not desired, you can turn this
                automation off by un-checking this option.
              
        </para>
  

        <para>
  
                If you use this feature, the NAT rules look exactly
                the same as shown above, except address objects are
                taken from the <emphasis>Objects/Addresses</emphasis> branch of the
                tree instead of the interfaces of the firewall. In
                case of iptables, generated script adds virtual
                addresses to the firewall with a label that starts
                with "FWB:" prefix. This helps the script identify and
                remove addresses it controls when you remove them in
                Firewall Builder GUI.
              
        </para>
  

	</sect4>

	<sect4>
        <title>NAT rules using an address of dynamic external
                interface</title>

  

        <para>
  
                In all previous examples, the external interface of the
                firewall had a static IP address that was used in the
                destination address translation rules. But what if the
                address is dynamic and not known at the time when
                Firewall Builder processes rules? Let's see what happens.
              
  </para>
  

        <para>
  
                Configuration of objects used in this example:
              
  </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="fwobj-dnat-4.png"/></figure>

        <para>
  
                The only difference is that interface <emphasis>eth0</emphasis> of
                the firewall is dynamic and has no IP address. In
                order to build NAT rules we use this interface in
                <guilabel>Original Destination</guilabel> (the rule looks exactly the
                same as rules in the previous examples):
              
  </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="dnat-rule-5.png"/></figure>

        <para>
  
                Firewall Builder uses method specific to the target
                firewall platform that allows it to use an interface a with
                dynamic address in policy and NAT rules. For example,
                iptables script generated by fwbuilder runs commands
                that retrieve the actual address of the interface and
                assign it to the shell variable. This variable is then
                used in iptables commands to build policy and NAT
                rules. OpenBSD PF permits using of interface name in
                rules, PIX has special syntax for "nat", "static" and
                "access-list" commands that also permit using
                interface in place of the address.
              
  </para>
  

        <para>
  
                Here is generated iptables script:
              
  </para>
  

  <screen>

getaddr() {
  dev=$1
  name=$2
  L=`$IP -4 addr show dev $dev | grep inet | grep -v :`
  test -z "$L" &amp;&amp; { 
    eval "$name=''"
    return
  }
  OIFS=$IFS
  IFS=" /"
  set $L
  eval "$name=$2"
  IFS=$OIFS
}

getaddr eth0  i_eth0

# Rule 0 (NAT)
# 
test -n "$i_eth0" &amp;&amp; $IPTABLES -t nat -A PREROUTING   -d $i_eth0 \
     -j DNAT --to-destination 172.16.22.100 

              </screen>

        <para>
  
                It defines function getaddr() that retrieves IP
                address of a given interface and assigns it to a
                variable, in this example to <emphasis>i_eth0</emphasis>. The script
                checks if this variable has a non-empty value and uses it in
                <emphasis>-d</emphasis> clause of iptables command to match
                destination address of incoming packet. Generated
                script checks the value of this variable because, if
                some interface does not have any address at the moment
                when script is executed, it should not try to run
                incorrect iptables command or, worse, install iptables
                rule matching "any". Either way machine would end up
                with firewall configuration that would have a meaning
                different from what was intended.
              
  </para>
  

        <para>
  
                In PF we can use clause <emphasis>(en0)</emphasis> to make the
                firewall match address of an interface without having
                to retrieve the address manually:
              
  </para>
  

  <screen>

# Rule  0 (NAT)
# 
rdr on en0 proto {tcp udp icmp} from any to (en0) -&gt; 172.16.22.100 

              </screen>

        <para>
  
                Generated PIX configuration uses <emphasis>interface</emphasis>
                clause to match address of the interface:
              
  </para>
  

  <screen>

! Rule  0 (NAT)
! 
access-list id29402X30286.0 permit ip host 172.16.22.100   any 
static (inside,outside) interface  access-list id29402X30286.0 tcp 0 0

              </screen>

	</sect4>

	<sect4>
        <title>Port Translation</title>

  

        <para>
  
                Rules shown in examples above only translated the
                destination address of packets. Sometimes the
                server uses different ports as well, and the firewall should
                convert from the standard port numbers to the ones used by the host. For example, the web server
                might be running on port 8080, but we may want clients
                to access it using standard port 80. Here is how to do
                it.
              
  </para>
  

        <para>
  
                First, we create TCP Service object that defines
                destination port 8080:
              
  </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="dnat-tcp-service-1.png"/></figure>

        <para>
  
                This service object does not have any source port
                specification. Only the destination port is defined. Now
                we can use it in the NAT rule as follows:
              
  </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="dnat-rule-7.png"/></figure>

        <para>
  
                Firewall Builder generates the following iptables
                script for this rule:
              
  </para>
  

  <screen>

# Rule 0 (NAT)
# 
$IPTABLES -t nat -A PREROUTING  -p tcp -m tcp   -d 192.0.2.1 --dport 80 \
    -j DNAT --to-destination 172.16.22.100:8080 

              </screen>

        <para>
  
                It uses <emphasis>-j DNAT --to-destination
                &lt;address&gt;:&lt;port&gt;</emphasis> to translate both
                destination address and destination port.
              
  </para>
  

        <para>
  
                Here is how this looks for PF:
              
  </para>
  

  <screen>

# Rule  0 (NAT)
# 
rdr on en0 proto tcp from any to 192.0.2.1 port 80 -&gt; 172.16.22.100 port 8080 

              </screen>

        <para>
  
                PIX rules look like this:
              
  </para>
  

  <screen>

! Rule  0 (NAT)
! 
! 
access-list id37125X30286.0 permit tcp host 172.16.22.100  eq 8080 any 
static (inside,outside) tcp interface 80  access-list id37125X30286.0 tcp 0 0

              </screen>

	</sect4>

     </sect3>	
					
      </sect2>

      </sect1>

    <sect1 id="routing">
      <title>Routing Ruleset</title>
      <para>Though not strictly a firewall function, Firewall Builder also lets you configure the routing tables of iptables, PIX and Cisco IOS firewalls. Routing rules are ignored for other firewalls.</para>

      <para>Construct these rules the same way you construct access policy or NAT rules, by dragging the appropriate objects into the rules. When you run the compiled script on the target firewall, the routing rule set rules create static routes in the firewall.</para>

      <note><para>When executing a firewall script, all existing routing rules previously set by user space processes are deleted. To see which rules will be deleted, you can use the command <command>ip route show</command>. All lines not including "proto kernel" will be deleted upon reload of the firewall script.</para></note>

      <para>If you want to use ECMP (Equal Cost Multi Path) routing rules with your iptables-based firewall, make sure your kernel is compiled with the CONFIG_IP_ROUTE_MULTIPATH option. See <xref linkend="ecmp" /> for instructions on creating multiple paths to a destination.</para>

          <figure float="1" id="routing-rule1">
            <title>A Routing Rule</title>
                <graphic scale="70" fileref="routing-rule1.png" />
          </figure>

<itemizedlist spacing="compact">
            <listitem>
              <para>Destination</para>

              <para>Can be any addressable object (hosts, addresses, address ranges, groups, networks.) The default destination ("Default") is 0.0.0.0/0.</para>
            </listitem>

            <listitem>
              <para>Gateway</para>

              <para>Can be an IP address, an interface, or a host with only one interface.</para>
            </listitem>

            <listitem>
              <para>Interface</para>

              <para>Specify an outbound interface for packets. This interface must be a child interface of the firewall.</para>
            </listitem>

            <listitem>
              <para>Metric</para>

              <para>The metric of the route. The default metric for PIX is 1, so a "0" in a rule is automatically changed to 1 at compilation.</para>
            </listitem>

            <listitem>
              <para>Comment</para>

              <para>A free-form text field.</para>
            </listitem>
          </itemizedlist>

	<note>
	  <para>RedHat seems to reset routing rules explicitly upon system startup. Therefore, it's hard to distinguish interface rules from rules set up by the user. On RedHat systems you need to include the interface basic routing rules into your Firewall Builder routing setup. IF YOU DO NOT FOLLOW THIS HINT, YOUR MACHINE WILL FREEZE ANY NETWORK TRAFFIC UPON START OF THE FIREWALL SCRIPT.  This means, for example, if eth0 has network 192.168.3.0/24 attached to it, you need to add a route with Destination=Network(192.168.3.0/24), Gateway empty and Interface=eth0.  This problem was encountered on RedHat 8.0, but other versions and distributions might be affected too. (Debian sarge and SuSE Linux work fine without interface routing rules being included in Firewall Builder routing rules.)
	  </para>
	</note>

      <sect2>
	<title>Handling of the Default Route</title>

	  <para>"Default route" is special in that it is critical for your ability to access the firewall machine when it is managed remotely. To make sure you do not cut off access accidentally by not adding default to the routing rules in Firewall Builder, Firewall Builder treats the default route in a special way. If the default route is configured in the routing rule set in Firewall Builder, then the default route found in the routing table is deleted and replaced with the one configured in Firewall Builder. However, if there is no default route in the routing rule set in Firewall Builder configuration, then the original default route found in the routing table is not deleted. Additionally, the script checks if the installation of routing entries was successful and rolls changes back in case of errors. This ensures that the firewall machine will not be left with no default route and therefore no way to access it remotely.</para>

      </sect2>

      <sect2 id="ecmp">
	<title>ECMP routes</title>
	  <para>Firewall Builder supports ECMP routes in Linux-based firewalls using iptables. To create an ECMP rule simply specify several rules with different paths, i.e. different combinations of Gateway and Interface, for the same Destination and with the same metric.</para>

	  <para>In this example, there are three different paths to HostA.</para>

          <figure float="1" id="routing-rule2">
            <title>ECMP Routing Rule</title>
                <graphic scale="60" fileref="routing-rule2.png" />
          </figure>

	  <para>Rules are automatically classified in ECMP rules and non-ECMP.  The ECMP rules are written out in a separated section of the firewall script after the "normal" routing rules.</para>
      </sect2>
    </sect1>

      <sect1 id="editing-policy-and-nat">
        <title>Editing Firewall Rulesets</title>

        <sect2>
          <title>Adding and removing rules</title>

          <figure float="1" id="editing-policy1">
            <title>Modifying Policy rules</title>
                <graphic scale="60" fileref="editing_policy1.png" />
          </figure>

          <para>Rules can be added, removed or moved around in the policy
          using commands in a popup menu. The menu appears if you right-click rule element "Number" (the very first rule element,
          counting from the left).  <xref
          linkend="editing-policy1" /> illustrates this menu.</para>

          <para>This menu allows you to add new rules above or below the
          currently selected rule in the policy, remove rules, move the
          current rule up or down, plus the usual
          <guimenuitem>Copy</guimenuitem>/<guimenuitem>Paste</guimenuitem>
          operations done on policy rules.</para>

          <para>Functions of this pop-up menu are also duplicated in the
           <guimenu>Rules</guimenu> menu.</para>

          <para>You can also use the drag and drop operation to move rules up
          and down in the policy. Just drag the rule by its
          "number" rule element.</para>
        </sect2>

        <sect2>
          <title>Adding, removing and modifying objects in the policy and NAT
          rules</title>

          <para>To add objects to the policy or NAT rule you can either drag
          them from the tree and drop them into the corresponding rule
          element, or use the
          <guimenuitem>Copy</guimenuitem>/<guimenuitem>Paste</guimenuitem>
          operation. Objects can be copied into clipboard both from the tree
          and from another policy rule; in both cases use the pop-up menu or
          main menu <guimenu>Edit</guimenu>.</para>

          <para>Clicking the right mouse button when the cursor is over rule
          elements "Source","Destination" or "Service" brings a
          context-sensitive pop-up menu ( <xref linkend="editing-policy2" />
          ). The same pop-up menu appears when you do that over the "Original
          Source", "Original Destination", "Original Service", "Translated
          Source", "Translated Destination" and "Translated Service" rule
          elements in the NAT rule.</para>

          <figure float="1" id="editing-policy2">
            <title>Modifying Object in the Policy Rule</title>
                <graphic scale="60" fileref="editing_policy2.png" />
          </figure>

          <para>This menu provides items for the following functions:</para>

          <para><itemizedlist spacing="compact">
              <listitem>
                <para>New Group</para>

                <para>Contiguous rules can be grouped together for easier handling. A group of rules can be collapsed in the GUI so that only the group name appears. This can make it easier to deal with rulesets with many rules. The <guimenu>New Group</guimenu> command opens a dialog that lets you create and name a new group. The current rule is automatically added to the group. <xref linkend="using-rule-groups" /> has more information on rule groups.</para>
              </listitem>

              <listitem>
                <para>Add to the group</para>

                <para>The selection only appears if you right-click on a rule directly above or below an existing group. If selected, the current rule is added to the indicated group. <xref linkend="using-rule-groups" /> has more information on rule groups.</para>
              </listitem>
<!--
              <listitem>
                <para>Remove from the group</para>

                <para>The selection only appears if you right-click on a rule that is currently in a group. This selection removes the rule from the group. If you remove a rule from the middle of a group, the group splits into two groups, one above and one below the current rule. Both groups have the same name as the original group. <xref linkend="using-rule-groups" /> has more information on rule groups.</para>
              </listitem>
-->
              <listitem>
                <para>Edit</para>

                <para>This menu item opens the currently selected object in the dialog area.</para>
              </listitem>

              <listitem>
                <para>Copy</para>

                <para>The object is copied into clipboard.</para>
              </listitem>

              <listitem>
                <para>Cut</para>

                <para>The object is copied into clipboard and removed from the
                rule.</para>
              </listitem>

              <listitem>
                <para>Paste</para>

                <para>The object on the clipboard is pasted into the field in the the
                rule. A copy of the object stays on the clipboard, so it may be pasted multiple times.</para>
              </listitem>

              <listitem>
                <para>Where used</para>

                <para>Opens a dialog that shows a list of where the rule is used in all rule sets in the current firewall. In addition, simply clicking on an object puts a red rectangle around that object everywhere it occurs in the rule set.</para>
              </listitem>

              <listitem>
                <para>Reveal in tree</para>

                <para>Shows the object in its location in the appropriate tree. Simply clicking on the object does the same thing.</para>
              </listitem>

              <listitem>
                <para>Negate</para>

                <para>All objects in the selected rule element are negated.
                The rule element "Source" is negated in rule #1 in screenshot
                <xref linkend="editing-policy2" />.</para>
              </listitem>
            </itemizedlist></para>
        </sect2>

        <sect2>
          <title>Changing rule action</title>

          <para>Clicking the right mouse button when the cursor is over the
          rule element <guilabel>Action</guilabel> opens a context-sensitive pop-up menu ( <xref
          linkend="editing-policy3" /> ).</para>

          <figure float="1" id="editing-policy3">
            <title>Modifying the Action of the Policy Rule</title>
                <graphic scale="80" fileref="editing_policy3.png" />  
          </figure>

          <para>The options for this menu are described in <xref linkend="action" />.</para>

        </sect2>

        <sect2>
          <title>Changing rule direction</title>

          <para>Clicking the right mouse button when the cursor is over the
          rule element <guilabel>Direction</guilabel> opens a context-sensitive pop-up menu (
          <xref linkend="editing-policy4" /> ).</para>

          <figure float="1" id="editing-policy4">
            <title>Modifying the Direction of the Policy Rule</title>
                <graphic scale="80" fileref="editing_policy4.png" />
              </figure>

          <para>This menu provides items for the following functions:</para>

          <itemizedlist spacing="compact">
            <listitem>
              <para>Inbound:</para>

              <para>The rule matches packets entering the firewall</para>
            </listitem>

            <listitem>
              <para>Outbound:</para>

              <para>The rule matches packets exiting the firewall</para>
            </listitem>

            <listitem>
              <para>Both:</para>

              <para>The rule matches both entering and exiting packets</para>
            </listitem>
          </itemizedlist>
        </sect2>

        <sect2 id="rule-options">
          <title>Changing rule options and logging</title>

          <para>clicking the right mouse button when the cursor is over the
          rule element <guilabel>"Options"</guilabel> brings up a context-sensitive pop-up menu (
          <xref linkend="editing-policy5" />. )</para>

          <figure float="1" id="editing-policy5">
            <title>Logging and Options in a Policy Rule</title>
                <graphic scale="70" fileref="editing_policy5.png" />
          </figure>

          <para>This menu provides items for the following functions:</para>

          <itemizedlist spacing="compact">
            <listitem>
              <para>Modify Options:</para>

              <para>This menu item brings up a dialogue that allows you to
              modify certain options specific to the target firewall platform, as in <xref linkend="rule-options1" />. These settings are associated with the current rule only. For more information on the options available, click <guibutton>Help</guibutton> in the Option dialogue.</para>
            </listitem>

            <listitem>
              <para>Turn logging ON:</para>

              <para>Turns logging on for all packets matching this rule. If
              the target firewall platform does not support selective logging
              of packets, this menu item is disabled.</para>
            </listitem>

            <listitem>
              <para>Turn logging OFF:</para>

              <para>Turn logging off for packets matching this rule. If the
              target firewall platform does not support selective logging of
              packets, this menu item is disabled.</para>
            </listitem>
          </itemizedlist>

          <figure float="1" id="rule-options1">
            <title>iptables Options dialog</title>
                <graphic scale="70" fileref="rule-options1.png" />
          </figure>
        </sect2>

    <sect2 id="using-rule-groups">
      <title>Using Rule Groups</title>

	<sect3>
	  <title>Creating rule groups</title>

      <para>If you have a rule set with quite a few rules, it can be useful to lump some of them together into rule groups. A rule group is a contiguous set of rules that you have grouped together and assigned a name to. Once you have a group, you can collapse it down visually to save screen real estate, then pop it back open when you need to look inside.</para>

      <para>Rule groups <emphasis>only</emphasis> affect how the rules are displayed visually. They have <emphasis>no</emphasis> on how the rule set is compiled or how it works on the firewall.</para>

      <para>Let's look at a simple example of using rule groups.</para>

      <para><xref linkend="rule-group1" /> shows a fragment of a set of rules. There are two rules for packets destined for eth0, several rules for packets destined for eth1, and a couple rules for eth2-destined packets.</para>

          <figure float="1" id="rule-group1">
            <title>Rules without grouping</title>
                <graphic scale="70" fileref="rule-group1.png" />  
          </figure>

      <para>The eth2 rules take up a lot of space, so let's group them together. We can then collapse the group so it uses less space.</para>

      <para>To create the group, right-click anywhere in the first "eth1" rule and select <guimenuitem>New group</guimenuitem>. (You don't have to click on the first rule. Any rule in the group will do.)</para>

          <figure float="1" id="rule-group2">
            <title>Create the group</title>
                <graphic scale="70" fileref="rule-group2.png" />  
          </figure>
      
      <para>A dialog appears. Enter the name of the group. This name is for your convenience only, so it can be anything. Here we're naming the group after the interface, but a more descriptive name can be more useful.</para>

          <figure float="1" id="rule-group3">
            <title>Name the group</title>
                <graphic scale="70" fileref="rule-group3.png" />  
          </figure>

      <para>Now we have a group with one entry. This doesn't provide much value, so let's add other rules to the group. You can add as many rules as you want, but they must all be contiguous in the rule set.</para>

          <figure float="1" id="rule-group4">
            <title>Group with one entry</title>
                <graphic scale="70" fileref="rule-group4.png" />  
          </figure>

      <para>To add more rules, right-click on a rule adjacent to the rule in the group, then select <guimenuitem>Add to the group eth1</guimenuitem>.</para>

          <figure float="1" id="rule-group5">
            <title>Add a rule to the group</title>
                <graphic scale="70" fileref="rule-group5.png" />  
          </figure>

      <para>Do that to the rest of the "eth1" rows, and we now have a populated group.</para>

          <figure float="1" id="rule-group6">
            <title>A group of rules</title>
                <graphic scale="70" fileref="rule-group6.png" />  
          </figure>

      <para>To collapse the group, just click the little minus (-) icon in the upper left of the group.</para>

          <figure float="1" id="rule-group7">
            <title>Collapsed group</title>
                <graphic scale="70" fileref="rule-group7.png" />  
          </figure>

      <para>The group now takes up less room on your screen, though it has not changed in function.</para>
      </sect3>

      <sect3>
	<title>Modifying rule groups</title>
	  <para>You can modify a rule group after you have created it. Options are as follows:</para>

          <itemizedlist spacing="compact">
            <listitem>
              <para>Rename a group</para>

              <para>To rename a group, right-click the group name (or anywhere on the gray bar that heads the rule, and select <guimenuitem>Rename group</guimenuitem>. Then, change the name in the dialog and click <guibutton>OK</guibutton>.</para>
            </listitem>
            <listitem>
              <para>Add more rules to a group</para>

              <para>You can add an existing rule to a group if the rule is directly above or below the group. Simply right-click the rule and select <guimenuitem>Add to the group eth1</guimenuitem>.</para>
            </listitem>

            <listitem>
              <para>Remove a rule</para>

              <para>You can remove a rule in a group entirely by right-clicking the number of the rule (left-most column) and selecting <guimenuitem>Remove rule</guimenuitem>. This will remove the rule from the rule set entirely. If you want to move the rule to anther part of the rule set, select <guimenuitem>Cut rule</guimenuitem> instead, and then paste the rule elsewhere.</para>
            </listitem>
<!--
            <listitem>
              <para>Remove a rule from the group while leaving it in place</para>

              <para>To remove a rule from the group while leaving it in place in the rule set, right-click the rule and select <guimenuitem>Remove from the group</guimenuitem>. If you do this to a rule in the middle of the group, the group splits in two. You will now have two different groups, both with the same name, with the removed rule between them. You can rename one or both of the groups using the <guimenuitem>Rename group</guimenuitem> right-click option.</para>
            </listitem>
-->
          </itemizedlist>
      </sect3>
    </sect2>

    <sect2 id="rule-elements">
      <title>Support for Rule Elements and Features on Various Firewalls</title>

      <para>Certain fields in the rules are only available if the target
      firewall platform supports them. For example, the iptables firewall
      provides controls for logging of matched packets, while Cisco PIX does
      not; PIX always logs every packet it drops. Where possible, the policy
      compiler tries to emulate the missing feature. For example,
      OpenBSD PF does not support negation natively, but the policy compiler
      provides a workaround and tries to emulate
      this feature for PF. Another example is policy rules with "Outbound"
      direction. Cisco PIX supports only inbound Access Lists, so the policy
      compiler emulates outbound Access Lists while generating configuration
      for PIX. <xref linkend="policy-rule-elements" /> represents a list of
      fields in the rules and which firewall platforms support them.
      Information about these fields and features is available for Firewall Builder
      GUI that disables corresponding menu items and hides associated policy
      elements when they are not supported.</para>

      <para><table id="policy-rule-elements">
          <title>Rule features available on different platforms</title>

          <tgroup cols="11">
            <thead>
              <row>
                <entry>Firewall Platform</entry>

                <entry>Source</entry>

                <entry>Destination</entry>

                <entry>Service</entry>

                <entry>Time Interval</entry>

                <entry>Direction</entry>

                <entry>Action</entry>

                <entry>Logging/ Options</entry>

                <entry>Comment</entry>

                <entry>Negation in Policy rules</entry>

                <entry>Negation in NAT rules</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>iptables</entry>

                <entry>+</entry>

                <entry>+</entry>

                <entry>+</entry>

                <entry>+</entry>

                <entry>+</entry>

                <entry>+</entry>

                <entry>+</entry>

                <entry>+</entry>

                <entry>+</entry>

                <entry>+</entry>
              </row>

              <row>
                <entry>ipfilter</entry>

                <entry>+</entry>

                <entry>+</entry>

                <entry>+</entry>

                <entry>-</entry>

                <entry>+</entry>

                <entry>+</entry>

                <entry>+</entry>

                <entry>+</entry>

                <entry>+</entry>

                <entry>-</entry>
              </row>

              <row>
                <entry>pf</entry>

                <entry>+</entry>

                <entry>+</entry>

                <entry>+</entry>

                <entry>-</entry>

                <entry>+</entry>

                <entry>+</entry>

                <entry>+</entry>

                <entry>+</entry>

                <entry>+</entry>

                <entry>+</entry>
              </row>

              <row>
                <entry>Cisco PIX</entry>

                <entry>+</entry>

                <entry>+</entry>

                <entry>+</entry>

                <entry>-</entry>

                <entry>+</entry>

                <entry>+</entry>

                <entry>-</entry>

                <entry>+</entry>

                <entry>-</entry>

                <entry>-</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>
    </sect2>

    </sect1>

    <sect1 id="rcs">
      <title>Using Built-in Revision Control in Firewall Builder</title>

	<note><para>Linux and *BSD users must install RCS before using revision control in Firewall Builder.</para></note>

	<para>    Firewall Builder GUI has built-in revision control
                  system that can be used to keep track of changes in
                  the objects and policy rules. If data file has been
                  added to the revision control system, every time it
                  is saved, the system asks the user to enter a
                  comment that describes changes done in the file in
                  this session and stores it along with the data. The
                  program also assigns new revision number to the data
                  file using standard software versioning system with
                  major and minor version numbers separated by a
                  dot. When you open this data file next time, the
                  program presents a list of revisions alongside with
                  dates and comments, letting you choose which revision
                  you want to use. You can open the latest revision and
                  continue working with the file from the point where
                  you left off last time, or open one of the older
                  revisions to inspect how the configuration looked
                  like in the past and possibly create a branch in the
                  revision control system. Here we take a closer look
                  at the built-in revision control system.</para>

 <para>
  
                  We start with a regular data file which we open in
                  the Firewall Builder GUI as usual. Note that the
                  name of the file appears in the title bar of the main
                  window, here it is <emphasis>test2.fwb</emphasis>:
                
  </para>
  

  <figure float="1"><title/><graphic scale="60" fileref="rcs_screenshot_1.png"/></figure>

  <para>
  
                You can always see additional information about the
                file using main menu <emphasis>File/Properties</emphasis>.  There
                is not much the program can report about this file
                that we do not know already. It shows full path where
                it is located on the file system and the date and time
                of last modification, but otherwise since it has not
                been added to the revision control system, there is no
                additional information it can report.
              
  </para>
  

  <figure float="1"><title/><graphic scale="60" fileref="rcs_screenshot_3.png"/></figure>

  <para>
  
                To start tracking revisions of this data file, use
                menu <guimenuitem>File/Add File to RCS</guimenuitem>, the program
                creates all necessary files and reports result in a
                pop-up dialog. If for some reason adding file to the
                revision control has failed, the program reports error
                in the same pop-up dialog.
                

		<xref linkend="rcs-troubleshooting" /> has a list of
                  typical problems that may occur at this point.
              
  </para>

      <table frame='none'><title></title>
	<tgroup cols='2' align='left'  rowsep='0'>
	  <tbody>
      <row>
	<entry>
	  <inlinegraphic scale="60" fileref="rcs_screenshot_4.png"/>
        </entry>

	<entry>
	    <inlinegraphic scale="60" fileref="rcs_screenshot_5.png"/>
        </entry>
      </row>
      </tbody>
      </tgroup>
    </table>

  <para>
  
                A few things have changed in the GUI after the file has
                been added to the revision control system. First,
                in addition to the file name, the title bar now also shows its
                revision. The initial revision number after checkin is <emphasis>1.1</emphasis>.
              
  </para>
  

  <figure float="1"><title/><graphic scale="60" fileref="rcs_screenshot_6.png"/></figure>

  <para>
  
                The File/Properties dialog shows that the file is now
                being tracked by the revision control system and that its
                current revision is <emphasis>1.1</emphasis>. There is only one
                revision in the history and the comment
                is "Initial revision", which is added
                automatically by the program.
              
  </para>
  

  <figure float="1"><title/><graphic scale="60" fileref="rcs_screenshot_7.png"/></figure>

  <para>
  
                Let's see how the revision control system keeps track of
                the changes in the data file. To demonstrate
                this, we are going to make a change in one of the
                objects, save the object file and check it in (this creates
                new revision). Then we'll close the object file. Then, we'll open both revisions to see the differences.
              
  </para>
  

  <para>
  
                Here is the rule set of the new firewall. It is very simple and consists of just 5 rules:
              
  </para>
  

  <figure float="1"><title/><graphic scale="60" fileref="rcs_screenshot_8.png"/></figure>

  <para>
  
                Now we add one more rule (to permit <emphasis>HTTP</emphasis> to the firewall).
                This is rule #3, it is colored yellow:
              
  </para>
  

  <figure float="1"><title/><graphic scale="60" fileref="rcs_screenshot_9.png"/></figure>

  <para>
  
                Now we save this file using <guimenuitem>File/Save</guimenuitem> and
                exit the program. Before we can do that, however, the
                program tries to check the file in to the RCS and
                presents a dialog where we can add a comment to
                document the change we made. We enter the comment and
                click <guibutton>Check file in</guibutton> to complete the
                operation. The file is now checked in and the program
                exits.
              
  </para>
  

  <figure float="1"><title/><graphic scale="60" fileref="rcs_screenshot_10.png"/></figure>

  <para>
  
                Now we restart the program and open the same
                file using <guimenuitem>File/Open</guimenuitem>. Since the file is now
                in revision control, the program presents the dialog with the list
                of its revisions. Each revision has a comment
                associated with it, shown at the bottom of the
                dialog. Note also that each revision also shows the
                user name of the user who checked it in, which is very
                useful in a multi-user environment.
              
  </para>

      <table frame='none'><title></title>
	<tgroup cols='2' align='left'  rowsep='0'>
	  <tbody>
      <row>
	<entry>
	  <inlinegraphic scale="50" fileref="rcs_screenshot_11.png"/>
        </entry>

	<entry>
	    <inlinegraphic scale="50" fileref="rcs_screenshot_12.png"/>
        </entry>
      </row>
      </tbody>
      </tgroup>
    </table>

  <para>
  
                If we choose revision <emphasis>1.2</emphasis> (the latest) and click <guibutton>Open</guibutton>, we see the rule that permits HTTP to the
                firewall:
              
  </para>
  

  <figure float="1"><title/><graphic scale="60" fileref="rcs_screenshot_13.png"/></figure>

  <para>
  
                If we choose revision <emphasis>1.1</emphasis> and open the file, we
                get this policy (note revision
                number in the main window title bar, it
                is <emphasis>1.1</emphasis>):
              
  </para>
  

  <figure float="1"><title/><graphic scale="60" fileref="rcs_screenshot_14.png"/></figure>

  <para>
  
                The rule to permit HTTP to the firewall is not there
                because we opened the earlier revision of the data
                file. Essentially, we rolled back the change we made in
                rev <emphasis>1.2</emphasis>. If we only opened the earlier file to take a quick look, we can now just close the
                file, then open the latest version to continue working. However, if we wanted, we could compile and install the
                old revision. Note that this
                can break things if some protocols were added to the
                firewall rules later, but this can be useful if you
                need to test things as they were few days ago.
              
  </para>
  

  <para>
  
                However, if we want to roll back the change and continue
                without it, all we need to do is make the change in
                this revision (1.1) and then save and check it
                in. This will create a branch in RCS and we will be
                able to continue working with it later. The previous
                change, checked in as rev 1.2 will always be there, and we will always be able to revert to it if we
                want. The program does not merge branches, merging
                changes in XML files is a complex task and is not
                implemented at this time.
              
  </para>
  

  <para>
  
                To illustrate creation of a branch, we are making a
                change to the revision 1.1 of the data file as shown
                on the next screenshot:
              
  </para>
  

  <figure float="1"><title/><graphic scale="60" fileref="rcs_screenshot_15.png"/></figure>

  <para>
  
                We then save and check this file in with an appropriate
                comment. To check it in we use
                <guimenuitem>File/Commit</guimenuitem>. We then close the file
                using <guimenuitem>File/Close</guimenuitem> and reopen it again
                using <guimenuitem>File/Open</guimenuitem>. This accomplishes the same
                operation as in the example above in this document,
                except we do not close the program. When we try to open
                it, the program shows the branch and new
                revision <emphasis>1.1.1.1</emphasis> that we just created. Note
                that the time of the revision <emphasis>1.1.1.1</emphasis> is
                later than the time of revision <emphasis>1.2</emphasis>:
              
  </para>
  

  <figure float="1"><title/><graphic scale="60" fileref="rcs_screenshot_16.png"/></figure>

  <para>
  
                Now if we open rev <emphasis>1.1.1.1</emphasis>, continue
                working with and check new changes in, the program
                will create revision <emphasis>1.1.1.2</emphasis> and so on.
              
  </para>
  

  <para>
  
                This section demonstrates how the built-in revision
                control system in Firewall Builder GUI can be
                used to document changes in the file. It can also be
                used to roll back changes to a previous revision both
                temporary or permanently. Using RCS helps establish
                accountability if several administrators can make
                changes to the policy of firewalls because RCS keeps
                track of the user name of the user who checked changes
                in. RCS in Firewall Builder works on all supported OS,
                that is Linux, FreeBSD, OpenBSD, Windows and Mac OS
                X. On Linux, *BSD and Mac OS X it relies on
                system-wide installed <emphasis>rcs</emphasis> package, while on
                Windows rcs tools are installed as part of the
                Firewall Builder package. In general, it's useful to always use revision control even in simple cases when only one
                administrator uses the tool. The ability to document
                changes and roll back if necessary greatly improve the process of
                security policy management.
              
  </para>

    </sect1>

    <sect1 id="compile-install-policy">
      <title>Compiling and Installing firewall policies</title>

	<note><para>This section offers a quick description of the process to compile and install a policy. <xref linkend="compile-install-detail" /> contains more detailed instructions on installing a compiled policy onto your firewall device.</para></note>
	
	<para>Once you have a policy created, you need to compile it into a script that can run on your target device. You then need to install it on that device.</para>

	<para>Let's walk through compiling and installing a simple iptables firewall onto a Linux machine. Here is the access policy of the firewall:</para>

        <figure float="1" id="compile-install-firewall-1">
          <title>A policy to compile and install</title>
              <graphic scale="50" fileref="compile-install-firewall-1.png" />
        </figure>

	<para>To compile it, select the firewall icon, then select <guimenuitem>Rules/Compile</guimenuitem>.</para>

        <figure float="1" id="compile-install-firewall-2">
          <title>Select Rules/Compile</title>
              <graphic scale="70" fileref="compile-install-firewall-2.png" />
        </figure>

	<para>Select your firewall in the dialog. If your object file has more than one firewall, you will see an entry for each firewall. To compile several of them at once, just check the checkboxes.</para>

        <figure float="1" id="compile-install-firewall-3">
          <title>Select your firewall</title>
              <graphic scale="50" fileref="compile-install-firewall-3.png" />
        </figure>

	<para>Click <guibutton>Next</guibutton>.</para>

	<para>A dialog appears that tracks the status of the compile. If everything goes well, the output will look something like this:</para>

        <figure float="1" id="compile-install-firewall-4">
          <title>Compile status messages</title>
              <graphic scale="50" fileref="compile-install-firewall-4.png" />
        </figure>

	<para>If you get an error, see <xref linkend="troubleshooting-compiler-runtime" />.</para>

	<para>To see the created script, look in the same directory as your .fwb file. The file will be called &lt;firewallName&gt;.fw. (If you changed your default directory in the Preferences, then the generated script will be there instead.)</para>

	<note><para>This rest of this section offers a quick description of the process of installing a policy. <xref linkend="compile-install-detail" /> contains more detailed instructions, including how to set up SSH on a variety of platforms.</para></note>

	<para>Create directory <emphasis>/etc/fw/</emphasis> on your firewall.</para>

	<para>Now let's install the script using Firewall Builder's "install" functionality. Select <guimenuitem>Rules/Install</guimenuitem>.</para>



        <figure float="1" id="compile-install-firewall-2-2">
          <title>Select Rules/Install</title>
              <graphic scale="70" fileref="compile-install-firewall-2.png" />
        </figure>

	<para>The following dialog appears:</para>

        <figure float="1" id="compile-install-firewall-5">
          <title>Select Install</title>
              <graphic scale="50" fileref="compile-install-firewall-5.png" />
        </figure>

	<para>Make sure the <guilabel>Install</guilabel> checkbox is checked, then click <guibutton>Next</guibutton>. The following dialog appears:</para>

        <figure float="1" id="compile-install-firewall-6">
          <title>Firewall SSH and install parameters</title>
              <graphic scale="50" fileref="compile-install-firewall-6.png" />
        </figure>

	<para>Enter the root username and password for the device, and specify the IP address of the management interface of the device. The first time you test your firewall, it's best to leave the <guilabel>Test run</guilabel> checkbox checked. If something goes wrong, you have only to reboot your device to get back the old configuration. If, however, you want your policy to be permanent on the device, uncheck this box.</para>

	<para>Then click <guibutton>OK</guibutton>.</para>

	<para>If everything goes well, the following dialog appears and reports success. (If not, it will report failure. The log will tell you what went wrong. If the error is unclear, see <xref linkend="troubleshooting-compiler-runtime" />.)</para>

	<figure float="1" id="compile-install-firewall-7">
          <title>Installation status</title>
              <graphic scale="50" fileref="compile-install-firewall-7.png" />
        </figure>

	<para>Log into the firewall to see the policy in place. For iptables, run <command>sudo iptables -L</command>.</para>

    </sect1>
  </chapter>

  <chapter id="compile-install-detail">
    <title>Installing a Policy onto a Firewall</title>
              <para>
  
                  After firewall configuration has been generated by
                  one of the policy compilers and saved in a file on
                  disk in the format required by the target firewall,
                  it needs to be transferred to the firewall machine
                  and activated. This function is performed by the
                  component we call "Policy Installer", which is part
                  of the Firewall Builder GUI.
                
          </para>

          <para>
  
                The installer needs to be able to copy the generated firewall
                script to the firewall and then run it there. In order
                to do so, it uses secure shell. The program does not
                include ssh code; it uses an external ssh client.  On
                Linux, BSD and Mac OS X it uses the standard ssh
                client <emphasis>ssh</emphasis> and secure shell file copy
                program <emphasis>SCP</emphasis> that come with the system; on
                Windows it uses <emphasis>plink.exe</emphasis> and <emphasis>pscp.exe</emphasis>.
                The full directory path to the ssh client program can be
                configured in the Preferences dialog (accessible via
                Edit/Preferences menu). However if you are on Linux,
                *BSD or Mac and use the standard ssh client 
                available via your PATH environment variable, you do
                not need to change the default value there.
              
          </para>
  

          <para>
  
                Installer works differently depending on the target
                platform. In the case of Linux and BSD-based firewalls, it
                uses <emphasis>SCP</emphasis> to copy the generated configuration files
                to the firewall machine and then uses <emphasis>ssh</emphasis> to
                log in and run the script. In the case of Cisco routers or
                ASA appliance (PIX), it logs in, switches
                to <emphasis>enable</emphasis> and then <emphasis>configuration</emphasis> mode
                and executes configuration commands one by one in a
                manner similar to <emphasis>expect</emphasis> scripts. It inspects the 
                router's replies looking for errors and stops if it
                detects one. In the end, it issues the command <emphasis>write
                mem</emphasis> to store the new configuration in memory, then logs
                out.
              
          </para>
  

          <para>
  
                The built-in policy installer has been designed to work
                with a dedicated firewall machine, in other words, when the 
                computer where you run Firewall Builder and the actual
                firewall are different machines. Nevertheless, it can
                be used when they are the same machine as well. The
                only difference is that in all commands below you
                would use the name or address of the machine where you
                run Firewall Builder instead of the name or address of
                the dedicated firewall. The SSH client will then connect
                back to the same machine where it runs and everything
                will work exactly the same as if it was different
                computer.
              
          </para>
  <!-- ***************************************************** -->

  <sect1>
        <title>How does installer decide what address to use to
                connect to the firewall</title>

          <para>
  
                  Installer does not use the name of the firewall when it connects; it always uses the firewall's IP address. Installer
                  starts by scanning interfaces of the firewall object
                  looking for one that is marked as "Management
                  interface" in the interface
                  object dialog. Installer uses the address of this
                  interface to connect. The <guilabel>Management
                  interface</guilabel> checkbox looks this:
                
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="management_interface.png"/></figure>

          <para>
  
                  If your firewall has multiple addresses and you want
                  to use the one that is not assigned to its interface
                  in the fwbuilder object, then you can overwrite the
                  address using the entry field in
                  the <emphasis>"Installer"</emphasis> tab of the "Advanced"
                  firewall object settings dialog, like this:
                
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="alternative_fw_address.png"/></figure>

          <para>
  
                  More about other input fields in this dialog below.
                
          </para>
  

          <para>
  
                  Finally, you can overwrite the address on a one-time
                  basis just for a particular install session using the entry field
                  in the installer options dialog. This is the same
                  dialog where you enter your password:
                
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="alternative_fw_address_2.png"/></figure>

        <note>        <para>
                  This works for all supported firewall
                  platforms, i.e. iptables on Linux, pf on OpenBSD and
                  FreeBSD, ipfw on FreeBSD and Mac OS X, ipfilter on
                  FreeBSD, Cisco IOS access lists and Cisco ASA
                  (PIX). Regardless of the platform, the installer follows
                  the rules described here to determine what address
                  it should use to connect to the firewall.
                        </para></note>
  <!-- ***************************************************** -->

    </sect1>

    <sect1 id="install-putty">
        <title>Configuring Installer on Windows</title>

  

          <para>
  
                  You can skip this section if you run Firewall
                  Builder GUI on Linux, *BSD or Mac OS X.
                
          </para>
  

          <para>
  
                  Here is the link to
                  

  <ulink url="http://www.fwbuilder.org/slideshows/using_putty/slide_1.html">
                  slide show </ulink> that demonstrates the process.
                
          </para>
  

          <para>
  
                  Download and install putty.exe, plink.exe and pscp.exe
                  somewhere on your machine (say, in
                  C:\putty). Download URL is 
  <ulink url="http://www.chiark.greenend.org.uk/~sgtatham/putty/">http://www.chiark.greenend.org.uk/~sgtatham/putty/</ulink>
                
          </para>
  

          <para>
  
                  Installer does not use <emphasis>putty.exe</emphasis>, but it will be
                  very useful for troubleshooting and for setting up
                  sessions and ssh keys.
                
          </para>
  

          <para>
  
                  In the <guimenuitem>Edit/Preferences</guimenuitem> dialog, in the <guilabel>SSH</guilabel> tab,
                  use the <guibutton>Browse</guibutton> button to locate <emphasis>plink.exe</emphasis>.
                  Click <guibutton>OK</guibutton> to save preferences. If you installed it
                  in <emphasis>C:\putty</emphasis>, then you should end up
                  with <emphasis>C:\putty\plink.exe</emphasis> in this entry
                  field. Do the same to configure the path to <emphasis>pscp.exe</emphasis>.
                
          </para>
  

          <para>
  
                  You may log in to the firewall using a regular user
                  account or as root. See instructions below for an
                  explanation how to configure sudo if you use regular
                  user accounts. This part of the configuration does
                  not depend on the OS on which you run Firewall Builder.
                
          </para>
  

          <para>
  
                Before you try to use fwbuilder installer with
                plink.exe and pscp.exe, test it from the command line
                to make sure you can log in to your firewall. If this
                is the first time you've tried to log into the firewall
                machine using putty.exe, plink.exe or pscp.exe, then
                the program will discover a new host key, ask you if it is
                correct and ask if you want to save it in cache. There are
                lots of resources on the Internet that explain what
                this means and how you should verify key accuracy
                before you accept it. If the key is already known to
                the program it will not ask you about it and will just
                proceed to the part where it asks you to enter a
                password. Enter the password and press Enter to see
                if you can log in.
              
          </para>
  

          <para>
  
                Here is the command (assuming you use account "fwadmin" to manage
                firewall "guardian"):
              
          </para>
  

  <screen>

  C:\Users\vadim&gt;c:\PuTTY\plink.exe -l fwadmin guardian

</screen>

          <para>
  
                

        <figure float="1"><title/><graphic scale="50" fileref="plink_login.png"/></figure>
          </para>
  

        <note>        <para>
                The installer does not use the GUI ssh
                client <emphasis>putty.exe</emphasis>, it uses command line
                utilities that come from the same
                author: <emphasis>plink.exe</emphasis> and <emphasis>pscp.exe</emphasis>. You can
                test SSH connectivity with <emphasis>putty.exe</emphasis>, but do not enter path to it
                in the SSH tab of the Preferences dialog in Firewall Builder. It won't work.
                      </para></note>
  <!-- *************************************************** -->

      </sect1>
      <sect1>
        <title>Configuring installer to use regular user account to manage the firewall:</title>

          <para>
  
                Before fwbuilder v3.0.4, the built-in installer could only use a
                regular account to activate a policy if this account was
                configured on the firewall to use sudo without a 
                password. Starting with v3.0.4, this is not necessary
                anymore because the installer can recognize sudo password
                prompts and enter the password when needed.
              
          </para>
  

  <itemizedlist>

  <listitem>        <para>
  
                  Create an account on the firewall (say,
                  "fwadmin"), create a group "fwadmin" and make
                  this user a member of this group. Most modern
                  Linux systems automatically create group with
                  the name the same as the user
                  account.


  <screen>

  useradd fwadmin

</screen>
                        </para>
  </listitem>
  

                

  <listitem>        <para>
  
                  Create directory /etc/fw/ on the firewall, make
                  it belong to group fwadmin, make it group
                  writable.
  <screen>

  mkdir /etc/fw
  chgrp fwadmin /etc/fw
  chmod g+w fwadmin /etc/fw

</screen>
                        </para>
  </listitem>
  
  <listitem>        <para>
  
                    Configure sudo to permit user fwadmin to execute the
                    firewall script and a couple of other commands
                    used by the fwbuilder policy installer.  Run
                    <emphasis>visudo</emphasis> on the firewall to edit file
                    <emphasis>/etc/sudoers</emphasis> as follows:


          </para>
  

  <screen>

  Defaults:%fwbadmin   !lecture , passwd_timeout=1 , timestamp_timeout=1
  # User alias specification
  %fwbadmin  ALL = PASSWD: /etc/fw/&lt;FWNAME&gt;.fw , /usr/bin/pkill , /sbin/shutdown

</screen>
          <para>
                      
                    Here &lt;FWNAME&gt; is the name of the firewall.
                    Installer will log in to the firewall as user
                    fwadmin, copy the firewall script to file
                    /etc/fw/&lt;FWNAME&gt;.fw and then use the
                    following command to execute it:

	  </para>

  <screen>

  ssh fwadmin@firewall sudo -S /etc/fw/&lt;FWNAME&gt;.fw

</screen>
                  

                  

          <para>
  
                    Installer needs to be able to run <emphasis>pkill
                      shutdown</emphasis> to kill <emphasis>shutdown</emphasis> command
                    that may be running if you tried to install
                    policy in <emphasis>testing mode</emphasis> before. In
                    testing mode the installer copies the firewall
                    script to temporary directory <emphasis>/tmp</emphasis>,
                    then runs command <emphasis>shutdown -r
                      timeout</emphasis> to schedule reboot in a few
                    minutes, and finally runs the firewall script. To
                    cancel the scheduled reboot you need to install the
                    policy again with test mode checkbox turned
                    off. In this case the installer will copy the
                    firewall script to its permanent place and
                    use <emphasis>pkill</emphasis> to kill the running shutdown
                    command, canceling reboot.
                  
          </para>
  
                       
  </listitem>
  

                

  <listitem>        <para>
  
                  Set up ssh access to the firewall. Make sure you
                  can log in as user fwadmin using ssh from your
                  management workstation:



  <screen>

  $ ssh -l fwadmin &lt;FWNAME&gt;

</screen>

                  You may use either password or public key
                  authentication; the installer will work either
                  way. Use <emphasis>putty.exe</emphasis> or <emphasis>plink.exe</emphasis> to
                  test ssh access if you are on Windows (see above for
                  the explanation how to do this).
                        </para>
  </listitem>
  

                

  <listitem>        <para>
  
                  In the <guilabel>installer</guilabel> tab of the <guilabel>firewall settings</guilabel>
                  dialog of the firewall object, put in your user name (here it
                  is <emphasis>"fwadmin"</emphasis>):
                        </para>
	  <para>
        <figure float="1"><title/><graphic scale="50" fileref="installer_tab_1.png"/></figure>
          </para>
  

  </listitem>

  <listitem>        <para>
  
                  If you need to use an alternative name or IP
                  address to communicate with the firewall, put it
                  in the corresponding field in the same dialog
                  page.
                        </para>
  </listitem>
  
                

  <listitem>        <para>
  
                  Make sure the entry field <guilabel>directory on the firewall
                  where script should be installed</guilabel> is set
                  to <emphasis>/etc/fw</emphasis>. Firewall Builder is not going to
                  create this directory, so you need to create it
                  manually before you install the firewall policy (see
                  above).
                        </para>
  </listitem>
  
                

  <listitem>        <para>
  
                  Leave "Policy install script" and "Command line options" fields blank.
                        </para>
  </listitem>
  
              </itemizedlist><!-- *************************************************** -->

      </sect1>
      <sect1>
        <title>Configuring installer if you use root account to manage the firewall:</title>

  <itemizedlist>

  <listitem>        <para>
  
                  Create directory /etc/fw/ on the firewall, make it
                  belong to root, make it writable.
                        </para>
  </listitem>
  
                

  <listitem>        <para>
  
                  Set up ssh access to the firewall. Make sure you
                  can log in as root using ssh from your
                  management workstation:



  <screen>
  
  $ ssh -l root &lt;firewall_name&gt;

</screen>

                  You may use either password or public key
                  authentication; the installer will work either
                  way.
                        </para>
  </listitem>
  

                

  <listitem>        <para>
  
                  In the <guilabel>installer</guilabel> tab of the <guilabel>firewall
                  settings</guilabel> dialog of the firewall object put
                  "root" as the user name you use to log in to the
                  firewall.
                        </para>
  </listitem>
  
                

  <listitem>        <para>
  
                  Make sure entry field <guilabel>directory on the firewall
                  where script should be installed</guilabel> is set
                  to <emphasis>/etc/fw</emphasis>
                        </para>
  </listitem>
  
                

  <listitem>        <para>
  
                  Leave <guilabel>Policy install script</guilabel> and <guilabel>Command line options</guilabel> fields are blank
                        </para>
  </listitem>
  
              </itemizedlist><!-- ***************************************************** -->

	</sect1>

	<sect1>
        <title>Configuring installer if you regularly switch between Unix and Windows workstations using the same .fwb file and want to manage the firewall from both</title>

  

          <para>
  
                First of all, the .fwb file is portable and can be
                copied back and forth between Linux/BSD and windows
                machines. Even comments and object names entered in a 
                local language should be preserved since the GUI
                uses UTF-8 internally.
              
          </para>
  

          <para>
  
                Built-in installer relies on path settings for ssh
                and SCP in <guimenuitem>Edit/Preferences/SSH</guimenuitem>.  Since preferences
                are stored outside of the .fwb file, the installer
                should work just fine when .fwb file is copied from
                Unix to Windows and back. Just configure the path to ssh
                program in preferences on each system using default
                settings "ssh" on Linux and path to plink.exe on Windows
                and give it a try.
              
          </para>
  <!-- **************************************************** -->
    </sect1>

    <sect1>
        <title>Always permit SSH access from the management workstation to the firewall</title>

  

          <para>
  
                One of the typical errors that even experienced
                administrators make sometimes is to deploy a firewall that blocks ssh access to
                the firewall from the management workstation. You need
                your workstation to be able to communicate with the
                firewall in order to be able to make changes to the
                policy, so you always need to add a rule to permit
                ssh from the management workstation.  Firewall Builder can simplify this and generate
                this rule automatically if you put an IP address of
                your workstation in the entry field on the first page
                of firewall settings dialog. Here is the screenshot
                that illustrates this setting for an iptables
                firewall. The management workstation has an IP address
                192.168.1.100
              
          </para>
  

          <para>
  
                

        <figure float="1"><title/><graphic scale="50" fileref="backup_access.png"/></figure>
          </para>
  <!-- *************************************************** -->

      </sect1>

      <sect1>
        <title>Using putty sessions on Windows</title>

          <para>
  
                putty allows you to store a destination host name or
                address, user name and bunch of other parameters in
                a session so that they all can be called up at
                once. If you wish to use sessions, do the following:
              
          </para>

  <itemizedlist>

  <listitem>        <para>
  
                    Configure putty as usual, create and test a session
                    for the firewall, test it using putty outside of
                    Firewall Builder. When you use a session, the 
                    firewall host name and user name are stored in the
                    session file. Firewall Builder allows you to enter the 
                    session name in the entry field in the firewall
                    settings dialog where you would normally enter an 
                    alternative address of the firewall. A comment next
                    to the entry field reminds you about this.  Just
                    type the session name in that field, leave the user name
                    field blank and save the settings.
                          </para>
  </listitem>
  
                  

  <listitem>        <para>
  
                    Once you start the installer, do not enter your user
                    name in the "User name" field on the first page of
                    installer wizard. You do, however, need to enter the
                    login and enable passwords. Configure the rest of
                    installer options as usual. They do not change
                    when you use putty sessions.
                          </para>
  </listitem>
  
                </itemizedlist>

      </sect1>

      <sect1>
        <title>How to configure the installer to use an alternate ssh
              port number</title>

  

          <para>
  
                If the ssh daemon on your firewall is listening on an
                alternate port, then you need to configure the 
                built-in installer so that it will run <emphasis>SCP</emphasis>
                and <emphasis>ssh</emphasis> clients with command line parameters
                that would make them connect to this port. This is
                done in the <guilabel>installer</guilabel> tab of the firewall object
                <guilabel>advanced</guilabel> settings dialog as shown on the following
                screenshot (here we set the port to "2222"):
              
          </para>
  

          <para>
  
                

        <figure float="1"><title/><graphic scale="50" fileref="different_ssh_port.png"/></figure>
          </para>
  

        <note>        <para>
                On Unix, the command line option that specifies the port number
                is different for <emphasis>ssh</emphasis> and <emphasis>SCP</emphasis>. It is
                lowercase <emphasis>-p</emphasis> for <emphasis>ssh</emphasis> and
                uppercase <emphasis>-P</emphasis> for <emphasis>SCP</emphasis>.  If you
                use the <emphasis>putty</emphasis> tool <emphasis>plink.exe</emphasis>
                and <emphasis>pscp.exe</emphasis> on Windows, the option to specify
                an alternate port number is <emphasis>-P</emphasis> (capital "P") for
                both.
                      </para></note>
  

          <para>
  
                You can use the same input fields in this dialog to
                add any other command line parameters for <emphasis>ssh</emphasis>
                and <emphasis>SCP</emphasis>. For example, this is where you can
                configure parameters to make it use an alternate
                identity file (private keys). This information is
                saved with a firewall object rather than globally
                because you may need to use different parameters for
                different firewall machines, such as different key
                files or ports.
              
          </para>
  
      </sect1>

      <sect1>
        <title>How to configure the installer to use ssh private keys
              from a special file</title>

          <para>
  
                You can use the same entry fields in this dialog to
                provide other additional command line parameters for
                <emphasis>ssh</emphasis> and <emphasis>SCP</emphasis>, for example to use keys
                from a different identity file. Here is how it looks:
              
          </para>
  

          <para>
        <figure float="1"><title/><graphic scale="50" fileref="different_ssh_keys.png"/></figure>
          </para>
  

          <para>
  
                Here we configure <emphasis>ssh</emphasis> and <emphasis>SCP</emphasis> to use
                an alternate port and an alternate identity
                file <filename>~/.ssh/fwadmin_identity</filename>. The command line
                parameter for the port is different for <emphasis>ssh</emphasis>
                and <emphasis>SCP</emphasis>, but the parameter for the identity file is
                the same (<emphasis>-i</emphasis>) for both utilities.
              
          </para>
  

          <para>
  
                On Windows, the simplest way (or maybe the only way)
                to use alternative keys is to use putty sessions.
              
          </para>
  
    </sect1>

    <sect1>
        <title>Troubleshooting ssh access to the firewall</title>

          <para>
  
                The built-in policy installer will not work if ssh access
                to the firewall is not working. Test it using this
                command on Linux (assuming you user "fwadmin" to manage the
                firewall):
              
          </para>
  

  <screen>

  ssh -l fwadmin firewall

              </screen>

          <para>
  
                If you use the root account to manage the firewall, the
                command becomes
              
          </para>
  

  <screen>

  ssh -l root firewall

              </screen>

          <para>
  
                On Windows use <emphasis>putty.exe</emphasis> or <emphasis>plink.exe</emphasis> to
                do this:
              
          </para>
  

  <screen>

  C:\Users\vadim&gt;c:\PuTTY\plink.exe -l fwadmin firewall

              </screen>

  <screen>

  C:\Users\vadim&gt;c:\PuTTY\plink.exe -l root firewall

              </screen>

          <para>
  
                If you cannot log in using ssh at this point, verify
                that the ssh daemon is working on the firewall, that the 
                existing firewall policy does not block ssh access and that 
                ssh daemon configuration in <filename>/etc/ssh/sshd_config</filename>
                permits login for root (if you plan to use the root
                account to manage the policy).
              
          </para>
  

          <para>
  
                You may get the following error in the installer
                output (the same error appears if you try to test
                using <emphasis>SCP</emphasis> or <emphasis>pscp.exe</emphasis> from the command
                line):
              
          </para>
  

  <screen>
SCP: warning: Executing SCP1 compatibility. 
SCP: FATAL: Executing ssh1 in compatibility mode failed (Check that SCP1 is in your PATH). 
Lost connection 
SSH session terminated, exit status: 1
              </screen>

          <para>
  
                This error may happen when you run fwbuilder on any
                platform; it is not specific to putty/pscp.
              
          </para>
  

          <para>
  
                This error means <emphasis>SCP</emphasis> or <emphasis>pscp.exe</emphasis> was able to
                connect to the firewall but encountered ssh protocol
                version mismatch. ssh tried to switch back to ssh1
                compatibility mode, but failed. Here is an explanation
                of the problem: 

  <ulink url="http://www.snailbook.com/faq/SCP-ossh-to-ssh2.auto.html">http://www.snailbook.com/faq/SCP-ossh-to-ssh2.auto.html</ulink>. This
                really has nothing to do with fwbuilder or even
                SCP/putty/pscp on the client side. This happens if you
                have two versions of ssh package installed on the
                firewall. ssh daemon accepts connection from pscp with
                ssh protocol v2, starts SCP utility (still on the
                firewall) but the SCP utility it gets is from the
                other package and is probably an older version that does
                not support ssh2 protocol. To resolve this, try switching
                to sftp. Here is how to test this from the command
                line. First, reproduce the error:
              
          </para>
  

  <screen>

  C:\Users\vadim&gt;c:\PuTTY\pscp.exe test.txt root@firewall:

              </screen>

          <para>
  
                If this command works, then it should work from inside
                fwbuilder too. However if you get an error
                saying <emphasis>SCP: FATAL: Executing ssh1 in
                compatibility mode failed </emphasis>, try to use
                sftp.
              
          </para>
  

        <note>        <para>
                For this to work, sftp should be enabled on the server
                side. There are many resources on the web that explain
                how to do this, for
                example 

  <ulink url="http://www.linux.com/feature/62254">this
                article</ulink>.  See also the man page for <emphasis>sshd_config</emphasis>
                and search for "Subsystem" in it.
                      </para></note>
  

  <screen>

  C:\Users\vadim&gt;c:\PuTTY\pscp.exe -sftp test.txt root@firewall:

              </screen>

        <note>        <para>
                Note that there is only one '-' in front of "sftp"
                here.
                      </para></note>
  

          <para>
  
                If this works, then you need to add "-sftp" to the
                list of additional command line parameters for SCP in
                the "Installer" tab of the firewall object dialog as
                explained above.
              
          </para>
  

          <para>
  
                Another common source of problems with <emphasis>SCP</emphasis>
                and <emphasis>pscp.exe</emphasis> is described in
                this 

  <ulink url="http://www.openssh.org/faq.html#2.9">SSH
                FAQ</ulink>.  When you use SCP to transfer a file, it
                actually launches a login shell on the server side. So
                if your shell initialization script
                (<emphasis>.profile</emphasis>, <emphasis>.bashrc</emphasis>, <emphasis>.cshrc</emphasis>, etc)
                produces any kind of output, SCP gets confused and
                fails.
              
          </para>
  <!-- **************************************************** -->

      </sect1>

      <sect1>
        <title>Running built-in installer to copy generated
                firewall policy to the firewall machine and activate
                it there</title>

          <para>
  
                Now that all preparations are complete, we can move on
                and actually try to install a newly generated firewall
                policy. Select the firewall object in the object tree in
                Firewall Builder, right-click and use
                menu item <guimenuitem>Install</guimenuitem>.
              
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="installer_list_page.png"/></figure>

          <para>
  
                On this page of the wizard the program shows the list
                of all firewall objects with checkboxes that let you
                choose which ones should be recompiled and
                installed. Time stamps in the three columns show the
                time when each firewall object was modified, compiled
                and installed the last time. You can turn checkboxes on
                and off to make the program recompile and then install
                any number of firewall objects. It will first run the 
                compiler for all of those marked for compile, then it
                will run the installer for all those marked for
                installation.  Installer will ask for the user name
                and password, as well as other parameters, before
                running the install process for each of the firewalls.  We
                will return to this page of the wizard later when we
                discuss batch install. After you click <guibutton>Next</guibutton> on this
                page, the program re-compiles the policy and opens the 
                installer dialog for the first firewall marked for
                installation.
              
          </para>
  

          <para>
        <figure float="1"><title/><graphic scale="50" fileref="installer_iptables.png"/></figure>
          </para>
  

          <para>
  
                This screenshot shows how the installer options dialog
                looks for iptables, pf, ipfilter and ipfw
                firewalls. See below for the demonstration of how it
                looks while installing on Cisco router or ASA
                (PIX) device.
              
          </para>
  

          <para>
  
                Here the program already entered the user
                name <emphasis>fwadmin</emphasis> in the "User Name" field, but
                you can change it for one installation session if
                you wish. Next you need to enter the password for
                this user. <emphasis>This is the password of user
                    fwadmin on the firewall machine</emphasis>. The address
                that will be used to communicate with the firewall is
                also entered by the program automatically; it is
                taken from the firewall settings. You can change it
                for one installation session as well.
              
          </para>
  

          <para>
  
                Other installer parameters do the following:
              
          </para>
  

          <para>
  
                
          </para>
  

  <itemizedlist>

  <listitem>        <para>
  <emphasis>Quiet install</emphasis>: as the name implies,
                    this checkbox suppresses all progress output of
                    the installer.
                          </para>
  </listitem>
  

                  

  <listitem>        <para>
  <emphasis>Verbose</emphasis>: this checkbox has the opposite
                    action: it makes the installer print a lot of
                    debugging information, including ssh client debug
                    output.
                          </para>
  </listitem>
  

                  

  <listitem>        <para>
  <emphasis>Store a copy of fwb file on the
                      firewall</emphasis>: if this checkbox is on, the
                    installer will copy not only generated firewall
                    configuration files to the directory on the
                    firewall machine that is configured in the
                    "installer" tab of the firewall object dialog,
                    but also the original .fwb data file as well. <emphasis>Use
                      of this option is discouraged if you manage many
                      firewalls from the same .fwb file because
                      distributing the file that contains the security policy
                      of multiple firewalls to all of them is a bad
                      idea</emphasis>.
                          </para>
  </listitem>
  

                  

  <listitem>        <para>
  <emphasis>Test run</emphasis>: if this checkbox is on,
                    policy installer will copy firewall
                    configuration files to a temporary directory on
                    the firewall and will run them from there. The
                    intent is to test generated configuration
                    without making it permanent. If firewall machine
                    reboots, it will activate the previous firewall
                    policy. Installer uses subdirectory <emphasis>"tmp"</emphasis>
                    inside the installation directory on the firewall
                    machine that is configured in the "installer"
                    tab of the firewall object dialog. If the 
                    installation directory configured there
                    is <emphasis>/etc/fw</emphasis> (as in the screenshot earlier
                    in this HOWTO), then installer will put files in
                    the directory <emphasis>/etc/fw/tmp</emphasis> when the test
                    install option is in effect. <emphasis>You need to
                        create this directory on the firewall before
                        using this installation mode</emphasis>.
                          </para>
  </listitem>
  
                  
                  

  <listitem>        <para>
  
                    <emphasis>Schedule reboot in... </emphasis>: If this option is
                    on, installer schedules firewall reboot after
                    given time in minutes. This can be used as a
                    measure of last resort to protect against loss
                    of communication with the firewall, which may
                    happen if there is an error in the new firewall
                    policy which makes it block ssh access from the
                    management machine. Installer uses
                    command <emphasis>shutdown -r +10min</emphasis> to schedule
                    reboot in 10 min. If installation has been
                    successful and everything works right, you need
                    to repeat installation with options "test
                    install" and "Schedule reboot" turned off to
                    cancel reboot and install new policy
                    permanently.
                          </para>
  </listitem>
  

                </itemizedlist>

          <para>
  
                After all parameters are set and the password
                entered, click <guibutton>OK</guibutton> to start installation.
              
          </para>
  

          <para>
  
                If this is the first time your management machine is
                logging in to the firewall via ssh, it will find out
                that ssh host key of the firewall is unknown to it
                and will present you with a dialog:
              
          </para>
  

          <para>
  
                

        <figure float="1"><title/><graphic scale="50" fileref="new_ssh_host_key_dlg.png"/></figure>
          </para>
  

          <para>
  
                Here is says that it does not know host key of the
                firewall "crash". This is nothing more than a copy
                of the warning message presented by the ssh
                client. You should verify the host key manually and
                if it matches, click <guibutton>Yes</guibutton>. If you click <guibutton>No</guibutton> in the
                dialog, the installation process will be interrupted.
              
          </para>
  

        <note>        <para>
                Installer only recognizes the ssh client warning message
                about unknown public host keys. If you rebuild your
                firewall machine, which means its host key changes,
                ssh will print a different warning message that
                fwbuilder installer does not recognise. In this case,
                you will see this message in the installer progress
                window, but installation process will get stuck. You
                need to use ssh client (<emphasis>ssh</emphasis> on Unix
                or <emphasis>putty.exe</emphasis> on Windows) to update the host key
                before you can use fwbuilder policy installer with
                this firewall again.
                      </para></note>
  

          <para>
  
                After this, installer copies files to the firewall
                and runs policy script there. You can monitor its
                progress in the dialog as shown on the screenshot:
              
          </para>
  

          <para>
  
                

        <figure float="1"><title/><graphic scale="50" fileref="install_dialog_overview.png"/></figure>
          </para>
  

          <para>
  
                This is an example of a successful installation
                session. Installer records the status in the left
                side panel of the dialog. If you use the installer
                to update several firewall machines in one session,
                their names and corresponding status of the
                installation session for each will be shown in the
                panel on the left. You can save the installer log to a
                file using <guibutton>Save log to file</guibutton> button. This can be
                useful for documentation or troubleshooting.
              
          </para>
  

          <para>
  
                If you marked multiple firewall objects for
                installation on the first page of the installer wizard
                (the one with the list of firewalls), then the program
                will repeat the installation process for the next object
                from the list when you click <guibutton>Next</guibutton>. The <guibutton>Next</guibutton> button
                will be enabled if there are more firewalls to install
                to.
              
          </para>
  <!-- **************************************************** -->

      </sect1>

      <sect1>
        <title>Running built-in installer to copy generated
                firewall policy to Cisco router or ASA (PIX)
              </title>

          <para>
  
                From the user's point of view the installer works the
                same when you manage Cisco router or ASA firewall,
                with only few minor differences. First of all, the
                first screen of the installer, where you enter the
                password, offers another input field for
                the <emphasis>enable</emphasis> password as well.
              
          </para>
  

        <note>        <para>
                You should be able to use an IPv6 address to communicate
                with the router.
                      </para></note>
  

          <para>
  
                

        <figure float="1"><title/><graphic scale="50" fileref="install_dialog_cisco.png"/></figure>
          </para>
  

          <para>
  
                Most of the options and parameters in this dialog are
                the same as those for Linux firewalls (see above). The
                following parameters work differently for Cisco
                devices:
              
          </para>
  

          <para>
  
                
          </para>
  

  <itemizedlist>

  <listitem>        <para>
  <emphasis>Test run</emphasis>: if this checkbox is on, policy
                    installer will copy new access lists configuration
                    to the router or ASA appliance but will not
                    issue <emphasis>write mem</emphasis> command in the end.
                          </para>
  </listitem>
  
                  
                  

  <listitem>        <para>
  
                    <emphasis>Schedule reboot in... </emphasis>: If this option is
                    on, installer issues command <emphasis>reload in NNN</emphasis>
                    after the new configuration has been loaded. This
                    schedules reboot in NNN minutes. In combination
                    with "test run" option, this can serve as a
                    roll-back mechanism in case of complete loss of
                    contact with the router or firewall because of an
                    error in the policy. Since "test run" does not
                    perform <emphasis>"write mem"</emphasis> in the end, the
                    original access list stays in the startup
                    configuration of the router and will be loaded
                    after reboot.
                          </para>
  </listitem>
  

                  

  <listitem>        <para>
  
                    <emphasis>Cancel reboot if policy activation was
                    successful</emphasis>: If this option is on, installer
                    issues command <emphasis>reload cancel</emphasis> in the end of
                    the policy activation process to cancel previously
                    scheduled reboot.
                          </para>
  </listitem>
  

                </itemizedlist>

          <para>
  
                Here is a screenshot of installation session to a
                Cisco router. Note the output at the very top of the
                log that shows how the installer detected a previously
                unknown RSA host key and accepted it after the user
                clicked "Yes" in the pop-up dialog (not shown on the
                screenshot). It then logged into the router. You can
                see the <emphasis>banner motd</emphasis> output from the
                router. After this, the installer switched
                to <emphasis>enable</emphasis> mode, set terminal width and turned
                off terminal pagination using the <emphasis>terminal length 0</emphasis>
                command and finally switched to the <emphasis>configuration
                mode</emphasis>. It then started entering the generated
                configuration line by line.
              
          </para>
  

          <para>

        <figure float="1"><title/><graphic scale="50" fileref="install_cisco_progress.png"/></figure>
          </para>
  

          <para>
  
                The final part of the installation session looks like
                this:
              
          </para>
  

          <para>
  
                

        <figure float="1"><title/><graphic scale="50" fileref="install_cisco_progress_end.png"/></figure>
          </para>
  

          <para>
  
                This was a successful installation session, with no
                errors. Installer finished entering configuration
                lines and issued the <emphasis>exit</emphasis> command to exit
                configuration mode, then the <emphasis>wr mem</emphasis> command to save
                configuration to memory and finally <emphasis>exit</emphasis> again
                to log out.
              
          </para>
  <!-- **************************************************** -->

    </sect1>

    <sect1>
        <title>Batch install</title>

          <para>
  
                Firewall Builder can help you manage the configuration of
                multiple firewalls if they all use the same user name
                and password for authentication. To update the policy on
                multiple firewalls in one operation, use the batch mode of
                the built-in installer. When you start the installer by
                clicking "Install" button in the toolbar or using main
                menu <emphasis>"Rules/Install"</emphasis>, the program opens the
                first page of the built-in installer where it lists
                all firewall objects. The checkbox <emphasis>"Perform batch
                install"</emphasis> turns batch mode install on.
              
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="installer_batch_list_page.png"/></figure>

          <para>
  
                When you click "Next", the program opens simplified
                version of the installation parameters dialog:
              
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="installer_batch_1.png"/></figure>

          <para>
  
                This is the same dialog as when we tried to install to a
                single firewall, except the batch mode dialog does not
                offer an input fields for the alternative address and
                some other parameters. You cannot enter alternative
                addresses in the install dialog while running it in
                batch mode because it will talk to multiple firewalls
                and one alternative address is not going to be useful.
                Other than that, this dialog always shows an entry field
                for the "enable" password which you need to fill only
                if some of the firewalls in the batch are Cisco
                routers or ASA (PIX) devices, otherwise leave it
                blank. When you run installer in the batch mode, it
                asks to enter parameters only once before the
                installation process begins. Afters that, it uses this
                data to connect to each firewall that was marked for
                installation in the first page of the installer wizard
                in turn, log in, upload new configuration and activate
                it there.
              
          </para>
    </sect1>
		
		<sect1>
			<title>How to make your firewall load your firewall policy on reboot</title>
			
<sect2>
        <title>How to make firewall load firewall policy after reboot  -- iptables</title>

  

        <para>
  
                  It depends on what Linux distribution your firewall
                  is based on. Firewall Builder generates the policy
                  in a form of a shell script for the firewall based
                  on Linux and iptables. To activate policy at a boot
                  time you need to execute this script at a boot time
                  one way or another.
                
  </para>
  

        <para>
  
                  The universal method is to put generated script in
                  /etc or /etc/firewall directory and add a line at
                  the bottom of script
                  <emphasis>/etc/rc.d/rc.local</emphasis> (Mandrake and
                  RedHat), <emphasis>/etc/rc.local</emphasis> (Debian, Ubuntu and derivatives)
		  or <emphasis>/etc/init.d/boot.local</emphasis>
                  (SuSE) like this:


  </para>
  

  <screen>

  /etc/firewall/firewall.fw

</screen>

        <para>
  
                  This way, firewall script runs when machine executes
                  boot-time scripts. The name of the file is the same
                  as the name of the firewall object in Firewall
                  Builder GUI, with extension ".fw".  So, if
                  firewall object name is <emphasis>guardian</emphasis>, then
                  fwbuilder puts generated policy in the file
                  <emphasis>guardian.fw</emphasis>.
                
  </para>
  

        <para>
  
                  Since the firewall policy generated by fwbuilder is
                  installed by running this script at a boot time, any
                  other firewall startup script that might be supplied
                  by the vendor of your Linux distribution should be
                  disabled. On Mandrake and RedHat this can be done
                  using command


  </para>
  

  <screen>

  "chkconfig --level 2345 iptables off"

</screen>

        <para>
   

                  On SuSE use command


  </para>
  

  <screen>
  
  chkconfig -e

</screen>

        <para>
   

                  and change state of services as follows:


  </para>
  

  <screen>
  
  SuSEfirewall2_final       off
  SuSEfirewall2_init        off
  SuSEfirewall2_setup       off

</screen>

        <para>
  

                  (There must be better way to turn firewall off on SuSE, but we do not know it.
                
  </para>
  

        <para>
  
                  Another method to get firewall policy automatically
                  installed at boot time uses scripts supplied by
                  Mandrake or RedHat. You still need to copy generated
                  script to the firewall machine and execute it there
                  (this can be done using installer scripts
                  fwb_install or fwbinstaller). Once the policy has
                  been tested and works as expected, you just execute
                  <command>service iptables save</command> to
                  save the policy. Now the policy will be activated at
                  a boot time if service <emphasis>iptables</emphasis> is
                  active. You can make it active on Mandrake and
                  RedHat using command


  </para>
  

  <screen>

  "chkconfig --level 2345 iptables on"

</screen>

        <note><para>
  
                    The script generated by Firewall Builder
                    does more than just set iptables rules, it also
                    adds virtual IP addresses to the interfaces of the
                    firewall and configures kernel parameters. It can
                    get real IP addresses of interfaces with dynamic
                    addresses and checks if interfaces are present and
                    "up" at the time when firewall policy is
                    applied. Standard
                    scripts <emphasis>iptables-save</emphasis>
                    and <emphasis>iptables-restore</emphasis> only manage
                    iptables rules; other tasks performed by the
                    script generated by Firewall Builder will not be
                    done upon reboot if you use this method.

                </para></note>

<sect3>
        <title>How to restart firewall script when interface address changes</title>

        <para>
  
                  Firewall policy script generated by fwbuilder for
                  iptables firewall needs to be restarted every time
                  IP address of a dynamic interface changes.  This
                  section explains why is it so and how this can be
                  done.
                
  </para>
  

        <para>
  
                  iptables firewall policy script generated by the
                  Firewall Builder determines IP addresses of all
                  dynamic interfaces and assigns them to variables
                  which it then uses in the policy rules. This helps
                  to build rules that require knowing address of the
                  interface correctly, such as anti-spoofing rules.
                  On the other hand, if interface's address changes
                  after the policy has been loaded and activated, the
                  firewall script needs to be restarted.
                
  </para>
  

        <para>
  
                  The firewall can be restarted from one of the
                  scripts that get called by PPP or DHCP daemons
                  whenever connection is established or new address
                  lease is obtained. For example, DHCP daemon
                  distributed with all major Linux distributions calls
                  script <emphasis>/etc/dhclient-exit-hooks</emphasis> when new DHCP
                  lease is obtained. To restart the firewall, just
                  create file <emphasis>/etc/dhclient-exit-hooks</emphasis> and call
                  your firewall script from it:


  </para>
  

  <screen>

  #!/bin/sh
  /etc/firewall/firewall.fw

</screen>

        <para>
  
                  See man page dhclient-script(8) for a detailed explanation.
                
  </para>
  

        <note><para>

                    On SUSE you should use YAST to
                    configure this. Start Yast control center, go to
                    "System", then "Editor for
                    /etc/sysconfig files" in the right panel, and
                    when the editor appears, choose
                    "Network/DHCP/DHCP client" in the tree
                    and edit "DHCLIENT_SCRIPT_EXE".

                </para></note>
  

        <para>
  
                  PPP daemon calls script <emphasis>/etc/ppp/ip-up</emphasis> when
                  connection is established and IP address
                  obtained. This script can be used to restart the
                  firewall as well. Just like
                  with <emphasis>/etc/dhclient-exit-hooks</emphasis>, just add a
                  call to <emphasis>/etc/firewall/firewall.fw</emphasis> at the
                  bottom of <emphasis>/etc/ppp/ip-up</emphasis>
                
  </para>
  

        <note><para>
  
                  <emphasis>"/etc/firewall/firewall.fw"</emphasis> should be
                  replaced everywhere with the real name of the firewall
                  script. Firewall Builder stores firewall commands in
                  the file with the name the same as the name of the
                  firewall object, with an extension ".fw".
                
  </para></note>
  

        <note><para>
  
                  Currently Firewall Builder requires
                  restart of the firewall script only on iptables
                  firewalls. Firewalls based on OpenBSD pf do not
                  require this because pf can dynamically load IP
                  address of the interface when it changes. As of the
                  moment of this writing, on ipfilter and ipfw
                  firewalls address of the dynamic interface has to be
                  entered in the GUI, or it cannot be used in the
                  rule. This limitation will be removed in the future
                  versions of the product.
                
  </para></note>
  
				</sect3>
      </sect2>

			<sect2>
        <title>How to make firewall load firewall policy after reboot  --  pf</title>

        <para>
  
                  For OpenBSD pf fwbuilder puts firewall policy in the
                  file <emphasis>firewall.conf</emphasis> and activation script
                  in <emphasis>firewall.fw</emphasis>
                
  </para>
  

        <para>
  
                  To activate the policy copy both files to the
                  directory <emphasis>/etc</emphasis> on the firewall
                  machine using <emphasis>fwbinstaller</emphasis>.
                  <emphasis>Fwbinstaller</emphasis> executes the
                  activation script to install the policy
                  immediately. Activation script not only loads PF
                  rules, it also configured aliased IP addresses on
                  the firewall's interfaces which is important if you
                  use multiple addresses for NAT and want fwbuilder to
                  configure them for you. It also sets kernel
                  parameters defined in the "Network" tab of the
                  firewall dialog (such as IP forwarding etc.) In
                  order to make the firewall activate it at a boot
                  time, call firewall script from the
                  file <emphasis>/etc/rc.local</emphasis> as follows:


  </para>
  

  <screen>

  /etc/firewall.fw

</screen>

        <para>
  
                  If you do not want to use activation script provided
                  by fwbuilder, you can use standard mechanisms
                  supplied by OpenBSD. Edit
                  file <emphasis>/etc/rc.conf</emphasis> as follows:


  </para>
  

  <screen>

  pf=YES                          # Packet filter / NAT
  pf_rules=/etc/firewall.conf     # Packet filter rules file
  pflogd_flags=                   # add more flags, i.e. "-s 256"

</screen>

      </sect2>

<sect2>
        <title>How to make firewall load firewall policy after reboot  --  ipfw</title>

  

        <para>
  
                  For ipfw fwbuilder generates policy in the form of a shell script (just like for iptables).
                
  </para>
  

        <para>
  
                  To install the policy, copy generated script
                  to <emphasis>/usr/local/etc/</emphasis> directory
                  using <emphasis>ssh</emphasis> and then execute it.  To
                  make the firewall run this script at a boot time
                  make the following modifications to
                  the <emphasis>/etc/rc.conf</emphasis> file:


  </para>
  

  <screen>

  firewall_enable="YES"                        
  # Set to YES to enable firewall functionality
  firewall_script="/usr/local/etc/firewall.fw" 
  # Which script to run to set up the firewall

</screen>

      </sect2>

<sect2>
        <title>How to make firewall load firewall policy after reboot  --  ipfilter</title>

  

        <para>
  
                  On FreeBSD fwbuilder generates firewall policy in
                  three files. Assuming firewall object's name
                  is <emphasis>firewall</emphasis>, these files are
                  <emphasis>firewall-ipf.conf, firewall-nat.conf,
                  firewall.fw</emphasis>. First two files contain
                  configuration for ipfilter, while the last one is a
                  shell script that activates it. This script can also
                  configure aliased IP addresses on firewall's
                  interfaces which is important if you use multiple
                  addresses for NAT and want fwbuilder to configure
                  them for you.
                
  </para>
  

        <para>
  
                  The simplest way to activate generated policy and to
                  make sure it is activated at boot time is to put all
                  three files in
                  <emphasis>/usr/local/etc/</emphasis> directory modify
                  script <emphasis>/etc/rc.conf</emphasis> by adding the following
                  lines:


  </para>
  

  <screen>

  firewall_enable="YES"                        
  # Set to YES to enable firewall functionality
  firewall_script="/usr/local/etc/firewall.fw" 
  # Which script to run to set up the firewall

</screen>

        <para>
  
                  You can use script <emphasis>fwbinstaller</emphasis> to copy all
                  three generated files from the firewall management
                  workstation to the firewall machine.
                
  </para>
  

        <para>
  
                  See also excellent mini-HOWTO: <ulink url="http://nil59.pisem.net/fwbuilder-relative/index.html"><citetitle>Deploy fwbuilder-generated policy to remote FreeBSD-and-ipfilter-based firewall</citetitle></ulink> by Daniel Podolsky.
                
  </para>
  

        <para>
  
                  Another option is to copy generated
                  files <emphasis>firewall-ipf.conf and
                  firewall-nat.conf</emphasis> to the
                  directory <emphasis>/etc/</emphasis> on the firewall
                  machine using names <emphasis>ipf.rules</emphasis>
                  and <emphasis>ipnat.rules</emphasis> and then use
                  standard way of loading ipfilter policy.  In order
                  to activate it, edit
                  file <emphasis>/etc/rc.conf</emphasis> by adding the
                  following lines to it:


  </para>
  

  <screen>

  ipfilter_enable="YES"           # Set to YES to enable ipfilter functionality
  ipfilter_program="/sbin/ipf"    # where the ipfilter program lives
  ipfilter_rules="/etc/ipf.rules" # rules definition file for ipfilter, see
  # /usr/src/contrib/ipfilter/rules for examples
  ipnat_enable="YES"              # Set to YES to enable ipnat functionality
  ipnat_program="/sbin/ipnat"     # where the ipnat program lives
  ipnat_rules="/etc/ipnat.rules"  # rules definition file for ipnat

</screen>
			</sect2>
					
		</sect1>
  </chapter>
	
	<chapter id="remote-management">
		<title>Manage your firewall remotely</title>
		<subtitle>How to set up a firewall on a small machine and use a separate workstations to manage it</subtitle>
		
		<para> The best way to utilize the flexibility of Firewall Builder and to minimize the risk to your network is to run Firewall Builder on a dedicated management workstation. This workstation will have the near-full installation of Linux or FreeBSD, complete with X11 and Gnome or KDE. Alternatively, it can be a Mac or Windows PC.</para>

		<para>The reason we do not recommend running X11 and GUI
                    environment on the firewall is actually rather
                    simple. It is well known that complex programs are
                    more prone to errors than simple and short
                    ones. X11 and GUI environments are 
<emphasis>very</emphasis>

                    complex programs, rivaling or exceeding the Linux kernel in size. Granted, you may be safe
                    if you run these on the firewall provided you
                    install all the latest patches and keep your software
                    up-to-date. This, however, means a lot of effort
                    and time spent on maintaining software
                    that is not essential to the operation of the
                    firewall and is being used only once in a
                    while. You may add protection using firewall rules
                    to block all access to the firewall itself from
                    outside (a very good idea regardless whether you
                    run X11 on it), but then you need to carefully
                    watch your policy to make sure you don't drop
                    these rules accidentally. The rules may get more
                    complex if you ever need to manage your firewall
                    remotely, making verification difficult. All this
                    adds up to the risk factor, so it is just a lot
                    simpler to not have X11 and GUI on the firewall at
                    all.
  </para>

    <para>In other words, run X11 and GUI environment on the firewall machine only when you have a definite reason to do so, and keep an open eye on it.</para>

		<para>We will look at configuring the dedicated firewall machine and then at configuring the management workstation.</para>
		
		<sect1>
			<title>The Firewall</title>

			<para>The choice of the hardware for the firewall depends on how much bandwidth is needed by the network it protects. Our experience indicates that a Pentium-II or Celeron machine running at 233 MHz or above is more than enough for a group of 2-5 people doing regular web surfing, sending and receiving email and doing some other not-very-demanding tasks. We have run firewalls like that at various times using Linux/iptables, FreeBSD/ipfilter and OpenBSD/pf combinations and can't say that any particular platform has better performance. They all just work. A firewall like one of these won't slow down file transfer on a DSL or a cable network, easily supporting download speeds of 1.5 - 2 Mbit/sec. Since hardware like this is very obsolete and can be had for almost nothing, we never saw the need to investigate which OS and firewall performs better on a slower CPU. People have had good results using old notebooks as their firewalls, too. The advantage of the notebook is that is has a monitor which makes troubleshooting easier in case you make a mistake in the policy rules and block your own access to the firewall over the network.</para>

			<para>For a larger installation (more people or long policy) a faster CPU is needed.</para>

			<para>The OS installed on the firewall machine should be minimal. Basically, all you need is the kernel, basic tools usually found in /bin, and ssh. This is true regardless of what OS you choose, so just follow installation instructions appropriate for your OS. Do not install development tools, X11, editors, graphics software and so on and you'll be fine. Make sure you get ssh, though, and in some cases you may need Perl.</para>

			<para>Once you install the firewall machine, check if the ssh daemon is running. It usually is, but some OS have different installation options and if you choose "workstation" install, they may not start ssh daemon automatically. Use <command>ps -ax | grep sshd</command> to check if the daemon is running, and if it is not, activate it.</para>
		</sect1>
		
		<sect1>
			<title>Using Diskless Firewall Configuration</title>

			<para>Several projects came up with a decent distributions intended for a small diskless router/firewall. We have experience with <ulink url="http://www.zelow.no/floppyfw/"><citetitle>floppyfw</citetitle></ulink> and <ulink url="http://www.devil-linux.org"><citetitle>Devil Linux</citetitle></ulink>, consequently Firewall Builder has policy install scripts for these. The advantage of using either one of these is that you won't have to install OS and software on the firewall machine; you just pop in a floppy or a CD-ROM and boot from it. This is as close as it comes to the firewall appliance, yet you get a modern Linux kernel and iptables with both. The whole OS is stored on the write-protected media and can be easily replaced or upgraded simply by changing the disk. Floppy FW comes on a single floppy. (These guys managed to pack a kernel, a busybox application and bunch of other programs on a single compressed ram disk.) You don't get ssh with floppyfw though. The firewall configuration is located in a text file that can be edited off-line and then written to the floppy. Firewall Builder's install script also writes the firewall policy to this floppy when you call main menu item <guimenuitem>Rules/Install</guimenuitem>. Once configuration is written to the floppy, you insert it in the firewall and reboot. That's it.</para>

			<para>Devil Linux comes on a CD-ROM and obviously has lot more stuff on it. They also keep configuration on a floppy disk. Firewall Builder's install script writes firewall policy to this floppy, which you then need to insert in the firewall. See detailed documentation on using <ulink url="http://www.devil-linux.org/home/index.php"><citetitle>Devil Linux</citetitle></ulink> on their web site.</para>
		</sect1>
		
		<sect1>
			<title>The Management Workstation</title>

			<para>The management workstation runs fwbuilder, so it needs X11 and all other libraries fwbuilder depends upon. Follow Installation instructions in <xref linkend="install" /> to install fwbuilder on the machine. Start fwbuilder by typing <command>"fwbuilder"</command> at a shell prompt to test it.</para>

			<para>Once you get the Firewall Builder GUI up and running on
                  the management workstation, you need to build a
                  firewall policy and, eventually, compile it and
                  install on the firewall. Other sections of this
                  Guide describe all steps of this
                  process. Configuration of the built-in policy
                  installer and different ways to use it to install
                  and activate generated policy on the dedicated
                  firewall can be found in <xref linkend="compile-install-detail" />.
			</para>
			
	</sect1>
</chapter>

  <!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

  <chapter id="cookbook">
    <title>Firewall Builder Cookbook</title>
     <para>The solutions to many security and firewall issues aren't always obvious. This chapter provides cookbook-like examples.</para>

<sect1 id="policy">
    <title>Examples of Access Policy Rules</title>

    <!-- ********************************************************* -->

    <sect2 id="change-ip-address-in-template">
      <title>How to change IP addresses in the firewall configuration created from a template</title>

      <para>When a firewall object is created from a template, its IP addresses possibly do not match addresses used in your setup. This section demonstrates how these addresses can be changed.</para>

      <para>We start with firewall object created in <xref linkend="gettingstarted" />. This object has been created from a three-interface template and the IP address used for the internal network is 192.168.1.0/255.255.255.0. Suppose we need to change it to 172.16.22.0/255.255.255.0. We need to change the IP address of the internal interface of the firewall, as well as the address used in the policy and NAT rules.</para>

      <para>To begin, find the IP address of the internal interface of the firewall in the tree and double-click it to open it in the editor.</para>

      <figure id="replace-network-template1">
          <title>New firewall</title>
              <graphic scale="50" fileref="pict_1.png" />
        </figure>

      <para>Edit the IP address (and possibly the netmask if needed), then click <guilabel>"Apply"</guilabel>. This changes the IP address of the interface of the firewall.</para>

      <figure id="replace-network-template2">
          <title>Edit the network address</title>
              <graphic scale="60" fileref="pict_10.png" />
        </figure>

      <para>Now we need to change the IP address used in the rules. To do this, we create a new Network object with the correct address and replace object net-192.168.1.0 in all rules with this new network object.</para>

      <para>Use <guimenu>New Object</guimenu> menu to create Network object.</para>

      <figure id="replace-network-template3">
          <title>Create new network object</title>
              <graphic scale="70" fileref="pict_20.png" />
        </figure>

      <para>A new Network object is created with default name "New Network" and IP address 0.0.0.0. </para>

      <figure id="replace-network-template4">
          <title>New object</title>
              <graphic scale="60" fileref="pict_30.png" />
        </figure>

      <para>Edit object name and address, then click <guibutton>Apply</guibutton>.</para>

      <figure id="replace-network-template5">
          <title>Edit name and address</title>
              <graphic scale="60" fileref="pict_40.png" />
        </figure>

      <para>Select <guimenuitem>Object/Find</guimenuitem> to activate the search and replace dialog.</para>

      <figure id="replace-network-template6">
          <title>Activate Find dialog</title>
              <graphic scale="60" fileref="pict_50.png" />
        </figure>

      <para>Drag and drop the object "net-192.168.1.0" from a policy rule or from its location in the "Standard" library to the left object field in the search and replace dialog. </para>

      <figure id="replace-network-template7">
          <title>Drag original object to the Find field</title>
              <graphic scale="50" fileref="pict_60.png" />
        </figure>

      <para>Locate the new Network object you just created and drag and drop it to the right object field in the search and replace dialog.</para>

      <figure id="replace-network-template8">
          <title>Drag new object to the Replace field</title>
              <graphic scale="50" fileref="pict_70.png" />
        </figure>

      <para>Change the scope to <guimenuitem>Policy of all firewalls</guimenuitem> and click <guibutton>Replace all</guibutton>. If you have many firewalls in the tree and you only want to replace in this one, use scope <guimenuitem>policy of the opened firewall</guimenuitem> instead. A pop-up dialog appears telling you how many replacements have been done.</para>

      <figure id="replace-network-template9">
          <title>Drag new object to the Replace field</title>
              <graphic scale="80" fileref="pict_80.png" />
        </figure>

      <para>Note how the search and replace function replaced object "net-192.168.1.0" with "internal net" in the NAT rules as well.</para>
      <para>If the IP address used for DMZ network in this template does not match your configuration, you can change it using the same procedure.
</para>

      <figure id="replace-network-template10">
          <title>New object used in all rule sets</title>
              <graphic scale="60" fileref="pict_90.png" />
        </figure>

    </sect2>
    <sect2>
      <title>Letting certain protocols through, while blocking everything
      else</title>

      <para>This is one of the simplest, most basic tasks you may want your
      firewall to do - block all the traffic while letting certain protocols
      through. Let's assume that we have a network consisting of just the
      firewall "firewall1" and a few hosts behind it. We want to let SMTP 
      through to the mail server from the Internet, and block
      everything else. All we need to do is put the following rules in the
      Global Policy:</para>

      <figure>
          <title>Example of a rule permitting only certain protocols to the
          server and blocking everything else.</title>
              <graphic scale="70" fileref="policy-1.png" />
        </figure>

      <para>Rule #0 allows SMTP through to the server, while rule #1
      blocks and logs everything else. It is worth mentioning that this policy
      also blocks all the access to firewall itself, including access to it
      from internal hosts.</para>

      <para>We do not need any additional rules to take care of "reply"
      packets coming back from the server to clients because our underlying
      firewall software supports stateful inspection and "understands" that
      such packets should be let through.</para>
    </sect2>

    <!-- ********************************************************* -->

    <sect2>
      <title>Interchangeable and non-interchangeable objects</title>

      <para>In the previous example we put object "hostA" into the Destination
      field of the policy rule #0 because our goal was to permit protocols
      SMTP and FTP to that host and not to any other one. This actually
      reflects general principle Firewall Builder is based on: put the object
      you want to control access for in the Source or Destination field of the
      policy rule. Two different objects with the same address may or may not
      be interchangeable, depending on their type and other parameters. One of
      the frequent mistakes is to create Host object with IP address of the
      firewall, then use it in the policy and expect Firewall Builder to build
      policy controlling access to the firewall. Unfortunately it does not
      always work that way. If you wish to control access to or from the
      firewall machine, then put Firewall object into the policy rule.</para>

      <para>Another example of two objects which may on the first glance
      represent the same thing, but in fact are not interchangeable, is IP
      service object with protocol number set to 1 and ICMP service object
      with type and code set to "any". Both objects might represent the same
      type of service, namely "Any ICMP message". IP protocol 1 is in fact
      ICMP, so one would expect the behaviour of the firewall to be the same
      regardless of what type of service object is used. However, target
      firewall software typically uses special syntax for indication of
      different protocols, so using proper syntax for ICMP protocol turns
      certain features on, like for example session state tracking. Using just
      IP with protocol number 1 will most likely not turn these features on
      and therefore will lead to unexpected results.</para>

      <para>On the other hand, two objects of the same type with different
      names but the same values of all other parameters are perfectly
      interchangeable. Using different objects to describe the same object may
      be confusing, but the final firewall policy will be correct. Firewall
      Builder leaves design of the objects up to the firewall
      administrator.</para>
    </sect2>

    <!-- ********************************************************* -->

    <sect2>
      <title>Using groups</title>

      <para>Sometimes we need to define a lot of very similar rules for
      multiple hosts or networks. For example, there may be a need to permit
      the same service to 10 different hosts on the network, while still
      blocking it to all others. The simplest way to accomplish this is to add
      10 rules with the same source and service fields and just different
      destinations. Obviously this can make firewall policy quite cluttered.
      To avoid this and make policy readable we can use groups. Group is just
      a container which includes multiple objects of the same or similar type.
      Firewall Builder supports groups of objects and groups of services. You
      can put "Host", "Network" and "Firewall" objects in an object group, but you
      cannot put service objects in a such group. Similarly, a service group
      can contain "IP Service", "TCP Service", "UDP Service" and
      "ICMP Service" objects, but cannot contain hosts or networks. Groups can
      contain other groups of the same type as well. <xref
      linkend="group-dialog1" /> represents an example of the object
      group.</para>

      <para>To add objects to a group simply drag them from the tree on the
      left into group view on the right, or use Copy/Paste functions available
      via menus.</para>

      <para>Once appropriate group has been created, it can be used for the
      policy and NAT rules just like any other object.</para>

      <figure>
          <title>Example of a rule using object group.</title>
              <graphic scale="70" fileref="policy-1-1.png" />
        </figure>
    </sect2>

    <!-- ********************************************************* -->

    <sect2>
      <title>Firewall talking to itself</title>

      <para>Many services running on the firewall machine need to be able to
      establish connections to the same machine. X11, RPC, DNS are services
      like that, to name a few. Blocking these services on the firewall can
      cause various problems, depending on what protocol is being blocked. If
      it is DNS, then it may take a lot longer than usual to get to a command
      line prompt when logging in to the machine using telnet or ssh. Once
      logged in, you won't be able to resolve any host names into addresses.
      If X11 is blocked, then X server and any graphic environment using it
      (KDE, Gnome etc.) won't start. In any case though the problem can easily
      be solved by adding a simple any-any rule and specifying the loopback interface of the
      firewall to permit all sorts of communications. As shown on <xref
      linkend="rule-on-loopback" />, this rule must specify the loopback interface, have action <emphasis>Accept</emphasis> and
      direction <emphasis>Both</emphasis>.</para>

      <figure id="rule-on-loopback">
          <title>Rule permitting everything on the loopback interface</title>
              <graphic scale="70" fileref="policy-10.png" />
        </figure>

      <note>
        <para>Running X11 and other complex services on the dedicated firewall
        machine should be discouraged. However,  you may want to run a firewall to protect a server, workstation, or laptop 
        where X11, RPC and other services are perfectly normal.</para>
      </note>
    </sect2>

    <!-- ********************************************************* -->

    <sect2>
      <title>Blocking unwanted types of packets</title>

      <para>Fragmented IP packets, although useful in certain situations, are
      often used as a tool to probe and penetrate simple packet filters.
      Particular kinds of fragmented packets, namely those with incorrect
      length specifications, are especially bad because they can cause some
      operating systems to crash (for example Windows NT was known to crash
      before a fix was developed and published by Microsoft). These packets
      therefore are considered potentially harmful and should be blocked on
      the perimeter of your network. Many firewall platforms provide ways to
      deal with such packets.</para>

      <para>In Firewall Builder, we provide a way to set flags or options in
      the IP service object. Two options deal with fragments: one is called
      "all fragments" and another "short fragments". <xref
      linkend="f-policy-2" /> shows how a user-defined object called "fragments" looks
      with both options turned on. Policy compilers recognize this object and
      generate correct code for underlying firewall software platform.</para>

      <figure id="f-policy-2">
          <title>IP Service object which represents fragmented
          packets.</title>
              <graphic scale="60" fileref="policy-2.png" />
        </figure>

      <para>Object "ip_fragments", which is included in the section "Services/IP" of
      the Standard objects tree, is set to block 'short' fragments only.</para>

      <para>Another potentially harmful type of packets is so called
      "Christmas tree" packet. This one is just a TCP packet with impossible
      combination of TCP flags or even all TCP flags turned on at once (for
      example SYN, ACK, FIN, RST, PSH). This combination is never used in real
      communications, so if a packet like that appears at the boundary of your
      network, it should be considered illegal and blocked. Object "tcp-xmas"
      is included in the section "Services/TCP" of the standard objects
      database coming with Firewall Builder.</para>

      <para>Some platforms provide a mechanism to turn on and off stateful
      inspection on individual rules. Turning it off on those rules which do
      not require it may improve performance of the firewall. Obviously we do
      not need stateful inspection while analysing fragmented packets as we do
      not really want any session to be established, so we can safely use this
      option on this rule. One example of firewall platform which supports
      stateful inspection but provides a way to turn it on and off is
      iptables. In Firewall Builder, this can be done in the rule options
      dialog (which is platform-sensitive and shows different options for
      different platforms). <xref linkend="f-policy-3" /> shows rule logging options
      dialog for iptables:</para>

      <figure id="f-policy-3">
          <title>Rule options dialog for iptables firewall</title>
              <graphic scale="70" fileref="iptables-options-logging.png" />
        </figure>

      <para>Here is an example of the policy rule which is intended to block
      short fragments and TCP "Christmas scan" packets. The icon in the Options column indicates that logging is turned on.</para>

      <figure>
          <title>Rule blocking short fragmented packets and TCP "Christmas scan"
          packets</title>
              <graphic scale="60" fileref="policy-4.png" />
        </figure>

      <para>This rule applies to
      all packets crossing the firewall regardless of their origin. This means
      that it will block such packets originating in your network, too. If by
      some reason you might want to be able to send this kind of packets out,
      then specify your external interface in the <guilabel>Interface</guilabel> column.</para>

    </sect2>

    <!-- ********************************************************* -->

    <sect2>
      <title>Anti-spoofing rules</title>

      <para>Generally speaking, IP spoofing is a technique of generating IP
      packets with source address that belongs to someone else. Spoofing
      creates a danger when hosts on the LAN permit access to their resources
      and services to trusted hosts by checking the source IP of the packets.
      Using spoofing, an intruder can fake the source address of his packets and
      make them look like they originated on the trusted hosts. The basic
      idea of anti-spoofing protection is to create a firewall rule assigned
      to the external interface of the firewall that examines source address
      of all packets crossing that interface coming from outside. If the
      address belongs to the internal network or the firewall itself, the packet
      is dropped.</para>

      <para>To create an anti-spoofing rule in Firewall Builder, we need objects
      for all subnets inside the firewall perimeter, plus an object for
      firewall itself. To make the rule more compact, objects for internal
      subnets can be put in a single group. Then we create a rule in the
      policy, targeted to the external interface (interface eth0 on <xref
      linkend="f-policy-5" />), that has these objects in the "source"
      rule element. <guilabel>Destination</guilabel> and <guilabel>service</guilabel> must be set to "any" and
      <guilabel>Direction</guilabel> must be set to "inbound". <xref linkend="f-policy-5" /> shows
      the anti-spoofing rule.</para>

      <para><xref linkend="gettingstarted" /> explains how a firewall
      object and its interfaces can be created. <xref
      linkend="host-interface" /> has more details on the firewall's
      interfaces, their types and other properties. <xref
      linkend="direction" /> explains the concept of direction.</para>

      <figure id="f-policy-5">
          <title>Anti-spoofing rule</title>
              <graphic scale="60" fileref="policy-5.png" />
        </figure>

      <para>Just like in the previous example, it may be advantageous to turn
      stateful inspection off on anti-spoofing rules. Since we want to prevent
      these packets from entering our network, there is going to be no session
      opened and we do not want to keep state at all. You can use <guilabel>Options</guilabel>
      to turn off stateful inspection.</para>
    </sect2>

    <!-- ********************************************************* -->

    <sect2>
      <title>Using Action 'Reject': blocking Ident protocol</title>

      <para>Suppose we want to block connections to certain ports on the
      server behind the firewall, but want to do it in a "polite" manner that
      lets the sender host know right away that the connection attempt
      was blocked so our server would look like nothing is listening on that
      port at all. One of the practical applications of this setup would be
      blocking Ident connections to a mail relay or a mail server. Sendmail
      and many other MTA's (Mail Transport Agents) attempt to connect to Ident
      port (TCP port 113) on the mail relay every time they accept email from
      that relay. Many believe Ident protocol is practically useless and does
      not really serve as a protection against SPAM or for any other useful
      purpose. Unfortunately silent blocking of ident connections on the
      firewall using a rule with action <emphasis>"Deny"</emphasis> adds a
      delay in the email delivery. This happens because when sender host tries
      to establish Ident connection to the recipient, it sends TCP SYN packet
      to it (the first packet in three-way TCP handshake) and then waits for
      TCP ACK packet in response. However, it never sees it because
      recipient's firewall blocked its first TCP SYN packet. In situations
      like this, the sender host assumes the reply packet got lost and tries to
      send TCP SYN packet again. It repeats this for a few seconds (usually 30
      sec) before it gives up. This adds 30 sec delay to email delivery. Our
      intent is to show how one can construct a policy rule to block Ident
      without causing this delay.</para>

      <para>The simplest way to block any protocol is to use "Deny" action in
      the policy rule. Since "Deny" causes firewall to silently drop the
      packet, sender never knows what happened to it and keeps waiting for
      response. To avoid this delay we will set rule Action to "Reject".
      Normally "Reject" makes firewall to send ICMP "unreachable" message back
      to sender, thus indicating that access to requested port is denied by
      the firewall. This may be insufficient in some cases because the host trying
      to connect to our Ident port won't understand this type of ICMP message
      and will keep trying. In fact, most OS do not recognize ICMP
      "administratively prohibited" message and do keep trying. To make host
      on the other side stop its attempts right away we need to send TCP RST
      packet back instead of ICMP message. This can be done by setting the appropriate parameter for the "Reject" action. To set an Action parameter, change the Action to "Reject," then double-click the Reject icon to get the parameters dialog. (see <xref linkend="f-policy-7" />). It is also
      safe to turn stateful inspection off on this rule since we do not want
      connection to be established and therefore do not need to keep track of
      it.</para>

      <figure>
          <title>Using action "Reject" with rule option</title>
              <graphic scale="70" fileref="policy-6.png" />
        </figure>

      <figure id="f-policy-7">
          <title>Adding rule option to make send TCP RST packet</title>
              <graphic scale="70" fileref="action-parameters-reject.png" />
        </figure>
    </sect2>

    <!-- ********************************************************* -->

    <sect2>
      <title>Using negation in policy rules</title>

      <para>Suppose we want to set up a rule to permit access from the host on
      DMZ net "mail_relay_1" to hosts on the Internet, but do not want to open
      access from it to machines on our internal network represented by the
      object "internal-network". Since we want it to connect to hosts on the
      Internet and cannot predict their addresses, we have to use "any" as a
      destination in the policy rule. Unfortunately "any" includes our
      internal net as well, which is going to open undesired hole in the
      firewall.</para>

      <para>There are two solutions to this problem. First, we can use two
      rules: first will deny access from "mail_relay_1" to "internal_net" and
      the second will permit access from "mail_relay_1" to "any". Since rules
      are consulted in the order they are specified in the policy, access to
      internal net will be blocked by the first rule since the packet would
      hit it first. These two rules are represented on <xref
      linkend="f-policy-8" /></para>

      <figure id="f-policy-8">
          <title>Using two rules to block access from DMZ to internal net and
          permit access to the Internet</title>
              <graphic scale="60" fileref="policy-8.png" />
        </figure>

      <para>Another solution uses negation. We can specify destination in the
      rule as "not internal_net", thus permitting access to anything but
      "internal_net". Negation can be enabled and disabled in the pop-up menu
      which you call by clicking right mouse button on the corresponding rule
      field. This rule depends on the rules below it to block access from
      "mail_relay1" to the "internal_net". If the policy was built using
      general principle of blocking everything and then enabling only types of
      connections that must be permitted, then it usually has a "catch-all"
      rule at the bottom that blocks everything. This last rule is going to
      deny connections from the "mail_relay1" to "internal_net".</para>

      <figure id="f-policy-9">
          <title>Using rule with negation to block access from DMZ to internal
          net and permit access to the Internet</title>
              <graphic scale="60" fileref="policy-9.png" />
        </figure>

      <para>Negation can be used in NAT rules in a similar way.</para>
    </sect2>

       <sect2 id="ipv6-policy">
	<title>Adding IPv6 Rules to a Policy</title>
	
	<para>We start with a firewall object that has some basic IPv4
policy. First, we need to add IPv6 addresses to its interfaces. Open
context menu associated with interface object in the tree and click on
the item "Add IPv6 address".</para>

      <figure id="ipv6_slide_1">
          <title>Add IPv6 addresses to IPv4 Policy</title>
              <graphic scale="70" fileref="ipv6_slide_1.png" />
        </figure>

      <para>Enter the address and netmask length (Use your own address!) </para>

        <figure id="ipv6_slide_2">
          <title>Enter address and netmask</title>
              <graphic scale="70" fileref="ipv6_slide_2.png" />
        </figure>

      <para>Add IPv6 to internal interface </para>

        <figure id="ipv6_slide_3">
          <title>Internal Interface</title>
              <graphic scale="70" fileref="ipv6_slide_3.png" />
        </figure>

      <para> Inspect the regular Policy object. To see its parameters, double-click on it in the tree to open it in the editor. This object has a <guilabel>Name</guilabel>, <guilabel>IPv4/IPv6 setting</guilabel> and a <guilabel>Top ruleset</guilabel> checkbox. For iptables firewalls, there is also a pair of radio buttons that indicates whether the policy should affect <guilabel>filter+mangle</guilabel> tables or just <guilabel>mangle</guilabel> table.</para>

      <para>Compilers treat the "top" rule set differently, depending on the firewall platform:</para>

      <itemizedlist>
          <listitem>
            <para>iptables: rules defined in such rule set will go into built-in chains INPUT,OUTPUT,FORWARD etc. Rules defined in rule sets where this checkbox is not checked go into user-defined chain with the name the same as the name of the rule set.</para>
          </listitem>

          <listitem>
            <para>PF: rules defined in the rule set with "top rule set" checkbox turned off go into an anchor with the name of the rule set.</para>
          </listitem>

          <listitem>
            <para>Cisco IOS access lists: if <guilabel>top rule set</guilabel> checkbox is turned off, the rules go into access list with the name prefixed with the name of the rule set; this access list will not be assigned to interfaces via "ip access-group" command. Rulesets with checkbox "top rule set" checked generate ACLs with names consisting of the shortened name of interface and direction abbreviation ("in" or "out"). Only these lists are assigned to interfaces.</para>
          </listitem>
        </itemizedlist>

        <figure id="ipv6_slide_4">
          <title>Policy parameters</title>
              <graphic scale="70" fileref="ipv6_slide_4.png" />
        </figure>

	<para>To add new policy, right-click on the firewall object in the tree to open the context menu and use menu item <guimenuitem>Add Policy Rule Set</guimenuitem>.</para>

        <figure id="ipv6_slide_5">
          <title>Add policy rule set</title>
              <graphic scale="70" fileref="ipv6_slide_5.png" />
        </figure>

	<para>Assign a unique name to the new policy object, make it IPv6 and check the <guilabel>top ruleset</guilabel> checkbox, then click <guibutton>Apply</guibutton>. </para>

        <figure id="ipv6_slide_6">
          <title>Set rule set parameters</title>
              <graphic scale="70" fileref="ipv6_slide_6.png" />
        </figure>

	<para>We forgot to create network object to represent our local IPv6 network. Click <guimenuitem>New Network IPv6</guimenuitem> in the new object menu.</para>

        <figure id="ipv6_slide_7">
          <title>IPv6 network object</title>
              <graphic scale="70" fileref="ipv6_slide_7.png" />
        </figure>

	<para>Enter the name and address of this network. We are using the link-local address for illustration purposes. </para>

        <figure id="ipv6_slide_8">
          <title>Object name and address</title>
              <graphic scale="70" fileref="ipv6_slide_8.png" />
        </figure>

	<para>Now click on the new policy object in the tree ("Policy_ipv6") and add some rules as usual. Here we have added a rule to permit all on loopback, a rule to permit incoming HTTP and ICMP6 to the firewall and a rule to permit outgoing sessions from the internal network (object "local ipv6 net") and the firewall itself.</para>

        <figure id="ipv6_slide_9">
          <title>Add policy rules</title>
              <graphic scale="70" fileref="ipv6_slide_9.png" />
        </figure>

	<para>Now compile the policy. Note that in the progress output the compiler declares that it compiles rules for IPv6. This particular rule set really does not have any rules that would generate iptables commands for the "mangle" table, however it has 4 rules to go to the ipv6 filter table. </para>

        <figure id="ipv6_slide_10">
          <title>Compile policy</title>
              <graphic scale="50" fileref="ipv6_slide_10.png" />
        </figure>

	<para>Here is a fragment of the generated script. The script uses the ip6tables routine to load rules into the kernel. Rule 1 has iptables rules in the OUTPUT chain because the firewall object has option "Assume firewall is part of any" turned on by default.</para>

        <figure id="ipv6_slide_11">
          <title>Generated script</title>
              <graphic scale="60" fileref="ipv6_slide_11.png" />
        </figure>

	<para>Now you can install the policy on your firewall.</para>
      </sect2>

      <sect2>
	<title>Running multiple services on the same machine on different virtual addresses and different ports</title>

	  <para> Here is an example of how Firewall Builder can be used to build a firewall protecting a server. Suppose we run several secure web servers on the same machine and use virtual IP addresses to be able to supply different certificates for each one.</para>

	  <para>In addition, we run webmin on the same machine that we use to manage it. We need to permit access on protocol HTTPS to virtual addresses web servers are using from anywhere, and limited access to the webmin port on a specific address.</para>

	  <para>Here is the firewall object:</para>

        <figure id="ex2-server-1">
          <title>Firewall object with multiple services</title>
              <graphic scale="70" fileref="ex2-server-1.png" />
        </figure>

	<para>Here are the policy rules:</para>

        <figure id="ex2-server-2">
          <title>Policy rules</title>
              <graphic scale="70" fileref="ex2-server-2.png" />
        </figure>

	  <para> Access to webmin service is only permitted from the local network, while access to the secure web servers running on virtual addresses fxp0-ip1, fxp0-ip2 and fxp0-ip3 is permitted from anywhere.</para>

	  <para>The following screenshot illustrates how the TCP Service object webmin is created.</para>

        <figure id="ex2-server-3">
          <title>webmin object</title>
              <graphic scale="70" fileref="ex2-server-3.png" />
        </figure>

	<para>Webmin uses port 10000, so we put this port number in both the beginning and end of the destination port range. We do not need to do any inspection of the TCP flags and leave all of them unchecked in this object.</para>
      </sect2>

      <sect2>
	<title>Using firewall as DHCP and DNS server for the local net</title>

	<para>It is often convenient to use a firewall as a DHCP and DNS server for the local net, especially in small installations like that in a home office. It is not really difficult, but building rules properly requires understanding of how DHCP and DNS work.</para>

	<para>The following combination of rules permits machines on the local net to use the firewall as DHCP server:</para>

        <figure id="policy-10-2">
          <title>Rules with DHCP</title>
              <graphic scale="70" fileref="policy-10-2.png" />
        </figure>

	<para> The first rule permits two types of DHCP requests: the initial discovery request that is sent to the broadcast address 255.255.255.255 and the renewal request that is sent to the firewall's address. The address range object "broadcast" can be found in the Standard objects tree, under Objects/Address Ranges; this object defines broadcast address 255.255.255.255. The second rule in the pair permits DHCP replies sent by the firewall. The Service object "DHCP" can be found in the "Standard" objects tree, under Services/Groups.</para>

	<para>We could make these rules more narrow if we used the internal interface of the firewall in place of the firewall object. Assuming interface eth0 is connected to internal net, the rules would look like this:</para>

        <figure id="policy-11">
          <title>Rules with DHCP using Firewall interface</title>
              <graphic scale="70" fileref="policy-11.png" />
        </figure>

	<para>To permit the local network to use the firewall as a DNS server, we need to permit DNS queries directed to the firewall, DNS replies sent by the firewall, DNS queries sent by the firewall to servers on the Internet and replies sent back to it. The following pair of rules does just that:</para>

        <figure id="policy-12">
          <title>Rules with DNS</title>
              <graphic scale="70" fileref="policy-12.png" />
        </figure>

	<para>The Service object group object DNS can be found in the "Standard" objects tree, under Services/Groups. This group consist of both the UDP object domain and TCP object domain. Both objects define destination port 53 and ignore source port. Since we do not specify the source port, these objects match both queries sent by the domain name server (source port is 53) and the resolver on the workstations on the local net (source port is >1024). We need to use objects representing both UDP and TCP protocols because DNS falls back to TCP if the answer for the query is too big and won't fit in the standard UDP datagram. DNS zone transfers also use TCP protocol.</para>
      </sect2>

      <sect2>
	<title>Permit internal LAN to connect to the Internet</title>

	  <para>In this example we create a rule to permit our internal LAN to connect to the Internet using any protocol. Network object "LAN" should be configured with the IP address and netmask corresponding to those used on the internal network behind the firewall.</para>

        <figure id="policy-13">
          <title>Permit LAN to connect to Internet</title>
              <graphic scale="70" fileref="policy-13.png" />
        </figure>
      </sect2>

      <sect2>
	<title>Controlling access to the firewall</title>

	  <para>Suppose we need to permit SSH access to the firewall. In the simplest case we just create a rule with firewall object (fw) in Destination and a service object SSH in Service. Service object SSH can be found in the Standard objects tree, under Services/TCP. Here is the rule:</para>

        <figure id="policy-14">
          <title>SSH from anywhere</title>
              <graphic scale="70" fileref="policy-14.png" />
        </figure>

	  <para>Unfortunately this rule makes our firewall too open because it permits SSH connections to it from any host on the Internet. It would be a good idea to restrict it so that it permitted connections only from the internal LAN. This should be easy, we just put object "LAN" in the source of the corresponding rule:</para>

        <figure id="policy-15">
          <title>SSH from LAN</title>
              <graphic scale="70" fileref="policy-15.png" />
        </figure>

	  <para>This is better, but we should be careful not to permit more protocols to the firewall than we really intend to. Let's look at the simple rule permitting connects from internal LAN to the Internet:</para>

        <figure id="policy-16">
          <title>LAN to anywhere</title>
              <graphic scale="70" fileref="policy-16.png" />
        </figure>

	  <para>Logic says that destination "any" should match any address, including the ones that belong to the firewall itself. In Firewall Builder this can actually be changed using a checkbox in the <guilabel>Compiler</guilabel> tab of the <guilabel>Firewall Settings</guilabel> dialog of the firewall object. If the checkbox <guilabel>"Assume firewall is part of any"</guilabel> is checked, then the compiler generates rules assuming that "any" matches the firewall as well. So, if this option is on, then this rule permits any connections from internal LAN to the firewall, regardless of the protocol! Here is how we can modify the rule permitting access to the Internet to exclude firewall from it:</para>

        <figure id="policy-17">
          <title>Negating the firewall as a destination from the LAN</title>
              <graphic scale="70" fileref="policy-17.png" />
        </figure>

	  <para>We are now using negation in the destination; the meaning of this rule is "permit connections on any protocols from machines on the network 'LAN' to any host except the firewall".</para>
	  <para>But is there any way to make it even more restrictive? Of course there is. It is always a good idea to restrict access to the firewall to just one machine and use that machine to compile the policy and manage the firewall. Let's call this machine a management station "fw-mgmt". This set of rules works best of all:</para>

        <figure id="policy-18">
          <title>Firewall access from only one machine</title>
              <graphic scale="70" fileref="policy-18.png" />
        </figure>
      </sect2>

      <sect2>
	<title>Controlling outgoing connections from the firewall</title>

	  <para>This example shows the rule that permits only certain types of outgoing connections. To permit outgoing web access but nothing else, we put the firewall object in Source and corresponding service object in Service:</para>

        <figure id="policy-19">
          <title>HTTP only</title>
              <graphic scale="70" fileref="policy-19.png" />
        </figure>

	  <para>Rule #1 blocking packets going from any source to any destination also blocks packet originating on the firewall (provided option "Assume firewall is part of any" is on). The combination of these two rules permits only outgoing HTTP connections from the firewall and nothing else.</para>

	  <para>Although we permit outgoing HTTP connections here, we should probably permit outgoing DNS queries as well. The browser running on this machine would not be able to connect to a web site if it cannot resolve the name via DNS. Here is the corrected policy:</para>

        <figure id="policy-20">
          <title>HTTP and DNS</title>
              <graphic scale="70" fileref="policy-20.png" />
        </figure>

	  <para> Service object DNS, which includes both the UDP and
	  TCP versions, can be found in
	  the <guilabel>"Standard"</guilabel> tree
	  under <guimenuitem>Services/Groups</guimenuitem>.</para>

	  <para>We may also want to permit protocols used for troubleshooting, such as ping. In order to permit it, we just add ICMP Service object "ping request" to the list of services permitted by rule #0:</para>

        <figure id="policy-21">
          <title>HTTP,DNS and ping</title>
              <graphic scale="70" fileref="policy-21.png" />
        </figure>

	  <note><para>In Firewall Builder, a firewall object represents any machine that runs firewall software. This is not necessarily a dedicated firewall protecting a local network, but may actually be a server or a laptop. For example, rules permitting HTTP to the dedicated firewall machine may not be very practical because running the web server on it would be risky, but if the firewall object represents a web server with iptables or ipfilter running on it, such rules make perfect sense. The rule permitting outbound HTTP access from the firewall machine&mdash;explained in this example&mdash;can be used as a part of the policy protecting a laptop or a workstation.</para></note>
      </sect2>

      <sect2>
	<title>Controlling access to different ports on the server</title>

	  <para>Firewall Builder can be used to generate a policy for the firewall running on the server. Here is an example that shows how to set up a policy to permit access to different ports on the server. First of all, we need to create a Firewall object to represent our server. The only difference between this case and a usual case where firewall protects one or more networks behind it is that for the server-firewall we only need to create one interface besides the loopback. The following screenshot demonstrates a policy that permits access to the web server running on this machine (both HTTP and HTTPS), as well as FTP and management access via SSH. Rule #1 allows the server to use DNS for name resolution.</para>

        <figure id="port-access-control1">
          <title>Policy for server</title>
              <graphic scale="60" fileref="port-access-control1.png" />
        </figure>

	  <para>Sometimes the web server is bound to a several IP addresses on the same machine. One typical situation when this is needed is when the web server supports multiple sites using HTTPS protocol. The following firewall configuration demonstrates the case when interface eth0 has two IP addresses (192.0.2.1 and 192.0.2.2):</para>

        <figure id="port-access-control2">
          <title>Policy for server</title>
              <graphic scale="80" fileref="port-access-control2.png" />
        </figure>

	  <para>Suppose the web server should accept HTTPS connections to both IP addresses, while HTTP and FTP are allowed only on address 192.0.2.1. The management access to the server is allowed only via protocol SSH and only from the management workstation "fw-mgmt". The following rules enforce this policy:</para>

        <figure id="port-access-control3">
          <title>Policy for server</title>
              <graphic scale="60" fileref="port-access-control3.png" />
        </figure>

	  <note><para>The same rules could be used to permit or deny access to different ports on a server located on the network behind a dedicated firewall.</para></note>
	  
      </sect2>

      <sect2>
	<title>Blocking ssh scans using a branching rule</title>

	  <para>We start with an existing firewall policy. The rules we are going to add to block ssh scans do not depend on other rules in the policy.</para>

        <figure id="block-ssh-scan-using-branch1">
          <title>Starting policy</title>
              <graphic scale="50" fileref="slide_1.png" />
        </figure>

	  <para>First, we create a new policy rule set with name "block_ssh". This rule set is not the "top ruleset", so generated iptables rules will be placed in the chain "block_ssh". We do not need to add any rules here. Rules will be added to this chain by an external script.</para>

        <figure id="block-ssh-scan-using-branch2">
          <title>Create "block_ssh" rule set</title>
              <graphic scale="50" fileref="slide_2.png" />
        </figure>

	  <para>Create rule #3 in the main policy, the destination is the firewall itself, the service is "ssh", the direction "Inbound" and action is "Chain". Open the action in the editor by double-clicking on it, then drag the object representing rule set "block_ssh" into the well in the action editor panel. The idea is to first permit ssh to the firewall from internal net (rule #2), then to pass control to chain "block_ssh". If that chain does not block the ssh session, use another rule to permit it.</para>

        <figure id="block-ssh-scan-using-branch3">
          <title>Set the "chain" action</title>
              <graphic scale="50" fileref="slide_3.png" />
        </figure>

	  <para>Add rule #4 to permit ssh to the firewall from all sources. This rule will act on the packet only if it is not blocked by rule #3. Our script will add addresses of scanners to the chain "block_ssh" so that rule #3 will block attempts to connect from these addresses. Connections coming from addresses not in the list in chain "block_ssh" will be permitted by rule #4.</para>

        <figure id="block-ssh-scan-using-branch4">
          <title>Add a "permit" rule</title>
              <graphic scale="50" fileref="slide_4.png" />
        </figure>

	  <para>Here is what the iptables commands generated for rules 2-4 look like. Note that although the script creates chain "block_ssh", it does not put any rules in it.</para>

        <figure id="block-ssh-scan-using-branch5">
          <title>iptables commands</title>
              <graphic scale="50" fileref="slide_5.png" />
        </figure>

	  <para>We use swatch to watch the log and add iptables rules with addresses of scanners to the chain "block_ssh". The screen shot below shows the contents of the swatch config file /root/.swatchrc. This configuration makes swatch detect log lines added by ssh when an attempt is made to log in using an invalid user account or invalid password. Swatch then runs script /root/swatch/block_ssh_scanner.sh.</para>

        <figure id="block-ssh-scan-using-branch6">
          <title>swatch</title>
              <graphic scale="50" fileref="slide_6.png" />
        </figure>

	  <para>This script adds an iptables rule to chain "block_ssh" and also adds the address of the scanner to the file /root/swatch/ssh_scan_addresses to avoid duplications in the future.</para>

        <figure id="block-ssh-scan-using-branch7">
          <title>script</title>
              <graphic scale="50" fileref="slide_7.png" />
        </figure>

	  <para>Here is the command line you can use to start the swatch daemon. Add this command to the /etc/rc.d/rc.local script to start it when you reboot your machine.</para>

        <figure id="block-ssh-scan-using-branch8">
          <title>command line</title>
              <graphic scale="50" fileref="slide_8.png" />
        </figure>

	  <para>This method of blocking ssh scan attacks is effective but might be too "sharp". It will block access from legitimate machines outside your network as soon as you mistype your password even once. This can be dangerous because you'll block yourself until you either restart the firewall or remove the blocked address from iptables rules in chain "block_ssh". Ssh access to the firewall from the internal network is always permitted because of the rule #2, so this setup will not cut you off the firewall completely. Using ssh keys for authentication instead of the password when you log in from outside is a good way to avoid this problem.</para>
	  <para>An even better method is to use iptables module "recent" to block ssh access only for limited period of time. Ssh scanners will stop the scan and go away if you block its access for 10min or so, and even if you mistype your password, you'll be cut off for a limited time only.</para>
      </sect2>

      <sect2>
	<title>Using two branching rules to pass control to the same rule set</title>

	  <para>In this section we'll demonstrate how the same policy rule set can be used in two different rules so that a complex rule can be reused. The rule created in this example is specific to the iptables firewall, however the concept of using the same rule set as a target in several branching rules applies to all firewall platforms.</para>

	  <para>First, create a new policy rule set, give it name "rate_limit" and make it not "top ruleset" so that generated iptables rules go into the chain "rate_limit".</para>

        <figure id="two-branching-rules1">
          <title>New policy rule set</title>
              <graphic scale="50" fileref="2branch_slide_1.png" />
        </figure>

	  <para>Add a rule to this ruleset with a destination the firewall object itself, direction "Inbound" and action "Accept".</para>

        <figure id="two-branching-rules2">
          <title>New rule</title>
              <graphic scale="50" fileref="2branch_slide_2.png" />
        </figure>

	  <para>Double-click in the cell "Options" of this rule to open options in the editor panel. Navigate to the "hashlimit" tab and set a rate limiting parameters there. Click <guibutton>Apply</guibutton>.</para>

        <figure id="two-branching-rules3">
          <title>Set rate limit</title>
              <graphic scale="50" fileref="2branch_slide_3.png" />
        </figure>

	  <para>Now in the main policy create a rule to permit SMTP to the firewall, but instead of action "Accept" use action "Chain" and then drag and drop ruleset object "rate_limit" to the well in the editor for this action. This will pass control to the rule in rule set "rate_limit" when the destination address matches the firewall and the service is SMTP.</para>

        <figure id="two-branching-rules4">
          <title>Chain to rate_limit rule set</title>
              <graphic scale="50" fileref="2branch_slide_4.png" />
        </figure>

	  <para>Create another rule with the firewall object as the destination and a service of HTTP. Use action "Chain" and drag ruleset "rate_limit" into the well in the editor for this action.</para>

	  <para>Obviously rules #4 and #5 could be merged into one rule, using two service objects in it. We're keeping them separate in order to demonstrate how the same rule set can be used as a target in multiple branching rules. In real policies these two rules could be sufficiently different to make merging them impractical, for example if they control access to different servers for different services.</para>

        <figure id="two-branching-rules5">
          <title>Create new rule</title>
              <graphic scale="50" fileref="2branch_slide_5.png" />
        </figure>

	  <para>Here is how the generated iptables script looks for rules #4 and #5. Both rules pass control to chain "rate_limit".</para>

         <figure id="two-branching-rules6">
          <title>iptables script for top rule set</title>
              <graphic scale="50" fileref="2branch_slide_6.png" />
        </figure>

	  <para>Here is the code generated for the rule in chain "rate_limit".</para>

	  <para>Using the firewall object in the Destination in rule #0 in rate_limit is redundant because we already matched the destination in the rules that passed control to this ruleset. However, optimization of the generated script was not the goal of this example.</para>

         <figure id="two-branching-rules7">
          <title>iptables code for "rate_limit" chain</title>
              <graphic scale="50" fileref="2branch_slide_7.png" />
        </figure>

      </sect2>
    </sect1>

    <sect1 id="nat-cookbook">
    <title>Examples of NAT Rules</title>

	<sect2>
        <title>"1-1" NAT</title>

  

        <para>
  
                  Examples above were "hiding" multiple internal
                  addresses behind just one external address. We a had whole
                  network (potentially 254 hosts) use the same
                  external address to access the Internet. Sometimes it is
                  necessary to do translation where each internal host
                  has a dedicated corresponding address on the outside.
                  This is often called "1-1" NAT. Here is how this is
                  done in fwbuilder when a whole network of the same
                  dimension is available on the outside:
                
  </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="snat-rule-2.png"/></figure>

        <para>
  
                  Network object <emphasis>ext net</emphasis> defines network
                  "192.0.2.0/24", which is the same size as the internal
                  network (this is a hypothetical example). Here is
                  iptables command produced for this rule:
                
  </para>
  

  <screen>

# Rule 0 (NAT)
# 
$IPTABLES -t nat -A POSTROUTING   -s 172.16.22.0/24 -j NETMAP --to 192.0.2.0/24 

                </screen>

        <para>
  
                  NETMAP target maps a whole network of addresses onto
                  another network of addresses.
                
  </para>
  

        <para>
  
                  In PF the following "nat" command is used:
                
  </para>
  

  <screen>

# Rule  0 (NAT)
# 
nat proto {tcp udp icmp} from 172.16.22.0/24 to any -&gt; 192.0.2.0/24 

                </screen>

        <para>
  
                  For PIX, fwbuilder generates a "global" address pool
                  the size of the 192.0.2.0/24 network:
                
  </para>
  

  <screen>

! Rule  0 (NAT)
! 
global (outside) 1 192.0.2.0 netmask 255.255.255.0
access-list id54756X30286.0 permit ip 172.16.22.0 255.255.255.0  any 
nat (inside) 1 access-list id54756X30286.0 tcp 0 0

                </screen>

	</sect2>

   	<sect2>
        <title>Using Address of "wrong" Interface for Source Address Translation</title>

  

        <para>
  
                  Normally, generated iptables SNAT rule includes a "-o
                  &lt;interface&gt;" clause to make it more specific
                  and only translate packets that really leave the
                  network. Firewall Builder guesses which interface to
                  put in the "-o" parameter by looking at the object
                  in the Translated Source of the NAT rule. If this
                  object is the firewall's interface or an address of one
                  of its interfaces, then it uses that interface for
                  the "-o" parameter. There is one configuration that
                  requires the "-o" parameter to be different from the
                  address used for SNAT translation. This
                  configuration is useful when you have small block of
                  publicly routable addresses and want to host a
                  server in DMZ, but the block is so small that
                  subnetting it does not make sense.
                
  </para>
  

         <figure float="1"><title/><graphic scale="50" fileref="fwobj-snat-3.png"/></figure>
                    


                      

        <para>
  
                        Firewall object <emphasis>fw-1-1</emphasis> has 4
                        interfaces:
                      
  </para>
  
                      

        <table>
	  <title></title>
	  <tgroup cols="3">
	    <tbody>

        <row>

        <entry>Interface</entry>

        <entry>Network zone</entry>

        <entry>Address</entry>
                        </row>

        <row>

        <entry><emphasis>eth0</emphasis></entry>

        <entry>external interface</entry>

        <entry>dynamic</entry>
                        </row>

        <row>

        <entry><emphasis>eth1</emphasis></entry>

        <entry>internal interface</entry>

        <entry>172.16.22.1/24</entry>
                        </row>

        <row>

        <entry><emphasis>eth2</emphasis></entry>

        <entry>DMZ</entry>

        <entry>192.0.2.1/29</entry>
                        </row>

        <row>

        <entry><emphasis>lo</emphasis></entry>

        <entry>loopback</entry>

        <entry>127.0.0.1</entry>
                        </row></tbody></tgroup></table>

        <para>
  
                  Here the publicly routable address block is very small,
                  it is just a /29 (6 usable addresses). It is assigned
                  to the DMZ interface <emphasis>eth2</emphasis>, and the firewall's address
                  is 192.0.2.1. The outside interface <emphasis>eth0</emphasis> can
                  be either dynamic or have private address. In fact,
                  this is a rather typical configuration for when your
                  firewall is behind a DSL router and segment between
                  the firewall and the router uses private addresses
                  such as 192.168.1.0. It is more useful to keep that
                  segment private and allocate all routable addresses
                  to the DMZ instead of trying to subnet the routable
                  subnet. The problem now is that a Source Address
                  translation rule should use address that belongs to
                  the DMZ interface <emphasis>eth2</emphasis> but "-o" parameter
                  should use interface <emphasis>eth0</emphasis> or should be
                  omitted all together. The "-o eth2" would not work
                  at all.
                
  </para>
  

        <para>
  
                  To do this is Firewall Builder, create an Address
                  object with an IP address equivalent to the one you
                  want to use for source NAT. Since in this example we
                  want to use address 192.0.2.1 which belongs to the
                  firewall, we call this new address object "like
                  fw-1-1:eth2:ip". This is just a regular IPv4 address
                  object, there is nothing special about it:
                
  </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="snat-address-obj-2.png"/></figure>

        <para>
  
                  Now we use it in the NAT rule:
                
  </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="snat-rule-6.png"/></figure>

        <para>
  
                  Here is what fwbuilder generates for iptables for
                  this rule:
                
  </para>
  

  <screen>

# Rule 0 (NAT)
# 
$IPTABLES -t nat -A POSTROUTING -o eth+  -s 172.16.22.0/24 -j SNAT --to-source 192.0.2.1 

                </screen>

        <para>
  
                  Compiler added "-o eth+" parameter that matches any
                  outbound interface and used address 192.0.2.1 in
                  SNAT target as required.
                
  </para>
  </sect2>

	<sect2>
        <title>"No NAT" rules</title>
  

        <para>
  
                Sometimes a firewall that is doing NAT should skip
                translation for some pairs of source and destination
                addresses. One example when this is necessary is when
                you have DMZ segment that uses private addresses, so
                you need to use NAT to provide access to servers in
                DMZ from outside, but no NAT is needed for access to
                the same servers from internal network. Here is how it
                looks like:
              
        </para>
  
        <figure float="1"><title/><graphic scale="50" fileref="fwobj-dnat-3.png"/></figure>

        <para>
          
          Firewall object <emphasis>fw-1</emphasis> has 4
          interfaces:
        </para>
  
                    

        <table>
	  <title></title>
	<tgroup cols='2'>
	<tbody>

        <row>

        <entry>Interface</entry>

        <entry>Network zone</entry>

        <entry>Address</entry>
        </row>

        <row>

        <entry><emphasis>eth0</emphasis></entry>

        <entry>external interface</entry>

        <entry>192.0.2.1/24</entry>
                      </row>

        <row>

        <entry><emphasis>eth1</emphasis></entry>

        <entry>internal interface</entry>

        <entry>172.16.22.1/24</entry>
                      </row>

        <row>

        <entry><emphasis>eth2</emphasis></entry>

        <entry>DMZ</entry>

        <entry>192.168.2.1/24</entry>
                      </row>

        <row>

        <entry><emphasis>lo</emphasis></entry>

        <entry>loopback</entry>

        <entry>127.0.0.1</entry>
        </row>
        </tbody></tgroup></table>

        <para>
          Internal interface <emphasis>eth1</emphasis> also has IPv6 address
          but it is not used in this example.
        </para>
  

        <para>
          Here is a NAT rule to permit access to the DMZ network
          (192.168.2.10) from internal network directly without
          NAT.
        </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="dnat-rule-4.png"/></figure>

        <para>
  
          Here is the script generated for iptables:
              
        </para>
  

  <screen>

# 
# Rule 0 (NAT)
# 
$IPTABLES -t nat -A POSTROUTING   -s 172.16.22.0/24 -d 192.168.2.0/24 -j ACCEPT  
$IPTABLES -t nat -A PREROUTING   -s 172.16.22.0/24 -d 192.168.2.0/24 -j ACCEPT  

  </screen>

  <para>
    
    For PF we get this:
    
  </para>
  

  <screen>

# Rule  0 (NAT)
# 
no nat proto {tcp udp icmp} from 172.16.22.0/24 to 192.168.2.0/24 
no rdr proto {tcp udp icmp} from 172.16.22.0/24 to 192.168.2.0/24 

              </screen>

        <para>
  
                For PIX Firewall Builder generates "nat 0" rule:
              
  </para>
  

  <screen>

! Rule  0 (NAT)
!
access-list nat0.inside permit ip 172.16.22.0 255.255.255.0 192.168.2.0 255.255.255.0
nat (inside) 0 access-list nat0.inside
! 

              </screen>

	</sect2>

	<sect2>
        <title>Redirection rules</title>

  

        <para>
  
                Another useful class of destination translation rule
                is the one that does redirection. Rule like this makes
                the firewall send matching packets to itself, usually
                on a different port. This rule can be used to set up a
                transparent proxy. To set up a redirection rule in
                Firewall Builder, place firewall object or one of its
                interfaces in <guilabel>Translated Destination</guilabel>. Here is an
                example:
              
  </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="dnat-rule-6.png"/></figure>

        <para>
  
                And here is what is generated for iptables:
              
  </para>
  

  <screen>

# Rule 0 (NAT)
# 
$IPTABLES -t nat -A PREROUTING  -p tcp -m tcp  -s 172.16.22.0/24 \
     --dport 80 -j REDIRECT --to-ports 3128 

              </screen>

        <para>
  
                Iptables uses special target <emphasis>REDIRECT</emphasis> for this
                kind of redirection.
              
  </para>
  

        <para>
  
                For PF we get this:
              
  </para>
  

  <screen>

# Rule  0 (NAT)
# 
rdr proto tcp from 172.16.22.0/24 to any port 80 -&gt; 127.0.0.1 port 3128 
# 

              </screen>

	</sect2>


    <sect2>
      <title>Destination NAT Onto the Same Network</title>

      <para>This situation is described in iptables HOWTO <ulink
      url="http://www.netfilter.org/documentation/HOWTO//NAT-HOWTO.html">&ipt-howto;</ulink></para>

      <para>This problem occurs when machines on an internal LAN try to access a
      server (let's say a web server) that is actually located on the same
      LAN and NAT'ed through the firewall for external access. If internal
      users access it by its external NAT'ed address, then they send their TCP
      packets through the firewall, which translates them and sends them to
      the server on LAN. The server, however, replies back to the clients
      directly because they are on the same network. Since the reply has
      server's real address in the source, clients do not recognize it and
      the connection cannot be established.</para>

      <para>To resolve this problem you need to make NAT rule to replace the source
      address of the packet with the address of firewall's internal interface.
      This should happen in addition to the translation of the destination
      address described in the previous chapters. If the source address of the
      packet that hits the server belongs to the firewall, the server replies
      to it; the firewall then translates again before sending the packet back
      to the client. Client sees the address it expects and the connection gets
      established.</para>

      <para>Fortunately, Firewall Builder supports this kind of a dual-translation NAT rule. Rule #0 in <xref
      linkend="dnat-back-to-same-net" /> does just that: it translates both the 
      source and destination addresses of the packet.</para>

      <para>The firewall's <emphasis>eth0</emphasis> interface is internal and is
      connected to the same subnet the <emphasis>web server</emphasis>
      belongs to. For any packet headed for any address of the firewall, TCP
      port 80, the rule #0 substitutes its source address with the address of
      interface <emphasis>eth0</emphasis> and its destination address with the
      address of the <emphasis>web server</emphasis>. The packet reaches the
      server because its destination address has been changed. This also makes
      the server reply back to the firewall, which in turn provides reverse
      translation before it sends these reply packets back to client
      hosts.</para>

      <figure id="dnat-back-to-same-net">
          <title>DNAT back to the same LAN</title>
              <graphic scale="60" fileref="dnat-back-to-same-net.png" />
        </figure>

      <para>Rule in <xref linkend="dnat-back-to-same-net" /> replaces source
      address of all packets regardless of their origin. Because of this, the
      web server sees all connections as if they were coming from the firewall
      rather than from the real clients. If having real client addresses in
      the web server log is necessary, the scope of this rule can be narrowed
      by placing object representing internal network in the
      <emphasis>Original Src</emphasis>. Since the source address needs to
      be translated only in the connections coming from the internal net, dual
      translation rule should only be needed for these connections.
      Connections coming from the Internet can be translated as usual.
      Combination of rules that implement this configuration is shown in <xref
      linkend="dnat-back-to-same-net-2" />. Rule #0 does dual translation,
      while rule #1 does a simple destination address translation. Dual
      translation rule must be the first in the pair because if it weren't,
      another one would match connections coming from the internal net and
      translate destination address without changing the source address.</para>

      <figure id="dnat-back-to-same-net-2">
          <title>Using dual translation only for connections coming from
          internal network</title>
              <graphic scale="60" fileref="dnat-back-to-same-net-2.png" />
        </figure>

      <note>
        <para>Not all firewall platforms provide features Firewall Builder
        needs to implement dual translation rules. Currently dual translation
        rules are supported only with iptables and OpenBSD PF.</para>
      </note>
    </sect2>



    </sect1>

  <sect1>
    <title>Useful Tricks</title>

    <!-- ********************************************************* -->


    <sect2>
      <title>How to generate firewall policy for many hosts</title>

	<para>Suppose you use Firewall Builder to generate a policy for the firewall running on a server. How can Firewall Builder help you generate a policy for it and how can you do it if you have hundreds of servers like that?</para>

	<para>For example, you could run a firewall locally on the web server that should be accessible to anyone on protocol HTTP, but other protocols used to publish content and manage the machine should be open only to a limited number of IP addresses. To configure such a firewall running on a host in Firewall Builder, create a firewall object and configure it with interfaces as usual. You will need to create a loopback interface and Ethernet (if it's a Linux machine, then it will be "eth0"). This firewall object now represents your server with a firewall running on it. You can then build a policy. Most likely you won't need NAT rules there, although there are some cases where NAT rules may be useful too. Compile the policy and transfer it to the server using the Firewall Builder installer as usual. That's it.</para>

	<para>This procedure gets really tiresome if you need to repeat it many times. This is so if you have a whole farm of servers and need to generate and install a firewall policy on each one of them. The following trick helps simplify the process if the servers are very similar (like a web servers farm) and use identical firewall policies.</para>

	<para>You need to create a firewall object as described above, except its interface "eth0" should be marked as "dynamic". Do not add an address object with IP address to it, just make it look like it gets IP address dynamically. Even if in reality it is configured statically, you make Firewall Builder believe it is dynamic. In this case, the generated firewall script will determine the actual address of the interface and then use it in the policy rules, which allows you to run the same script on many servers with different addresses. You will need to copy the firewall script from the management workstation to the servers by hand or by using some custom script. This should not be difficult though if you use SSH and RSA or DSA keys.</para>
    </sect2>
    <sect2>
      <title>Using Empty Groups</title>

	<para>This example shows how the option "Ignore empty groups" can be used to build a rule controlling access to or from an often-changing group of computers. Suppose we need to set up a rule to control access to or from a group of computers. In principle this should be easy: we create a Host object for each computer, then create a group and put all these Host objects in it. We can use this group in the Source or Destination of the policy rule to achieve our goal. If we ever need to add a new machine to the control list, we create a new Host object and add it to the group; if we need to remove the machine from the list, we just remove it from the group. But what should happen if after the last machine has been removed the group becomes empty? If the empty group is in the Source of the rule, shouldn't the compiler treat it as Any? This is confusing, to say the least.</para>

	<para>Here is how it works in Firewall Builder. The behavior of the compiler is controlled by the <guilabel>Ignore empty groups in rules</guilabel> checkbox in the "Compiler" tab of the Firewall Settings dialog. If this checkbox is off, then compiler treats empty groups as an error and stops processing of the ruleset as soon as it encounters such group. This is the default setting. However, if this checkbox is on, then compiler simply removes empty group from the rule and continues processing. This makes sense, since an empty group defines no objects and if the rule element has some other objects in it, removing an empty group does not change its meaning. It becomes tricky when the empty group is the only object in the rule element though. In this case, removing the group from the rule element makes it empty, which is equivalent to Any. All of the sudden, instead of controlling access to or from a group of hosts, the rule expands its action to any host! To avoid this unexpected side effect, compiler drops a rule if rule element becomes empty after the last empty group has been removed. Again, it works this way only if the checkbox "Ignore empty groups" is on.</para>

	<para>For example, this feature can be used to set up a rule to control Internet access from a bunch of a student computers. Suppose some students may be denied access once in a while, in which case their machine is removed from the group. If at some point of time all machines were removed from the group, the compiler would simply ignore this rule instead of inadvertently creating a hole in the policy.</para>
    </sect2>
    <sect2>
      <title>How to use Firewall Builder to configure the firewall using PPPoE</title>

	<para>If your Internet connection uses the PPPoE protocol, then your firewall should be configured with interface ppp0.</para>

	<para>With PPPoE, the connection is established using the PPP protocol that works on top of the usual Ethernet. As the result, the firewall gets interface ppp0 in addition to the interfaces eth0 and eth1 that correspond to its "normal" physical network adapters. Here is how you can use Firewall Builder to configure such a firewall (assuming interface eth0 is connected to the DSL link and eth1 is connected to internal LAN):</para>

	<orderedlist numeration="arabic">
	  <listitem>
	    <para>Create a firewall object in the GUI.</para>
	  </listitem>
	  <listitem>
	    <para>Add interfaces ppp0 and eth1. You can simply skip eth0 as it does not have an IP address and never sees IP packets.</para>
	  </listitem>
	  <listitem>
	    <para>If you have a static IP address with your Internet connection, mark ppp0 as "static" and add an address object to it. Configure the address object with the IP address.</para>
	  </listitem>
	  <listitem>
	    <para>If your Internet connection uses dynamic IP address, mark ppp0 as "dynamic" and do not add an address object to it. Create script /etc/ppp/ip-up to restart the firewall every time IP address of ppp0 changes.</para>
	  </listitem>
	</orderedlist>
    </sect2>
  </sect1>
  </chapter>

  <chapter id="Troubleshooting">
    <title>Troubleshooting</title>

    <para>This chapter provides tips for troubleshooting problems with the
    program.</para>

    <sect1>
      <title>Build and Install Startup Issues</title>

      <sect2>
        <title>autogen.sh complains "libfwbuilder not installed"</title>

	<para><emphasis>When compiling from source, autogen.sh complains "libfwbuilder
        not installed"</emphasis></para>

        <para>As of version 0.9.6 the code has been split into three major
        parts: API, GUI and policy compilers. You need to download, compile
        and install API for the rest to compile. The API comes in a separate
        source archive called libfwbuilder-0.10.0.tar.gz. Compile and install
        it as usual, using "./autogen.sh; make; make install"
        procedure.</para>
      </sect2>

      <sect2>
        <title>"Failed dependencies: ..." when installing RPM</title>

	<para><emphasis>Trying to install fwbuilder RPM but I get a bunch of errors
        "Failed dependencies: ...". What do I need to do ?</emphasis></para>

        <para>You need to install prerequisite libraries. See the list of RPMs
        in the appendix.</para>

        <note><para>Do not use options "--force" or "--nodeps" when
        you install fwbuilder RPMs. If rpm complains about unsatisfied
        dependencies, this means your system is missing some libraries, or the
        wrong versions are installed. Forcing the package install won't fix
        that; most likely it will fail in one way or another.</para></note>
      </sect2>
    </sect1>
    <sect1>
      <title>Program Startup Issues</title>

      <sect2>
        <title>"fwbuilder: cannot connect to X server localhost:0.0"</title>

	<para><emphasis>fwbuilder binary does not start. Error "fwbuilder: cannot
        connect to X server localhost:0.0" or similar</emphasis></para>

        <para>Firewall Builder GUI is an X application, that is, it needs X
        server to display it on the screen. The program determines how to
        connect to the X server using environment variable DISPLAY; you
        probably do not have this environment variable if you get an error
        like that. The simplest way to avoid this problem is to start
        fwbuilder from the shell window in Gnome or KDE environment.</para>

        <para>It may also be that the environment variable DISPLAY is set, but
        the program fwbuilder cannot connect to the X server. In this
        situation you won't be able to run any application using X, check if
        that's the case by trying to start "xclock". This may be happening
        because of many different reasons, such as X server is not running, X
        authentication failure, or DISPLAY variable reassigned its value by
        the shell login script or many others. This problem falls outside the
        scope of this document, please search on the Internet for the answer.
        Here are few URLs to make troubleshooting easier:</para>

        <para><itemizedlist spacing="compact">
            <listitem>
              <para>http://www.openssh.org/faq.html</para>
            </listitem>

            <listitem>
              <para>http://en.tldp.org/HOWTO/XDMCP-HOWTO/ssh.html</para>
            </listitem>

            <listitem>
              <para>http://en.tldp.org/LDP/intro-linux/html/sect_10_03.html</para>
            </listitem>
          </itemizedlist></para>
      </sect2>

      <sect2>
        <title>"fwbuilder: error while
        loading shared libraries: libfwbuilder.so.0: cannot load shared
        object file: no such file or directory."</title>

	<para><emphasis>fwbuilder binary does not start. Error "fwbuilder: error while
        loading shared libraries: libfwbuilder.so.0: cannot load shared
        object file: no such file or directory."</emphasis></para>

        <para>Then the GUI binary (fwbuilder) cannot find API library
        libfwbuilder. If you are using our binary packages, then make sure you
        download and install package called libfwbuilder. If you compiled from
        sources, then perhaps you installed libfwbuilder with default prefix
        /usr/local/, therefore library went to /usr/local/lib. Dynamic linker
        ldd cannot find it there.</para>

        <para>You have the following options:</para>

        <para><itemizedlist spacing="compact">
            <listitem>
              <para>create environment variable LD_LIBRARY_PATH with value
              /usr/local/lib and run fwbuilder from this environment.</para>
            </listitem>

            <listitem>
              <para>add /usr/local/lib to the file /etc/ld.so.conf and run
              ldconfig so it will rescan dynamic libraries and add them to its
              cache.</para>
            </listitem>

            <listitem>
              <para>recompile libfwbuilder and fwbuilder with prefix /usr/,
              this will install libfwbuilder.so.0 in /usr/lib. ldd will find
              it there without any changes to environment variables or
              /etc/ld.so.conf file. To change prefix you need to run
              autogen.sh with command line parameter "--prefix=/usr". Do this
              both for libfwbuilder and fwbuilder.</para>
            </listitem>
          </itemizedlist></para>
      </sect2>

      <sect2>
	<title>"fwbuilder: error while loading shared libraries: /usr/local/lib/libfwbuilder.so.8: cannot restore segment prot after reloc: Permission denied"</title>

	<para><emphasis>fwbuilder binary does not start. Error "fwbuilder: error while loading shared libraries: /usr/local/lib/libfwbuilder.so.8: cannot restore segment prot after reloc: Permission denied"</emphasis></para>

	  <para>The problem is caused by SELinux security settings, to work around it try the following command:</para>

	  <para><command>chcon -t texrel_shlib_t /usr/lib/libfwbuilder.so*</command></para>
	</sect2>         
    </sect1>
    <sect1 id="troubleshooting-compiler-runtime">
      <title>Firewall Compiler and Other Runtime Issues</title>
      <sect2>
	<title>Firewall Builder crashes</title>

	<para><emphasis>Firewall Builder or policy compiler crashes</emphasis></para>

	<para>Please file a bug on Sourceforge. Provide information we might need to fix the problem. See the <ulink url="http://www.fwbuilder.org/contact.html"><citetitle>Firewall Builder Contact</citetitle></ulink> page for links to bug tracking and instructions for filing bugs.</para>
	</sect2>
	<sect2>
	  <title>Older data file cannot be loaded in Firewall Builder</title>

	<para><emphasis>Data file created in the older version of fwbuilder cannot be loaded in the latest one</emphasis></para>

	  <para>Sometimes this happens when you skip several versions trying to upgrade the program. There used to be a bug in the upgrade procedure somewhere around version 1.0.4 which broke automatic upgrades from versions before 1.0.4 to versions after that. If this happens to you, upgrade your data file using script fwb-upgrade.sh that you can find in Contrib/Scripts area on our SourceForge site.</para>
	</sect2>
      <sect2>
	<title>"I/O Error" while compiling policy. No other error.</title>

	<para><emphasis>"I/O Error" while compiling policy. There is no other indication of error though.</emphasis></para>

	<para>Did you install package with corresponding compiler ? Our pre-built compilers come in a separate RPMs named like this: fwbuilder-ipt-2.0.2-1rh9.i386.rpm</para>

	<para>Check if compiler dumped core. If you can't find it, you may try to run compiler manually, providing the following command line parameters:</para>

	<para><command>$ fwb_ipt  -f path_to_objects.xml   firewall_object_name</command></para> 
	<para>All policy compilers have the same command line format.</para>
      </sect2>
      <sect2>
	<title>ios_base::failbit set on Windows</title>

	<para><emphasis>Policy compiler stops with an error ios_base::failbit set on Windows</emphasis></para>

	<para>It looks something like this:</para>
	<screen>
---------------------------------------
fwb_ipfw -f C:/Documents and Settings/User/data.fwb -d C:/Documents
and Settings/User -r C:\FWBuilder\resources fw

 Compiling policy for fw ...
  Detecting rule shadowing
 Begin processing
 Policy compiled successfully 
ios_base::failbit set
------------------------------------------
        </screen>
	<para>First of all, check available free disk space. Also check if the output file ( fw.fw ) is opened in another program while compiler is running. That is, if you looked at it after the previous compiler run and opened it in Notepad, it becomes locked and compiler won't be able to overwrite it with the new copy until you close Notepad.</para>
      </sect2>
      <sect2>
	<title>"Cannot create virtual address NN.NN.NN.NN"</title>

	<para><emphasis>Policy compiler stops processing rules with error message "Cannot create virtual address NN.NN.NN.NN"</emphasis></para>

	<para>This happens when you are using an option "Create virtual addresses for NAT rules". The problem is that policy compiler needs to be able to determine interface of the firewall to assign virtual address to. In order to do that it scans all interfaces trying to find subnet requested NAT address is on. Sometimes firewall's interface has an address which belongs to a different network than NAT address specified in the rule; in this case compiler cannot identify an interface and aborts.</para>

	<para>The NAT rule still can be built without "-i" or "-o" option, but automatic assignment of virtual address is impossible. You need to turn off option "Create virtual addresses for NAT rules" in the tab "Firewall" of firewall dialog and configure this address manually. </para>
      </sect2>
    </sect1>
    <sect1>
      <title>Running the Firewall Script</title>
      <sect2>
	<title>Determining which rule caused an error</title>

	<para><emphasis>I get some error when I run generated script, how can I figure out which rule causes this error?</emphasis></para>

	<para>You can turn debugging on (look for a checkbox in the tab "Firewall" in firewall dialog). This simple generates firewall script with shell option "-x" so it will print all commands while executing. This way you can see which command causes the error and trace it back to the policy rule.</para>
      </sect2>
      <sect2>
	<title>"ip: command not found"</title>

	<para><emphasis> (Linux / iptables only) I've generated script for iptables firewall using Firewall Builder, but when I run it I get an error "ip: command not found". What is this command for and what package should I install?</emphasis></para>

	<para>This tool is part of the package 'iproute'; we use it to manage virtual IP addresses needed for some NAT rules.</para>
      </sect2>
      <sect2>
	<title> I get the following error when I run generated script for iptables firewall: "iptables v1.2.8: can't initialize iptables table 'drop': Table does not exits (do you need to insmod?) Perhaps iptables or your kernel needs to be upgraded."</title>

	<para>You get this error because you used option "Log all dropped packets" (there is a checkbox in the 'Firewall' tab). This option requires "dropped" patch from patch-o-matic. You either need to turn this option off, or apply corresponding patch and recompile both kernel modules and command-line utilities for iptables.</para>
      </sect2>
      <sect2>
	<title>"Interface eth0 does not exist"</title>

	<para><emphasis>You are trying to execute iptables script generated by fwbuilder but get an error message "Interface eth0 does not exist" or similar.</emphasis></para>

	<para>There are several conditions that may cause this error.</para>

	<para>The script generated by fwbuilder uses tool /sbin/ip to verify configuration of the firewall interfaces and make sure that interfaces of the real firewall machine correspond to the interface objects created in the GUI. You may get this error if the tool /sbin/ip is not installed on your system. All modern Linux distributions come with the package iproute2 which includes /sbin/ip; check if iproute2 is installed and /sbin/ip exists.</para>

	<para>Another case when you may encounter this error is when firewall script is executed prematurely during the boot sequence and interface really does not exist at that time. For example, interface ppp0 is created only when the system is configured for PPP and daemon pppd is running. If firewall script is activated before the daemon started during the boot sequence, interface ppp0 is not there yet, which leads to this error. Make sure you start firewall script after all interfaces has been initialized.</para>
      </sect2>
      <sect2>
	<title>"Interface eth0:1 does not exist"</title>

	<para><emphasis>My firewall has virtual interface eth0:1. In fwbuilder I added the interface, however, when I want to apply the new rules I get the error "Interface eth0:1 does not exist"</emphasis></para>

	<para>eth0:1 is not a real interface on Linux, it is just a label for a second IP address of the interface eth0. One way to solve this is not to create it in the OS (remove file /etc/sysconfig/network-scripts/ifcfg-eth0:1 and restart networking), but rather add its IP address in the Firewall Builder GUI as a second address to interface eth0.</para>

	<para>In any case you should not add interface "eth0:1" in fwbuilder because it really does not exist. Iptables will not recognize this interface either, so even if fwbuilder let you use it, you would get an error from iptables. You see "eth0:1" in the output of ifconfig only because ifconfig has been modified on Linux to show virtual IP addresses as pseudo-interfaces. The command "ip addr show" will reveal that the eth0:1 is really a label on the second IP address of eth0.</para>
      </sect2>
      <sect2>
	<title>Script fails to load module nf_conntrack</title>

	<para><emphasis>Generated script fails to load module nf_conntrack when it is executed on the firewall</emphasis></para>
	<para>This problem is specific to iptables. The answer below has been written in September 2006, most likely the situation and relevant recommendations are going to change in the future as module nf_conntrack matures and gets wider deployment.</para>

	<para>Here is an example of an error message:</para>
	<screen>
FATAL: Error inserting nf_conntrack_ipv4
(/lib/modules/2.6.13-15.11-default/kernel/net/ipv4/netfilter/nf_conntrack_ipv4.ko):
Device or resource busy
        </screen>

	<para>Here is the <ulink url="http://www.netfilter.org/projects/patch-o-matic/pom-extra.html#pom-extra-nf_conntrack"><citetitle>link</citetitle></ulink> to the nf_conntrack page in patch-o-matic catalog. Here is the <ulink url="http://lists.netfilter.org/pipermail/netfilter-devel/2006-July/024879.html"><citetitle>link</citetitle></ulink> to the discussion on netfilter-devel mailing list.</para>

	<para>It appears you can load either ip_conntrack or nf_conntrack but not both at the same time since nf_conntrack is a replacement for ip_conntrack. As of this writing, nf_conntrack does not support NAT just yet and is marked as having status "TESTING" on the patch-o-matic catalog page.</para>

	<para>This actually represent a problem for fwbuilder. I would like to avoid having to write extensive GUI to let user choose which modules they want to load. One of the reasons is that the GUI may be working on one machine, while generated firewall script will be executed on another. In this situation the GUI cannot determine which modules are available on the firewall. Currently generated script simply tries to load all modules but it aborts if it detects an error in the command that does it (modprobe).</para>

	<para>Until better solution is found, you would probably need to remove module that conflicts with others or disable feature that makes generated script load modules and write your own script to load modules you need. You can for example add commands to load modules explicitly to the "prolog" section of the generated script.</para>
      </sect2>
    </sect1>
 <!-- ############################################################### -->
    <sect1 id="policy-importer">
      <title>Using Built-in Policy Importer in Firewall Builder</title>

          <para>
  
                  There are two ways to activate the feature: Main
                  menu <guimenuitem>File/Import Policy</guimenuitem> or
                  <guimenuitem>Tools/Discovery Druid</guimenuitem> and then
                  choose option <guilabel>Import configuration of a
                  firewall or a router</guilabel>.  Only the import of
                  iptables and Cisco IOS access lists is possible in
                  the current version.
                
          </para>
  

      <sect2>
        <title>Importing existing iptables configuration</title>
          <para>
  
                  Firewall Builder imports iptables configs in
                  the format of iptables-save. Script <command>iptables-save</command> is part
                  of the standard iptables install and should be
                  present on all Linux distribution. Usually this
                  script is installed in <emphasis>/sbin/</emphasis> . When you run
                  this script, it dumps the current iptables configuration
                  to stdout. It reads iptables rules directly form the
                  kernel rather than from some file, so what it dumps
                  is what is really working right now. To import this
                  into Firewall Builder, run the script to save the configuration
                  to a file:
                
          </para>
  
  <screen>
iptables-save &gt; iptables_config.conf
                </screen>

          <para>
  
                  Then launch Firewall Builder, activate the <guimenuitem>Import
                  Policy</guimenuitem> function and click <guibutton>Browse</guibutton> to find <filename>iptables_config.conf</filename>. You also
                  need to choose <guimenuitem>iptables</guimenuitem> in the <guilabel>Platform</guilabel> pull-down
                  menu.
                
          </para>
  

          <para>
  
                  If you do not choose "iptables" in 
                  <guilabel>Platform</guilabel>, the program will try to
                  interpret the file using a different parser and will
                  fail. The program does not make any assumptions
                  about the file name or extension and cannot predict
                 the source platform of the configuration.
                
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="importer_1.png"/></figure>

	<sect3>
        <title>Importing an iptables configuration created in FireStarter</title>

          <para>
  
                  The following example demonstrates an import of an
                  iptables policy generated by <emphasis>Firestarter</emphasis>,
                  another popular iptables configuration management
                  program.
                
          </para>
  

          <para>
  
                  After the platform is selected and file name
                  entered, click <guibutton>Next</guibutton> to start the process.
                
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="importer_2.png"/></figure>

          <para>
  
                  The program tries to interpret the configuration file
                  rule-by-rule and recreates its equivalent in
                  Firewall Builder. The progress window displays errors, if
                  any, as well as some diagnostics that shows network
                  and service objects created in the process. Note
                  that user-defined iptables chains found in the
                  configuration file will be re-created in Firewall Builder
                  as policy rule sets. The screenshot shows rulesets
                  "LSI", "LSO", "OUTBOUND" being created. (There were
                  more but they did not fit in the output
                  window.) Address objects "h-10.3.14.10",
                  "h-10.3.14.255" and few others have been created as
                  well. Service objects "tcp fsra/s", "udp 0-0:0-0",
                  "icmp -1/-1" and few others have also been created.
                
          </para>
  

          <para>
  
                  Note that the new firewall object created in the
                  process has generic name "New Firewall". This is
                  because iptables configuration file used for import
                  does not have information about firewall machine
                  name. It also does not have information about its
                  interfaces, their names and addresses. The program
                  can infer their names when it encounters
                  "-i &lt;interface&gt;" or "-o &lt;interface&gt;" clauses in the
                  iptables configuration lines. It cannot reliably
                  detect their addresses though. You need to manually rename the
                  firewall object and add IP addresses to interfaces
                  after the import.
                
          </para>
  

          <para>
  
                  Note also that only the IPv4 part of the iptables
                  configuration was imported. Currently, import of
                  IPv6 iptables configuration is not supported.
                
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="importer_3.png"/></figure>

          <para>
  
                  Screenshot above shows rule sets that the
                  program created from the configuration it
                  imported. Rule sets "INBOUND", "LOG_FILTER", "LSI",
                  "LSO", "OUTBOUND", "Policy" are all of the type
                  "Policy" and contain filtering rules. There were no
                  NAT rules in the original configuration so the rule
                  set "NAT" is created but is empty. The names of all
                  policy rule sets match names of the iptables chains
                  in the original configuration.
                
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="importer_7.png"/></figure>

        <figure float="1"><title/><graphic scale="50" fileref="importer_8.png"/></figure>

        <figure float="1"><title/><graphic scale="50" fileref="importer_9.png"/></figure>

          <para>
  
                  Screen shots above demonstrate address and service
                  objects created by the program. The importer writes a comment
                  in each object to remind you that the object was created
                  automatically on import. Names of these objects are
                  chosen automatically, but you can rename objects to give
                  them more meaningful names. Some of the objects
                  created during import have the same properties as
                  existing service and address objects from the
                  Standard objects library. Currently the program does
                  not cross-match them and just creates new objects,
                  however in the future it may use Standard objects
                  instead.
                
          </para>
  

          <para>
  
                Some rules in the original iptables config used
                "--tcp-flags" parameter to match only certain
                combinations of tcp flags. Here is an example:
              
          </para>
  

  <screen>
-A INPUT -s 10.3.14.10 -p tcp -m tcp ! --tcp-flags FIN,SYN,RST,ACK SYN -j ACCEPT 
              </screen>

          <para>
  
                In order to be able to reproduce this rule, Firewall Builder
                created a special TCP service object with given
                combination of tcp mask and flags:
              
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="importer_10.png"/></figure>

          <para>
  
                  The following screenshot shows rules created
                  in the main Policy rule set. These are the top
                  iptables rules, though some of them branch off to the other
                  Policy rule sets. Some of the rules in the original
                  policy did not match state (did not have clause "-m
                  state --state NEW" or similar), these rules were
                  created with the flag "stateless" turned on. In
                  Firewall Builder, this makes the policy compiler generate
                  iptables commands without a "-m state --state NEW"
                  clause that matches the original.  These rules are
                  marked with an icon that represents non-default rule
                  options in the column <guilabel>Options</guilabel>.
                
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="importer_14.png"/></figure>

          <para>
  
                  Let's inspect one group of rules a little closer. The
                  original iptables file contained the following
                  commands:
                
          </para>
  

  <screen>

-A INPUT -i eth0 -j INBOUND 


-A INBOUND -p tcp -m state --state RELATED,ESTABLISHED -j ACCEPT 
-A INBOUND -p udp -m state --state RELATED,ESTABLISHED -j ACCEPT 
-A INBOUND -s 10.3.14.0/255.255.255.0 -j ACCEPT 
-A INBOUND -s 10.3.14.0/255.255.255.0 -p tcp -m tcp --dport 22 -j ACCEPT 
-A INBOUND -s 10.3.14.0/255.255.255.0 -p udp -m udp --dport 22 -j ACCEPT 
-A INBOUND -j LSI 

                </screen>

          <para>
  
                  The first rule is in chain INPUT and was recreated
                  as rule #11 in the Policy rule set (rule colored
                  green). Since it was in INPUT, the destination
                  object in the rule #11 is the firewall itself. The
                  "-i eth0" clause translated into interface object
                  "eth0" in the "Interface" rule element and direction
                  "Inbound". The action of the rule #11 is "Branch",
                  pointing to the rule set "INBOUND". This is direct
                  re-creation of the original rule in the iptables config.
                
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="importer_15.png"/></figure>

          <para>
  
                  This screenshot demonstrates rules created in the
                  rule set "INBOUND". Rule #0 matches CustomService
                  object "custo-0-tcp" that was created to match a 
                  combination of protocol "tcp" and state
                  "RELATED,ESTABLISHED". This object is shown in the
                  following screenshot:
                
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="importer_11.png"/></figure>

          <para>
  
                  Firewall Builder automatically adds a rule on top of the 
                  generated iptables script to match packets in states
                  "ESTABLISHED, RELATED". With that rule, it is not
                  necessary to have a rule like #0 in INBOUND, but
                  since the original script had it, Firewall Builder reproduced
                  it.
                
          </para>
  

          <para>
  
                  Rule #1 in INBOUND matches protocol UDP and state
                  "ESTABLISHED,RELATED". Other rules in INBOUND
                  reproduce original rules from the chain INBOUND and
                  match packets coming from the local net heading for
                  the firewall machine. It is easy to see that the
                  original policy was redundant: rules #2-4 match the
                  same source and destination addresses but different
                  services, but rule #2 matches any service which
                  means rules #3 and 4 will never match any
                  packets. Fwbuilder will detect this problem
                  automatically if you try to compile this policy
                  (this is called "Rule shadowing").
                
          </para>
  

          <para>
  
                  All packets not matched by any rule in INBOUND will
                  match the last rule in this rule set, which branches to
                  the rule set LSI. Rule set LSI logs various packets
                  and drops them:
                
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="importer_16.png"/></figure>

          <para>
  
                  You might wonder why we have all these rules
                  with action "Continue".
                
          </para>
  

          <para>
  
                  When a rule is marked as "logging" in Firewall Builder, it
                  gets an icon in the column "Options" that represents
                  logging. This icon appears either by itself or next to
                  the icon that represents non-default rule
                  options. However, iptables does not allow for an
                  action "Accept" or "Deny" to be used in combination
                  with logging. In iptables, logging is a separate target
                  just like "ACCEPT" or "DROP". Because of that,
                  Firewall Builder splits a rule that has action "Accept" or
                  "Deny" or any other with logging turned on. One such
                  rule becomes two or more iptables rules in the
                  generated script. Unfortunately when iptables script
                  is imported back, the program cannot merge such
                  rules and logging rules appear in the rule set as
                  separate rules with a logging icon in the "Options"
                  column and action "Continue". This is a valid
                  configuration in Firewall Builder, it just means that the
                  rule generates a log record but does not make any
                  decision whether the packet should be accepted or
                  denied.
                
          </para>
  

          <para>
  
                  Here is the fragment of the original iptables rules in
                  the chain LSI:
                
          </para>
  

  <screen>
-A LSI -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN \
    -m limit --limit 1/sec -j LOG --log-prefix "Inbound " --log-level 6 
-A LSI -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -j DROP 
                </screen>

          <para>
  
                  These rules become rules #1 and 2 in rule set LSI in
                  Firewall Builder. The first rule, the one that does
                  logging, becomes a separate rule because this is how
                  it is done in iptables. If this policy was created
                  in Firewall Builder, rules #1 and 2 would be just one rule
                  in the GUI.  Double-clicking in the column <guilabel>Options</guilabel>
                  in rule #1 opens a dialog where you can inspect and
                  edit its options. The <guilabel>Limit</guilabel> tab in this dialog
                  controls parameters in the iptables "limit" module, which
                  was used in the original rule. Screenshot below
                  demonstrates how the policy importer recognized these
                  parameters and reproduced them in the rule options:
                
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="importer_17.png"/></figure>

      </sect3>

      <sect3>
        <title>Limitations</title>

          <para>
  
                  The iptables policy importer in Firewall Builder has its
                  limitations. The main limitation is that it can only
                  parse certain set of iptables modules and
                  targets. There are too many modules and associated
                  targets out there and supporting all of them is next
                  to impossible. However, it supports the core
                  functionality and most popular modules. Even though the 
                  importer tries to match the original
                  configuration as closely as possible, you should always review the 
                  rules and objects it creates and edit resulting
                  rules. Most of the time rules can be simplified,
                  such as with logging rules as was explained
                  above. Often you can merge multiple rules by putting
                  several objects in a <guilabel>Source</guilabel> or <guilabel>Destination</guilabel> or
                  <guilabel>Service</guilabel> field. Using Object and Service groups is another
                  good way to simplify rules.
                
          </para>
  
	</sect3>
      </sect2>

      <sect2>
        <title>Importing Cisco IOS access lists configuration</title>

          <para>
  
                  Importing an IOS access lists configuration is more
                  straightforward because branching is not possible
                  there. To import a configuration, first you need to
                  save it using the <command>show run</command> command. IOS has literally
                  hundreds of different commands and configuration
                  clauses, but Firewall Builder can only parse those related
                  to the access lists configuration. Other commands
                  will be ignored. There is no need to edit the 
                  configuration prior to importing it into Firewall Builder
                  (except for the "banner" command, see below). </para>

	  <para>A saved
                  IOS configuration has information about the router's name
                  and its interfaces. This information will be used to
                  recreate objects in Firewall Builder. Parser will not only
                  create interface objects with proper names, it will
                  also attach address objects to them to describe
                  their IP addresses.
                
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="importer_20.png"/></figure>

          <para>
  
                  As with iptables, we start with
                  <guimenuitem>File/Import Policy</guimenuitem> and enter the filename in
                  the dialog. The <guilabel>Platform</guilabel> pull-down menu
                  should be set to <guimenuitem>Cisco IOS</guimenuitem>. Click <guibutton>Next</guibutton> to
                  start the import process.
                
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="importer_21.png"/></figure>

          <para>
  
                  The program recognized router name "c3620" and its
                  interfaces, created interface objects with their IP
                  addresses and then created some address and service
                  objects. This test router config contains the
                  following lines (this is just a fragment, there are
                  more interfaces and more ACLs):
                
          </para>
  

  <screen>

interface FastEthernet0/0
 ip address 192.168.100.100 255.255.255.0 secondary
 ip address 10.3.14.201 255.255.255.0
 ip access-group fe0_0_acl_in in
 ip access-group fe0_0_acl_out out
 no ip mroute-cache
 duplex auto
 speed auto
!
interface Ethernet1/0
 description Test [test] {test} (and one more test) /weird:characters#$%^&amp;*/
 ip address 192.168.171.2 255.255.255.0
 ip access-group e1_0_acl_in in
 ip access-group e1_0_acl_out out
 no ip mroute-cache
 ip ospf cost 65000
 half-duplex
 crypto map real


!################################################################
ip access-list extended e1_0_acl_in
 deny   ip any any fragments
 permit tcp host 10.3.14.40 host 192.168.171.2 eq 22 log
 permit tcp host 10.3.14.40 host 10.3.14.201 eq 22 log
 permit ip any 10.3.14.0 0.0.0.255 log
 deny   ip any any log
!################################################################
ip access-list extended e1_0_acl_out
 permit ip 10.3.14.0 0.0.0.255 any log
 deny   ip any any log

                </screen>

          <para>
  
                  The parser recognizes comments and skips them, but text
                  from interface descriptions goes into comments in
                  the Interface objects.
                
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="importer_22.png"/></figure>

          <para>
  
                  Firewall Builder recognizes both named and regular
                  extended access lists. Each separate access list is
                  recreated in Firewall Builder in the same main Policy rule
                  set. The program recognizes "ip access-group"
                  commands and puts the corresponding interface object in
                  the "Interface" rule element of the rules it
                  creates.
                
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="importer_30.png"/></figure>

          <para>
  
                  The original configuration used the same access list
                  "133" with two interfaces:
                
          </para>
  

  <screen>

interface Ethernet1/1
 ip address 10.10.10.10 255.255.255.0
 no ip mroute-cache
!
!  Note - the same access list applied both in and out
 ip access-group 133 in
 ip access-group 133 out
 no shutdown
 half-duplex
!
interface Ethernet1/2
 ip address 10.10.20.20 255.255.255.0
 no ip mroute-cache
!
!  Note - the same access list applied both in and out
!  the same list is applied to eth 1/1 and eth 1/2
 ip access-group 133 in
 ip access-group 133 out
 no shutdown
 half-duplex
!
                </screen>

          <para>
  
                  The program recognizes this and creates object group
                  "intf-acl_133" with these two interfaces as members:
                
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="importer_31.png"/></figure>

          <para>
  
                  It then uses this group in the <guilabel>Interface</guilabel> element
                  of rules #0, 1 and 2 to reproduce rules from the
                  access list "133".
                
          </para>
  

          <para>
  
                  Interface configuration commands visible in the
                  config snippets above, such as "half-duplex",
                  "duplex auto", "speed auto", various protocol
                  configuration commands and other commands supported
                  by IOS inside the "interface" block are ignored.
                
          </para>
  
	<sect3>
        <title>Limitations</title>

          <para>
  
                  One IOS configuration construct that Firewall Builder can
                  not import is the "banner" command. This command is
                  special in that it allows you to set an arbitrary
                  terminator character, and then it allows any text up
                  to this character. This creates a problem for the
                  Firewall Builder parser because the terminator character
                  can be arbitrary. You need to edit and remove banner
                  from the saved configuration file before importing
                  it.
                
          </para>
	</sect3>
      </sect2>
    </sect1>
 <!-- ############################################################### -->
    <sect1 id="rcs-troubleshooting">
      <title>RCS Troubleshooting</title>
      <sect2>
	<title>Error adding file to RCS</title>

	  <para><emphasis>Error adding file to RCS: Fatal error during initial RCS checkin of file</emphasis></para>

	  <para>You will get this error if you do not have RCS set up on your system. To resolve it, install and configure RCS on the workstation running Firewall Builder.</para>
      </sect2>
      <sect2>
	<title>"Error checking file out: co: RCS file c:/fwbuilder/RCS/file.fwb is in use"</title>

	<para><emphasis>I cannot open my data file, I get error "Error checking file out: co: RCS file c:/fwbuilder/RCS/file.fwb is in use"</emphasis></para>

	<para>A catastrophe (e.g. a system crash) can cause RCS to leave behind a semaphore file that causes later invocations of RCS to claim that the RCS file is in use. To fix this, remove the semaphore file. A semaphore file name typically begins with , or ends with _.</para>

	<para>If not that, then it could be another manifestation of bug #1908351</para>

	<para>See if there is a file with the name starting and ending with a comma in the RCS directory (like ",file.fwb,"). The file should have length of zero bytes. This file is a lock file, it is created and deleted by RCS tools. Bug 1908351 caused this lock file to be left behind. When that happens, ci won't check file in because it thinks another copy of ci is already running. Likewise, co won't check the file out for the same reason. If such file exists (zero bytes in length and name starting or ending with a comma), just delete it and try to check your data file out again.</para>
      </sect2>
      <sect2>
	<title>"Error checking file out:"</title>
	<para><emphasis>I cannot open my data file, I get error "Error checking file out:"</emphasis></para>

	<para>Such non-descriptive error message is usually caused by hard unrecoverable errors experienced by RCS tools. Unfortunately these tools not always report errors in the best way possible and when this happens, Firewall Builder GUI cannot provide any better diagnostics than it gets from the tool. Such poor diagnostics of errors happens more frequently on Windows than on other platforms.</para>

	<para>Here are few things to check and try:</para>
	<itemizedlist>
	  <listitem><para>First of all, check file permissions. The data file (.fwb) should be read-only. RCS repository file (.fwb,v) should also be read-only. Repository file may be located in subdirectory RCS but that depends on the OS. It may be located in the same directory with corresponding data file (.fwb) as well.</para></listitem>
	  <listitem><para>Try to check the file out manually to see if you can get better diagnostics:</para>
	  <para>If you use Windows, start MS DOS window and in it navigate to the folder where you keep your files, then execute the following command:</para>
	  <screen>c:\FWBuilder\co.exe -l filename.fwb</screen>
	  <para>If it checks the file out successfully, it just prints revision number and 'done'. Otherwise it will print some error.</para>
	  <para>After you do that, you need to check the file in to RCS again. Do it like this:</para>
	  <screen>c:\FWBuilder\ci.exe -u filename.fwb</screen>
	  <para>Since the file hasn't changed, it should just check it in without asking you for the RCS log record. If you can successfully check it out and then check it in again from the command line, then the GUI should work too.</para>
	  <para>On Linux, *BSD and Mac OS X the process is exactly the same, except for the path to the checkout and checkin commands:</para>

	  <para>To check the file out use</para>
	  <screen>co -l filename.fwb</screen>
	  <para>
      To check the file in use
	  </para>
	  <screen>ci -u filename.fwb</screen>
	  </listitem>
	</itemizedlist>
      </sect2>
    </sect1>
    <sect1>
      <title>Firewall Issues after new policy</title>

      <sect2>
        <title>Cannot access only some web sites</title>

	<para><emphasis>Can access most web sites through the firewall just fine,
        except for a few.</emphasis></para>

        <para>The browser would state "waiting for www.somesite.com" for a
        while and then time out when you connect to one of these sites.</para>

        <para>This might be caused by a MTU problem if you are on a DSL
        connection using PPPoE. Here are couple of useful pages that describe
        the problem in details:</para>

        <para><itemizedlist spacing="compact">
            <listitem>
              <para>http://www.dslreports.com/tweaks/MTU</para>
            </listitem>

            <listitem>
              <para>http://www.internetweekly.org/llarrow/mtumss.html</para>
            </listitem>
          </itemizedlist></para>

        <para>If your firewall runs iptables you can use option "Clamp MSS to
        MTU" in the firewall settings dialog to work around it.</para>

        <para>For the PF firewalls similar option is called "Enforce maximum
        MSS" and is located in the "Scrub rule options" tab of firewall
        settings dialog. It allows for setting MSS value of TCP sessions
        opened through the firewall; try values between 1460 or 1464 (1464 is
        the maximum MSS value that can be used on PPPoE connections without
        fragmentation).</para>

        <para>There is no way to change MSS value on the ipf, ipfw and pix
        firewalls. If your firewall is one of these, you may need to change
        MTU on your workstation. See links above for recommendations on how to
        do it.</para>
      </sect2>

      <sect2>
	<title>Firewall becomes very slow with new policy</title>

	<para>You compiled and started firewall policy script and then noticed that seemingly every operation on the firewall takes a lot longer than before. For example, it takes forever to log into it using telnet or ssh, different services take a few minutes to start or won't start at all.</para>

	<para>Most likely the firewall needs to be able to do DNS lookups but can't. Look in /etc/resolv.conf for the address of the name server it is using and make sure you have a rule in the policy to permit connections to it. Use firewall object in "Source", the name server object in "Destination" and a standard service object group "DNS" in the Service field.</para>

	<para>If your firewall runs caching name server and file /etc/resolv.conf lists "127.0.0.1" as a name server address, then you need to permit firewall to talk to itself. Here is how such /etc/resolv.conf file looks like:</para>
<screen>
    domain your_domain.com
    nameserver 127.0.0.1 
</screen>
	<para>You need to add a rule with the firewall object in both Source and Destination fields and the service object group "DNS" in the Service field to the loopback interface. This rule permits the firewall machine to communicate with the name server running on it, but you need another rule to permit the name server to send DNS queries and receive answers. This rule should have the firewall object in Source, Destination should be set to "any" and the same standard service object group "DNS" should be used in the Service element. Now not only firewall can query the name server process running on it, but the process in turn can send queries to other name servers on the Internet and receive answers.</para>

	<para>Here is the rule that should be added to the loopback interface:</para>

      <figure float="1" id="dns1">
        <title>DNS on loopback</title>
            <graphic scale="70" fileref="dns1.png" />
      </figure>

	<para>Here is the rule that permits the name server process to communicate with name servers on the Internet:</para>

      <figure float="1" id="dns2">
        <title>DNS on to name servers</title>
            <graphic scale="70" fileref="dns2.png" />
      </figure>

	<para> Depending on your policy design, you may want to permit all services rather than just DNS on the loopback interface because there are many other processes that need to be able to communicate with the same host, such as X11, RPC and others. The dedicated firewall machine should not run anything unnecessary, so there you may experiment with limiting the number of services in the rule on loopback the interface. On the other hand, if you use fwbuilder to protect a server that runs many different services, permitting any service on the loopback may be a simpler solution.</para>

	<para>The next rule permits processes running on the firewall to communicate with other processes running on the same machine on all protocols:</para>

      <figure float="1" id="dns3">
        <title>Any to any on firewall</title>
            <graphic scale="70" fileref="dns3.png" />
      </figure>
      </sect2>

      <sect2>
	<title>X won't start on a server protected by the firewall</title>

	<para>You've built a firewall script to protect a server, but after you ran the script, X (KDE, Gnome) won't start anymore.</para>

	<para>The reason for this is the same as in the DNS problem&mdash;you need a rule to permit processes to communicate with other processes running on the same machine. This can easily be achieved with the following rule added to the loopback interface:</para>

      <figure float="1" id="dns3-1">
        <title>Any to any on firewall</title>
            <graphic scale="70" fileref="dns3.png" />
      </figure>

      </sect2>

      <sect2>
        <title>Cannot access Internet from behind firewall</title>

	<para><emphasis>I compiled and activated firewall policy, but workstations
        behind the firewall still cannot access the Internet.</emphasis></para>

        <para>Here are few troubleshooting steps:</para>

        <para><itemizedlist spacing="compact">
            <listitem>
              <para>Make sure you compiled, then installed and activated
              firewall policy. Were there any errors during compile and
              activation?</para>
            </listitem>

            <listitem>
              <para>check if ip forwarding is turned on (pull down menu in the
              "Network" tab of the firewall object dialog).</para>
            </listitem>

            <listitem>
              <para>try to ping hosts on the Internet by their IP address, not
              their name. This helps isolate DNS problems. If you can ping by
              address but can't ping by name, then you need to add policy
              rules to permit DNS queries.</para>
            </listitem>

            <listitem>
              <para>Look in firewall's log for records indicating that it
              drops packets. Error in the policy design can cause it to block
              connections that you really want to go through.</para>
            </listitem>

            <listitem>
              <para>Use option "Log everything" to make all rules generate log
              entries, this sometimes helps pinpoint a rule that drops
              packets.</para>
            </listitem>
          </itemizedlist></para>

        <para>Things to check in the policy:</para>

        <para><itemizedlist spacing="compact">
            <listitem>
              <para>Check if you have a NAT rule if your protected network is
              using "private" IP addresses.</para>
            </listitem>

            <listitem>
              <para>If the NAT rule is there, then you may need to add a
              policy rule to actually permit connections from the protect
              network.</para>
            </listitem>

            <listitem>
              <para>In case when NAT is not used, check if the routing is
              configured properly. If your firewall separates subnets A and B,
              and you are trying to connect from the host on subnet A to the
              host on subnet B, then both hosts should have routing to the
              opposite network. Host on the net A needs a route for the net B,
              pointing at the firewall. Similarly, host on the net B needs a
              route for the net A, also pointing at the firewall. If one (or
              both) host has a default route pointing at the firewall, then it
              won't need a special route for another network.</para>
            </listitem>
          </itemizedlist></para>
      </sect2>
    </sect1>
    <sect1>
      <title>Routing Rules Issues</title>
       <sect2>
	<title>Compile fails with dynamic or point-to-point interfaces</title>

	<para><emphasis>Compile fails with dynamic or point-to-point interfaces</emphasis></para>

	  <para>If you have interfaces with a dynamic address or a point-to-point address and you try to insert a routing rule for the default gateway, compilation might fail, stating "gateway not reachable". Typically this is the case for DSL dial-up links. Solution: leave the gateway field empty.  Just specify the interface.</para>
	</sect2>
    </sect1>
  </chapter>

 <!-- ############################################################### -->

 
</book>
