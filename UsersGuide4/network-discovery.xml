<?xml version="1.0"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
                 "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

  <chapter id="discovery">
    <title>Network Discovery: A Quick Way to Create Objects</title>

    <para>One of the distinguishing features that Firewall Builder provides is
    support for automated object creation. This helps populate the objects
    tree for large networks with lots of hosts and subnets. What might take hours to do manually, the
    Discovery Druid wizard can help you do in minutes.</para>

    <para>To start the Discovery Druid, select 
    <guimenuitem>Tools</guimenuitem>/<guimenuitem>Discovery
    Druid</guimenuitem>.</para>

    <para>The Discovery Druid supports three main methods for automated object
    creation:</para>

    <para><itemizedlist spacing="compact">
        <listitem>
          <para>Reading file /etc/hosts</para>
        </listitem>

        <listitem>
          <para>Network discovery using SNMP queries</para>
        </listitem>

        <listitem>
          <para>Import the configuration of a firewall or router</para>
        </listitem>
      </itemizedlist></para>

    <para>You choose the method on the first page of the Druid ( <xref
    linkend="discovery-page1" />. )</para>

    <figure id="discovery-page1">
      <title>Calling The Object Discovery Druid</title>
          <graphic scale="70" fileref="discovery-druid1.png" />
    </figure>

    <para>Just check the radio-button next to the method you want to use and
    click <guibutton>'Next</guibutton>.</para>

    <sect1 id="import_from_hosts">
      <title>Reading the /etc/hosts file</title>

      <para>This method imports the host records present in the standard
      <emphasis>/etc/hosts</emphasis> file or any other file that contain
      records in the following format (this format is actually described in
      the manual page hosts(5)).</para>

      <para>IP_Address host_name</para>

      <para>The IP address must be separated from the host name with any
      number of spaces or tab symbols. Lines starting with '#' are considered
      comments and are ignored.</para>

      <para>When you choose the import from /etc/hosts on the first page, the
      Druid asks you for the file path and name on the next page. Once that
      information is entered, it reads the contents of that file and presents
      a table of new networks (<xref linkend="discovery-hosts-1" />).</para>

      <figure id="discovery-hosts-1">
        <title>Choose the file for import</title>
        <graphic scale="70" fileref="discovery-druid-hosts1.png" />
      </figure>

      <para>
        Once you have chosen the file, click Next to let the program
        read and parse it. The file should be in "/etc/hosts" format,
        that is it should have an address and host name on each line,
        separated by any number of while spaces. Here is an example:
      </para>

      <programlisting>
192.2.0.1 test1
192.2.0.2 test2
10.1.1.2  serv2
10.1.1.3  serv3
      </programlisting>

      <figure id="discovery-hosts-2">
        <title>Parsing a file in hosts format</title>
        <graphic scale="70" fileref="discovery-druid-hosts2.png" />
      </figure>

      <para>
        Once the program finishes import, you can click Next to move
        on to the next page where you can choose which of the
        addresses you want to use:
      </para>

      <figure id="discovery-hosts-3">
        <title>Choosing which addresses should be used</title>
        <graphic scale="70" fileref="discovery-druid-hosts3.png" />
      </figure>

      <para>
        You can select any number of addresses in the left panel and
        use buttons "--&gt;" and "&lt;--" to add or remove them to the
        panel on the right. Buttons "Select All" and "Unselect All"
        help to work with large lists of addresses.
      </para>

      <figure id="discovery-hosts-4">
        <title>Choosing which addresses should be used</title>
        <graphic scale="70" fileref="discovery-druid-hosts4.png" />
      </figure>

      <para>
        Choose object library where new address objects should be
        created on the next page:
      </para>

      <figure id="discovery-hosts-5">
        <title>Choosing object library</title>
        <graphic scale="70" fileref="discovery-druid-hosts5.png" />
      </figure>

      <para>
        Once you click Finish, object are created and shown in the
        tree:
      </para>

      <figure id="discovery-hosts-6">
        <title>New address objects are shown in the tree</title>
        <graphic scale="70" fileref="discovery-druid-hosts6.png" />
      </figure>



    </sect1>

    <sect1 id="network-discovery">
      <title>Network Discovery</title>

      <para>
        Another powerful way to find addresses of subnets and hosts on
        the network is to use snmp crawler.
      </para>

      <figure id="discovery-snmp-seed">
        <title>Initial Parameters for the Network Discovery program</title>
        <graphic scale="70" fileref="discovery-druid2.png" />
      </figure>

      <para>
        The Network discovery program (sometimes referred to as the
        "Network Crawler") needs a host to start from. This host is called the
        "seed host"; you enter it in the first page of the Druid (
        <xref linkend="discovery-snmp-seed" />). The crawler implements the following
        algorithm (this is a somewhat simplified explanation):</para>

      <para>
        First, it runs several SNMP queries against the seed host
        trying to collect the list of its interfaces and its ARP and
        routing tables. This host is then added to the table of
        discovered network objects, together with its interfaces,
        their addresses and netmasks, and the host's "sysinfo"
        parameters. Then the crawler analyses the routing table of
        that host; this allows it to discover the networks and
        subnets, which in turn are also added to the list of
        discovered objects. Then it analyses the ARP table, which
        holds MAC and IP addresses of neighboring hosts. It takes one
        host at a time from this table and repeats the same algorithm,
        using the new host as a seed host. When it pulls an ARP table
        from the next host, it discards entries that describe objects
        it already knows about. However if it finds new entries, it
        tries them as well and thus travels further down the
        network. Eventually it will visit every host on all subnets on
        the network.
      </para>

      <para>
        This algorithm relies on hosts answering to the SNMP
        queries. If the very first host (the "seed" host) does not run
        SNMP agent, the crawler will stop on the first run of its
        algorithm and won't find anything. Therefore it is important
        to use a host which does run SNMP agent as a "seed" host. Even
        if most of the hosts on the network do not run SNMP agents,
        but a few do, the crawler will most likely find all of
        them. This happens because it discovers objects when it reads
        the ARP tables from the host which answers; so even if
        discovered hosts do not answer to SNMP queries, the crawler
        already found them anyway.
      </para>

      <para>
        One of the ways to limit the scope of the network that the
        crawler will visit is to use the "Confine scan to the network"
        parameter. You need to enter both a network address and a
        netmask; the crawler will then check if the hosts it discovers
        belong to this network and if they do not, discard
        them.
      </para>

      <figure id="discovery-snmp-options">
        <title>Parameters for Network Discovery: Page 1</title>
        <graphic scale="70" fileref="discovery-druid3.png" />
      </figure>

      <figure id="discovery-snmp-options2">
        <title>Parameters for Network Discovery: Page 2</title>
        <graphic scale="70" fileref="discovery-druid4.png" />
      </figure>

      <para>
        There are a few settings that affect the crawler's algorithm (see
        <xref linkend="discovery-snmp-options" /> and
        <xref linkend="discovery-snmp-options2" />). Here is the list:
      </para>

      <para><itemizedlist spacing="compact">
          <listitem>
            <para>Run network scan recursively</para>

            <para>As was described above, the crawler starts with the "seed"
            host and then repeats its algorithm using every discovered host as
            a new "seed". If this option is turned OFF, then the crawler runs
            its algorithm only once and stops.</para>
          </listitem>

          <listitem>
            <para>Follow point-to-point links</para>

            <para>If a firewall or router has a point-to-point interface
            (for example, PPP interface), then the crawler can automatically
            calculate the IP address of the other side of this interface. It
            then continues the discovery process by querying a router on the
            other side. Very often, the point-to-point link connects the
            organization's network to an ISP and you are not really interested
            in collecting data about your ISP network. By default crawler
            won't cross point-to-point links, but this option, if activated,
            permits it.</para>
          </listitem>

          <listitem>
            <para>Include virtual addresses</para>

            <para>Sometimes servers or routers have more than one IP address
            assigned to the same interface. If this option is turned on, the
            crawler "discovers" these virtual addresses and tries to create
            objects for them.</para>
          </listitem>

          <listitem>
            <para>Run reverse name lookup queries to determine host
            names</para>

            <para>If the host discovered by the crawler answers to SNMP
            queries, it will report its name, which the crawler will use to
            create an object in Firewall Builder. However, if the host does
            not answer the query, the crawler cannot determine its name and
            only knows its IP address. The crawler can use DNS to back-resolve
            such addresses and determine host names if this option is turned
            ON.</para>
          </listitem>

          <listitem>
            <para>SNMP (and DNS) query parameters</para>

            <para>You must specify the SNMP "read" community string
            which will be used for SNMP queries. You can also specify
            the number of retries and a timeout for the query. (The
            number of retries and timeout parameters also apply to DNS
            and reverse DNS queries.)</para>
          </listitem>
        </itemizedlist></para>

      <para>Once all parameters are entered, the crawler actually gets to
      work, which may take a while. Depending on the size of the network and
      such parameters as the SNMP timeout value, scanning may take minutes or
      even hours. The progress of the scanner can be monitored on the page in
      the Druid (<xref linkend="discovery-snmp-crawler" />) and (<xref linkend="discovery-snmp-crawler2" />). You can always
      stop the crawler using the <guibutton>"Stop network scan"</guibutton>
      button. Data does not get lost if you do this as the Druid will use
      whatever objects the crawler discovered before you stopped it.</para>

      <figure id="discovery-snmp-crawler">
        <title>The SNMP crawler status</title>
            <graphic scale="70" fileref="discovery-druid6.png" />
      </figure>

      <figure id="discovery-snmp-crawler2">
        <title>The SNMP crawler status (more)</title>
            <graphic scale="70" fileref="discovery-druid7.png" />
      </figure>

      <para>The <guibutton>"Save scan log to file"</guibutton> button saves
      the content of the progress window to a text file and is mostly used for
      troubleshooting and bug reports related to the crawler.</para>

      <para>
        If the crawler succeeded and was able to collect information
        it needed to create objects, you can switch to the next page
        where you choose and create objects.
      </para>

      <figure id="discovery-druid-8">
        <title>Creating networks using gathered information</title>
            <graphic scale="70" fileref="discovery-druid8.png" />
      </figure>

      <para>This part of the druid is the same for all discovery methods.</para>

      <para>The left column shows the networks that were
      discovered. The right column shows the network objects that will
      be created. To start with, the right column is empty.</para>

      <para>This page of the Druid also has the following buttons:</para>

      <itemizedlist spacing="compact">
          <listitem>
            <para><guibutton>Select All</guibutton></para>

            <para>Selects all records in the column.</para>
          </listitem>

          <listitem>
            <para><guibutton>Unselect All</guibutton></para>

            <para>Deselects all records in the column.</para>
          </listitem>

          <listitem>
            <para><guibutton>Filter</guibutton></para>

            <para>Brings up a filter dialog. Filtering helps manage long lists
            of objects.</para>
          </listitem>

          <listitem>
            <para><guibutton>"Remove Filter"</guibutton></para>

            <para>Removes the currently applied filter and shows all records
            in the table.</para>
          </listitem>
        </itemizedlist>

      <para>The Druid can filter records in the table either by their address,
      by their name, or by both. To filter by address enter part of it in the
      "Address" field. The program compares the text entered in the filter
      dialog with an address in the table and shows only those records whose
      address starts with the text of the filter. For example, to only filter
      out hosts with addresses on the net 10.3.14.0 we could use the filter
      "10.3.14". Likewise, to remove hosts "bear" and "beaver" (addresses
      10.3.14.50 and 10.3.14.74) we could use the filter "10.3.14.6". Note
      that the filter string does not contain any wildcard symbols like "*".
      The filter shows only records that have addresses which literally match
      the filter string.</para>

      <para>Filtering by the object name uses the POSIX regular expressions
      syntax described in the manual page regex(7). For example, to find all
      records whose names start with "f" we could use the regular expression
      "^f". The "^" symbol matches the beginning of the string, so this
      regular expression matches any name that starts with "f". To find all
      names that end with "somedomain.com", we could use the regular
      expression ".*somedomain.com$"</para>

      <para>Once you have reviewed the discovered networks, decide
      which ones you want to turn into Network objects. Then, copy
      those networks to the right column.</para>

      <para>To populate the right column with objects, select the
      networks you want, then click the right arrow (--&gt;) to put
      them in the right column.</para>

      <figure id="discovery-snmp-2a">
        <title>Creating networks using gathered information (more)</title>
            <graphic scale="70" fileref="discovery-druid9.png" />
      </figure>

      <para>Click <guibutton>Next</guibutton>. The discovered Hosts list displays:</para>

      <figure id="discovery-snmp-2b">
        <title>Creating Hosts using gathered information</title>
            <graphic scale="70" fileref="discovery-druid10.png" />
      </figure>

      <para>Again, populate the right column with the objects you want to create:</para>

      <figure id="discovery-snmp-2c">
        <title>Creating Hosts using gathered information (more)</title>
            <graphic scale="70" fileref="discovery-druid11.png" />
      </figure>

      <para>Click <guibutton>Next</guibutton>. The final object list displays:</para>

      <figure id="discovery-snmp-2d">
        <title>List of Objects</title>
            <graphic scale="70" fileref="discovery-druid12.png" />
      </figure>

      <para>Here you can specify which type of object will be created
      for each discovered item: Address, Host, or Firewall. Here we
      are changing the object "sveasoft (10.3.14.202)" from a host to
      a firewall:</para>

      <figure id="discovery-snmp-2e">
        <title>Specify type of object</title>
            <graphic scale="70" fileref="discovery-druid13.png" />
      </figure>

      <para>Click <guibutton>Next</guibutton>. The target library control appears:</para>

       <figure id="discovery-snmp-2f">
        <title>Target Library</title>
            <graphic scale="70" fileref="discovery-druid14.png" />
      </figure>

      <para>Here you can specify which library the objects will appear
      in. Normally this would be User, unless you have created a
      user-defined library. Click <guibutton>Next</guibutton>.</para>

      <para>The wizard finishes processing, and your new objects appear in your library:</para>

       <figure id="discovery-snmp-2g">
        <title>Target Library</title>
            <graphic scale="70" fileref="discovery-druid15.png" />
      </figure>


    </sect1>

 <!-- ############################################################### -->
    <sect1 id="policy-importer">
      <title>Using Built-in Policy Importer in Firewall Builder</title>

          <para>
  
                  There are two ways to activate the feature: Main
                  menu <guimenuitem>File/Import Policy</guimenuitem> or
                  <guimenuitem>Tools/Discovery Druid</guimenuitem> and then
                  choose option <guilabel>Import configuration of a
                  firewall or a router</guilabel>.  Only the import of
                  iptables and Cisco IOS access lists is possible in
                  the current version.
                
          </para>
  

      <sect2>
        <title>Importing existing iptables configuration</title>
          <para>
  
                  Firewall Builder imports iptables configs in
                  the format of iptables-save. Script <command>iptables-save</command> is part
                  of the standard iptables install and should be
                  present on all Linux distribution. Usually this
                  script is installed in <emphasis>/sbin/</emphasis> . When you run
                  this script, it dumps the current iptables configuration
                  to stdout. It reads iptables rules directly form the
                  kernel rather than from some file, so what it dumps
                  is what is really working right now. To import this
                  into Firewall Builder, run the script to save the configuration
                  to a file:
                
          </para>
  
  <programlisting>
iptables-save &gt; iptables_config.conf
                </programlisting>

          <para>
  
                  Then launch Firewall Builder, activate the <guimenuitem>Import
                  Policy</guimenuitem> function and click <guibutton>Browse</guibutton> to find <filename>iptables_config.conf</filename>. You also
                  need to choose <guimenuitem>iptables</guimenuitem> in the <guilabel>Platform</guilabel> pull-down
                  menu.
                
          </para>
  

          <para>
  
                  If you do not choose "iptables" in 
                  <guilabel>Platform</guilabel>, the program will try to
                  interpret the file using a different parser and will
                  fail. The program does not make any assumptions
                  about the file name or extension and cannot predict
                 the source platform of the configuration.
                
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="importer_1.png"/></figure>

	<sect3>
        <title>Importing an iptables configuration created in FireStarter</title>

          <para>
  
                  The following example demonstrates an import of an
                  iptables policy generated by <emphasis>Firestarter</emphasis>,
                  another popular iptables configuration management
                  program.
                
          </para>
  

          <para>
  
                  After the platform is selected and file name
                  entered, click <guibutton>Next</guibutton> to start the process.
                
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="importer_2.png"/></figure>

          <para>
  
                  The program tries to interpret the configuration file
                  rule-by-rule and recreates its equivalent in
                  Firewall Builder. The progress window displays errors, if
                  any, as well as some diagnostics that shows network
                  and service objects created in the process. Note
                  that user-defined iptables chains found in the
                  configuration file will be re-created in Firewall Builder
                  as policy rule sets. The screenshot shows rulesets
                  "LSI", "LSO", "OUTBOUND" being created. (There were
                  more but they did not fit in the output
                  window.) Address objects "h-10.3.14.10",
                  "h-10.3.14.255" and few others have been created as
                  well. Service objects "tcp fsra/s", "udp 0-0:0-0",
                  "icmp -1/-1" and few others have also been created.
                
          </para>
  

          <para>
  
                  Note that the new firewall object created in the
                  process has generic name "New Firewall". This is
                  because iptables configuration file used for import
                  does not have information about firewall machine
                  name. It also does not have information about its
                  interfaces, their names and addresses. The program
                  can infer their names when it encounters
                  "-i &lt;interface&gt;" or "-o &lt;interface&gt;" clauses in the
                  iptables configuration lines. It cannot reliably
                  detect their addresses though. You need to manually rename the
                  firewall object and add IP addresses to interfaces
                  after the import.
                
          </para>
  

          <para>
  
                  Note also that only the IPv4 part of the iptables
                  configuration was imported. Currently, import of
                  IPv6 iptables configuration is not supported.
                
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="importer_3.png"/></figure>

          <para>
  
                  Screenshot above shows rule sets that the
                  program created from the configuration it
                  imported. Rule sets "INBOUND", "LOG_FILTER", "LSI",
                  "LSO", "OUTBOUND", "Policy" are all of the type
                  "Policy" and contain filtering rules. There were no
                  NAT rules in the original configuration so the rule
                  set "NAT" is created but is empty. The names of all
                  policy rule sets match names of the iptables chains
                  in the original configuration.
                
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="importer_7.png"/></figure>

        <figure float="1"><title/><graphic scale="50" fileref="importer_8.png"/></figure>

        <figure float="1"><title/><graphic scale="50" fileref="importer_9.png"/></figure>

          <para>
  
                  Screen shots above demonstrate address and service
                  objects created by the program. The importer writes a comment
                  in each object to remind you that the object was created
                  automatically on import. Names of these objects are
                  chosen automatically, but you can rename objects to give
                  them more meaningful names. Some of the objects
                  created during import have the same properties as
                  existing service and address objects from the
                  Standard objects library. Currently the program does
                  not cross-match them and just creates new objects,
                  however in the future it may use Standard objects
                  instead.
                
          </para>
  

          <para>
  
                Some rules in the original iptables config used
                "--tcp-flags" parameter to match only certain
                combinations of tcp flags. Here is an example:
              
          </para>
  

  <programlisting>
-A INPUT -s 10.3.14.10 -p tcp -m tcp ! --tcp-flags FIN,SYN,RST,ACK SYN -j ACCEPT 
              </programlisting>

          <para>
  
                In order to be able to reproduce this rule, Firewall Builder
                created a special TCP service object with given
                combination of tcp mask and flags:
              
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="importer_10.png"/></figure>

          <para>
  
                  The following screenshot shows rules created
                  in the main Policy rule set. These are the top
                  iptables rules, though some of them branch off to the other
                  Policy rule sets. Some of the rules in the original
                  policy did not match state (did not have clause "-m
                  state --state NEW" or similar), these rules were
                  created with the flag "stateless" turned on. In
                  Firewall Builder, this makes the policy compiler generate
                  iptables commands without a "-m state --state NEW"
                  clause that matches the original.  These rules are
                  marked with an icon that represents non-default rule
                  options in the column <guilabel>Options</guilabel>.
                
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="importer_14.png"/></figure>

          <para>
  
                  Let's inspect one group of rules a little closer. The
                  original iptables file contained the following
                  commands:
                
          </para>
  

  <programlisting>

-A INPUT -i eth0 -j INBOUND 


-A INBOUND -p tcp -m state --state RELATED,ESTABLISHED -j ACCEPT 
-A INBOUND -p udp -m state --state RELATED,ESTABLISHED -j ACCEPT 
-A INBOUND -s 10.3.14.0/255.255.255.0 -j ACCEPT 
-A INBOUND -s 10.3.14.0/255.255.255.0 -p tcp -m tcp --dport 22 -j ACCEPT 
-A INBOUND -s 10.3.14.0/255.255.255.0 -p udp -m udp --dport 22 -j ACCEPT 
-A INBOUND -j LSI 

                </programlisting>

          <para>
  
                  The first rule is in chain INPUT and was recreated
                  as rule #11 in the Policy rule set (rule colored
                  green). Since it was in INPUT, the destination
                  object in the rule #11 is the firewall itself. The
                  "-i eth0" clause translated into interface object
                  "eth0" in the "Interface" rule element and direction
                  "Inbound". The action of the rule #11 is "Branch",
                  pointing to the rule set "INBOUND". This is direct
                  re-creation of the original rule in the iptables config.
                
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="importer_15.png"/></figure>

          <para>
  
                  This screenshot demonstrates rules created in the
                  rule set "INBOUND". Rule #0 matches CustomService
                  object "custo-0-tcp" that was created to match a 
                  combination of protocol "tcp" and state
                  "RELATED,ESTABLISHED". This object is shown in the
                  following screenshot:
                
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="importer_11.png"/></figure>

          <para>
  
                  Firewall Builder automatically adds a rule on top of the 
                  generated iptables script to match packets in states
                  "ESTABLISHED, RELATED". With that rule, it is not
                  necessary to have a rule like #0 in INBOUND, but
                  since the original script had it, Firewall Builder reproduced
                  it.
                
          </para>
  

          <para>
  
                  Rule #1 in INBOUND matches protocol UDP and state
                  "ESTABLISHED,RELATED". Other rules in INBOUND
                  reproduce original rules from the chain INBOUND and
                  match packets coming from the local net heading for
                  the firewall machine. It is easy to see that the
                  original policy was redundant: rules #2-4 match the
                  same source and destination addresses but different
                  services, but rule #2 matches any service which
                  means rules #3 and 4 will never match any
                  packets. Fwbuilder will detect this problem
                  automatically if you try to compile this policy
                  (this is called "Rule shadowing").
                
          </para>
  

          <para>
  
                  All packets not matched by any rule in INBOUND will
                  match the last rule in this rule set, which branches to
                  the rule set LSI. Rule set LSI logs various packets
                  and drops them:
                
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="importer_16.png"/></figure>

          <para>
  
                  You might wonder why we have all these rules
                  with action "Continue".
                
          </para>
  

          <para>
  
                  When a rule is marked as "logging" in Firewall Builder, it
                  gets an icon in the column "Options" that represents
                  logging. This icon appears either by itself or next to
                  the icon that represents non-default rule
                  options. However, iptables does not allow for an
                  action "Accept" or "Deny" to be used in combination
                  with logging. In iptables, logging is a separate target
                  just like "ACCEPT" or "DROP". Because of that,
                  Firewall Builder splits a rule that has action "Accept" or
                  "Deny" or any other with logging turned on. One such
                  rule becomes two or more iptables rules in the
                  generated script. Unfortunately when iptables script
                  is imported back, the program cannot merge such
                  rules and logging rules appear in the rule set as
                  separate rules with a logging icon in the "Options"
                  column and action "Continue". This is a valid
                  configuration in Firewall Builder, it just means that the
                  rule generates a log record but does not make any
                  decision whether the packet should be accepted or
                  denied.
                
          </para>
  

          <para>
  
                  Here is the fragment of the original iptables rules in
                  the chain LSI:
                
          </para>
  

  <programlisting>
-A LSI -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN \
    -m limit --limit 1/sec -j LOG --log-prefix "Inbound " --log-level 6 
-A LSI -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -j DROP 
                </programlisting>

          <para>
  
                  These rules become rules #1 and 2 in rule set LSI in
                  Firewall Builder. The first rule, the one that does
                  logging, becomes a separate rule because this is how
                  it is done in iptables. If this policy was created
                  in Firewall Builder, rules #1 and 2 would be just one rule
                  in the GUI.  Double-clicking in the column <guilabel>Options</guilabel>
                  in rule #1 opens a dialog where you can inspect and
                  edit its options. The <guilabel>Limit</guilabel> tab in this dialog
                  controls parameters in the iptables "limit" module, which
                  was used in the original rule. Screenshot below
                  demonstrates how the policy importer recognized these
                  parameters and reproduced them in the rule options:
                
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="importer_17.png"/></figure>

      </sect3>

      <sect3>
        <title>Limitations</title>

          <para>
  
                  The iptables policy importer in Firewall Builder has its
                  limitations. The main limitation is that it can only
                  parse certain set of iptables modules and
                  targets. There are too many modules and associated
                  targets out there and supporting all of them is next
                  to impossible. However, it supports the core
                  functionality and most popular modules. Even though the 
                  importer tries to match the original
                  configuration as closely as possible, you should always review the 
                  rules and objects it creates and edit resulting
                  rules. Most of the time rules can be simplified,
                  such as with logging rules as was explained
                  above. Often you can merge multiple rules by putting
                  several objects in a <guilabel>Source</guilabel> or <guilabel>Destination</guilabel> or
                  <guilabel>Service</guilabel> field. Using Object and Service groups is another
                  good way to simplify rules.
                
          </para>
  
	</sect3>
      </sect2>

      <sect2>
        <title>Importing Cisco IOS access lists configuration</title>

          <para>
  
                  Importing an IOS access lists configuration is more
                  straightforward because branching is not possible
                  there. To import a configuration, first you need to
                  save it using the <command>show run</command> command. IOS has literally
                  hundreds of different commands and configuration
                  clauses, but Firewall Builder can only parse those related
                  to the access lists configuration. Other commands
                  will be ignored. There is no need to edit the 
                  configuration prior to importing it into Firewall Builder
                  (except for the "banner" command, see below). </para>

	  <para>A saved
                  IOS configuration has information about the router's name
                  and its interfaces. This information will be used to
                  recreate objects in Firewall Builder. Parser will not only
                  create interface objects with proper names, it will
                  also attach address objects to them to describe
                  their IP addresses.
                
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="importer_20.png"/></figure>

          <para>
  
                  As with iptables, we start with
                  <guimenuitem>File/Import Policy</guimenuitem> and enter the filename in
                  the dialog. The <guilabel>Platform</guilabel> pull-down menu
                  should be set to <guimenuitem>Cisco IOS</guimenuitem>. Click <guibutton>Next</guibutton> to
                  start the import process.
                
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="importer_21.png"/></figure>

          <para>
  
                  The program recognized router name "c3620" and its
                  interfaces, created interface objects with their IP
                  addresses and then created some address and service
                  objects. This test router config contains the
                  following lines (this is just a fragment, there are
                  more interfaces and more ACLs):
                
          </para>
  

  <programlisting>

interface FastEthernet0/0
 ip address 192.168.100.100 255.255.255.0 secondary
 ip address 10.3.14.201 255.255.255.0
 ip access-group fe0_0_acl_in in
 ip access-group fe0_0_acl_out out
 no ip mroute-cache
 duplex auto
 speed auto
!
interface Ethernet1/0
 description Test [test] {test} (and one more test) /weird:characters#$%^&amp;*/
 ip address 192.168.171.2 255.255.255.0
 ip access-group e1_0_acl_in in
 ip access-group e1_0_acl_out out
 no ip mroute-cache
 ip ospf cost 65000
 half-duplex
 crypto map real


!################################################################
ip access-list extended e1_0_acl_in
 deny   ip any any fragments
 permit tcp host 10.3.14.40 host 192.168.171.2 eq 22 log
 permit tcp host 10.3.14.40 host 10.3.14.201 eq 22 log
 permit ip any 10.3.14.0 0.0.0.255 log
 deny   ip any any log
!################################################################
ip access-list extended e1_0_acl_out
 permit ip 10.3.14.0 0.0.0.255 any log
 deny   ip any any log

                </programlisting>

          <para>
  
                  The parser recognizes comments and skips them, but text
                  from interface descriptions goes into comments in
                  the Interface objects.
                
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="importer_22.png"/></figure>

          <para>
  
                  Firewall Builder recognizes both named and regular
                  extended access lists. Each separate access list is
                  recreated in Firewall Builder in the same main Policy rule
                  set. The program recognizes "ip access-group"
                  commands and puts the corresponding interface object in
                  the "Interface" rule element of the rules it
                  creates.
                
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="importer_30.png"/></figure>

          <para>
  
                  The original configuration used the same access list
                  "133" with two interfaces:
                
          </para>
  

  <programlisting>

interface Ethernet1/1
 ip address 10.10.10.10 255.255.255.0
 no ip mroute-cache
!
!  Note - the same access list applied both in and out
 ip access-group 133 in
 ip access-group 133 out
 no shutdown
 half-duplex
!
interface Ethernet1/2
 ip address 10.10.20.20 255.255.255.0
 no ip mroute-cache
!
!  Note - the same access list applied both in and out
!  the same list is applied to eth 1/1 and eth 1/2
 ip access-group 133 in
 ip access-group 133 out
 no shutdown
 half-duplex
!
                </programlisting>

          <para>
  
                  The program recognizes this and creates object group
                  "intf-acl_133" with these two interfaces as members:
                
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="importer_31.png"/></figure>

          <para>
  
                  It then uses this group in the <guilabel>Interface</guilabel> element
                  of rules #0, 1 and 2 to reproduce rules from the
                  access list "133".
                
          </para>
  

          <para>
  
                  Interface configuration commands visible in the
                  config snippets above, such as "half-duplex",
                  "duplex auto", "speed auto", various protocol
                  configuration commands and other commands supported
                  by IOS inside the "interface" block are ignored.
                
          </para>
  
	<sect3>
        <title>Limitations</title>

          <para>
  
                  One IOS configuration construct that Firewall Builder can
                  not import is the "banner" command. This command is
                  special in that it allows you to set an arbitrary
                  terminator character, and then it allows any text up
                  to this character. This creates a problem for the
                  Firewall Builder parser because the terminator character
                  can be arbitrary. You need to edit and remove banner
                  from the saved configuration file before importing
                  it.
                
          </para>
	</sect3>
      </sect2>
    </sect1>

  </chapter>
