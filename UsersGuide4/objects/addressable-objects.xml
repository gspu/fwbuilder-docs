
<sect1 id="addressable-objects">
    <title>Addressable Objects</title>
    <para>
      This section describes object types that represent
      addresses or groups of addresses.
    </para>

    <sect2 id="common-properties">
      <title>Common Properties of Addressable Objects</title>

      <para>
        Objects that contain IP address fields provide validity
        checking for the address when the object is saved. If the IP
        address is invalid, the system notifies you with an error.
      </para>
    </sect2>

    <sect2 id="firewall-object">
      <title>The Firewall Object</title>

      <para>
        A firewall object represents a real firewall device in your
	network. This firewall object will have interface and IP
	address objects that mirror the real interfaces and IP
	addresses of the actual device. In addition, the firewall
	object is where you create the access policy rule sets, NAT
	rule sets, and routing rule sets that you assign to your
	firewall device.
      </para>

      <para>
        By default, a firewall has one Policy rule set, one NAT rule
	set, and one routing rule set. However, you can create more
	than one rule set of each type for a firewall. On the other
	hand, you don't have to populate all the default rule sets. You can,
	for example, create a Policy rule set and leave the NAT and
	Routing rule sets empty. <xref linkend="policies-and-rules" />
	explains more about policies and rule sets.
      </para>

      <para>To speed up the creation of a firewall object, Firewall
	Builder has a wizard that walks you through creating the
	object. The wizard has three options for creating a firewall
	object: </para>

      <para>
        <itemizedlist spacing="compact">
          <listitem>
            <para>From a template: Firewall Builder comes with
              several pre-defined templates. You can use these to
              create a firewall that is close to your configuration,
              then modify it to fit your needs. 
            </para>
	  </listitem>
          <listitem>
            <para>Manually: You can provide interface IP address,
              subnet mask, gateway, and other parameters
              manually. You can add this information when you create
              the firewall, or you can add it
              later. <xref linkend="creating_firewall_manually" />
              (below) describes this process.</para>
	  </listitem>
          <listitem>
            <para>Using SNMP: Firewall Builder uses SNMP queries to
              learn about the network.
              <xref linkend="firewall-snmp"/> describes this process.</para>
	  </listitem>
        </itemizedlist>
      </para>

      <sect3 id="creating_firewall_manually">
        <title>Creating a Firewall Object Manually</title>

        <para>
          To start the firewall object creation wizard, right-click
          the <guibutton>Firewalls</guibutton> folder in the User tree
          and select <guimenuitem>New Firewall</guimenuitem>.
        </para>

	<para>
          The first page of the wizard displays.
        </para>

        <figure id="creating-firewall1-2">
          <title>First Page of the Wizard</title>
          <graphic scale="60" fileref="objects/images/creating_firewall1.png" />
        </figure>

        <para>
          Give the firewall object a name. Usually, this name is the same name 
          you assigned to the device, but it need not be if
          you're assigning interfaces manually. (If you are use SNMP or
          DNS to populate the interfaces, then the name must be the same
          as the device name.) Then specify the firewall software and
          device OS.
        </para>

	<para>
          Leave the <guilabel>Use pre-configured template firewall
	    objects</guilabel> checkbox unchecked.
        </para>

	<para>Click <guibutton>Next</guibutton>.</para>

        <figure id="creating-firewall_manual1">
          <title>Choosing to Configure Interfaces Manually</title>
          <graphic scale="60" fileref="objects/images/creating_firewall_manual1.png" />
        </figure>

	<para>
          Select <guibutton>Configure interfaces manually</guibutton>
	    and click <guibutton>Next</guibutton>.
        </para>

        <figure id="creating-firewall_manual1_1">
          <title>The Add Interfaces Page</title>
          <graphic scale="60" fileref="objects/images/creating_firewall_manual1-1.png" />
        </figure>


        <para>
          This is the page where you can add interfaces to the
          firewall. In this page of the dialog, each interface is
          represented by a tab in the tabbed widget.  Use the "+"
          button in the upper left corner to add a new interface. The
          "x" button in the upper right corner deletes an interface. Click the "+"
          button to create first interface and give it the name "eth0":
        </para>

        <figure id="creating-firewall_manual2">
          <title>Adding Interfaces to the New Firewall Object</title>
          <graphic scale="60" fileref="objects/images/creating_firewall_manual2.png" />
        </figure>

        <para>
          To add an IP address to the interface, click in the table
          cell in the "Address" column and begin typing the
          address. The cell becomes an editable field that lets you
          enter the address. Add the network mask using the table cell in the
          "Netmask" column. The <guilabel>"Type"</guilabel> drop-down list 
          lets you choose between IPv4 and IPv6 addresses. The network mask
          field accepts both full numeric notation and bit length for
          IPv4 netmasks. For IPv6, only bit length is allowed. The
          <guilabel>"Remove"</guilabel> button removes the address. You can
          add several addresses to the same interface.
        </para>

        <para>
          The following elements are available on this
          page of the wizard:
        </para>

        <para>
          <itemizedlist spacing="compact">
            <listitem>
              <para>
                <guilabel>Name</guilabel>: The name of the
                interface object in Firewall Builder must match
                exactly the name of the interface of the firewall
                machine it represents. This will be something like
                "eth0", "eth1", "en0", "br0", and so on.
              </para>
	    </listitem>

            <listitem>
              <para>
                <guilabel>Label</guilabel>: On most OSs this
                field is not used and serves the purpose of a
                descriptive label.  On the Cisco PIX, however, the label is mandatory, and must reflect the network
                topology. Firewall Builder GUI uses the label, if it
                is not blank, to label interfaces in the tree. One of
                the suggested uses for this field is to mark
                interfaces to reflect the network topology ("outside" or
                "inside", for example) or interface purpose ("web frontend" or
                "backup subnet", for example).
              </para>
	    </listitem>

            <listitem>
              <para>
                <guilabel>MAC</guilabel>: If you like, you can
                also specify the interface physical address. The MAC
                address is not necessary, but it can be used to prevent
                spoofing. If the feature is turned on and available,
                the firewall only accepts packets from the given
                IP address if the MAC address matches the one
                specified. <xref linkend="using-mac-address" /> has
                more information.
              </para>
	    </listitem>

            <listitem>
              <para>
                <guilabel>Interface type</guilabel>: Indicates the type
                of interface. <xref linkend="host-interface"/>
                explains the interface types in more detail. Briefly,
                though, a <guilabel>Regular interface</guilabel> has a
                static IP addresses, a <guilabel>Dynamic
                address</guilabel> interface has a dynamic address
                provided by something like DHCP,
                an <guilabel>Unnumbered interface</guilabel> never has
                an IP address (a PPPoE connection, for example), and
                a <guilabel>Bridge port</guilabel> is an interface
                that is bridged in the firewall.
              </para>
	    </listitem>

            <listitem>
              <para>
                <guilabel>Comment</guilabel>: free-form text field
                used for the comment.
              </para>
	    </listitem>

            <listitem>
              <para>
                <guilabel>Address</guilabel>: If the interface
                has a static IP address, specify it here.
              </para>
	    </listitem>

            <listitem>
              <para>
                <guilabel>Netmask</guilabel>: Use either a traditional
                netmask (255.255.255.0) or bit length (24, without
                slash) to specify the interface netmask. For IPv6
                addresses, only bit length notation is accepted.
              </para>
	    </listitem>
	</itemizedlist></para>

	<para>
          Once all the interfaces are configured,
          click <guibutton>Finish</guibutton> to create the new firewall
          object.
        </para>

        <note>
          <para>
            You can always add, modify, and delete interfaces later
            using controls provided in the main window.
          </para>
        </note>
      </sect3>


      <sect3 id="firewall-from-template">
        <title>Creating a Firewall Object Using a Preconfigured Template</title>

        <para>
          Another method you can use to create new firewall object is
          based on the use of preconfigured template objects that come
          with the program. To do this, select the "Use
          preconfigured template firewall objects" checkbox on the first page
          of the wizard <xref linkend="creating-firewall1-2"/>, then
          click <guibutton>Next</guibutton>.
        </para>

        <figure id="new_firewall_template_1">
          <title>List of preconfigured firewall templates</title>
          <graphic scale="70" fileref="objects/images/new_firewall_wizard_templ_1.png" />
        </figure>

        <para>
          The program comes with several template objects. These
          include firewalls with two or three interfaces, a couple of
          firewall configurations intended for a server with one
          interface, templates for OpenWRT, DD-WRT, and IPCOP firewalls,
          and a Cisco router. Each template is configured with
          IP addresses and basic rules. Some templates assume all
          interfaces have static IP addresses, while other assume some
          interfaces have dynamic addresses. These template objects
          are intended to be a start, something you can and should
          edit and modify to match your network configuration and
          security policy.
        </para>

        <para>
          Choose the template that is closest to your configuration
          and click <guibutton>Next</guibutton>.
        </para>

        <figure id="new_firewall_template_2">
          <title>Editing Addresses of Interfaces of a New Firewall Created from a Template</title>
          <graphic scale="70" fileref="objects/images/new_firewall_wizard_templ_2.png" />
        </figure>

        <para>
          This page of the wizard allows you to change IP addresses
          used in the template. This is a new feature in Release 4.0 relative to Release 3.0. You can add and
          remove addresses using the <guibutton>Add
            address</guibutton> and <guibutton>Remove</guibutton> buttons. Since
          configuration of the template object depends on its
          interfaces, the dialog does not let you add or remove
          interfaces for objects created from a template.  Each
          interface is represented by a tab in the tabbed widget; you
          can switch between them clicking the tabs with the interface
          names. <xref linkend="creating_firewall_manually"/> lists
          all elements of this page of the dialog and explains their
          purpose.
        </para>

        <para>
          Each template firewall object comes preconfigured with some
          basic rules that use the firewall object, its interfaces, and
          network objects that represent subnets attached to
          interfaces. If you change addresses of interfaces in this
          page of the wizard, the program automatically finds all network objects
          used in the template rules matching old addresses and
          replaces them with new network objects representing
          subnets with addresses you entered in the wizard. This feature
          saves you from having to find and replace these objects manually.
        </para>

        <para>
          Once all interfaces and addresses are entered or modified,
          click <guibutton>Finish</guibutton> to create the firewall object.
        </para>

      </sect3>

      <sect3 id="firewall-snmp">
        <title>Creating a Firewall Object Using SNMP Discovery</title>

	<para>
          If your firewall runs an SNMP daemon, you can save
	  yourself some time by using SNMP discovery to automatically
	  create the interfaces of the new firewall object.
        </para>

        <figure id="new_firewall_snmp1">
          <title>SNMP "read" Community String</title>
          <graphic scale="70" fileref="objects/images/new_firewall_wizard_4.png" />
        </figure>

	<para>
          Start by checking the <guilabel>Use SNMP to discover
	    interfaces of the firewall</guilabel> checkbox on the second
	  page of the wizard and enter your SNMP "read"
	  community. Then click <guibutton>Discover interfaces using
	    SNMP</guibutton>.
        </para>

        <figure id="new_firewall_snmp2">
          <title>Discovering Interfaces via SNMP</title>
          <graphic scale="70" fileref="objects/images/new_firewall_wizard_5.png" />
        </figure>

	<para>
          The program runs a series of SNMP queries to the firewall to
	  read the list of interfaces and their addresses. Both IPv4
	  and IPv6 address can be imported. For IPv6, the firewall must
	  support IP-MIB RFC 4293. Once the discovery process finishes,
	  click <guibutton>Next</guibutton>.
        </para>

        <figure id="new_firewall_snmp3">
          <title>Editing Interfaces Discovered Using SNMP</title>
          <graphic scale="70" fileref="objects/images/new_firewall_wizard_6.png" />
        </figure>

	<para>
          The next page of the wizard offers an opportunity to review
	  the discovered interfaces and make adjustments, if necessary.
	  This is the same page described previously in
	  <xref linkend="creating_firewall_manually"/>. You can add
	  and remove interfaces and add, remove, or change their IP
	  addresses. <xref linkend="creating_firewall_manually"/>
	  lists all elements of this page of the dialog and explains
	  the purpose of each.
        </para>

        <para>
          When configuration of all interfaces is correct, click <guibutton>Finish</guibutton>
          to create the new firewall object.
        </para>

      </sect3>

      <sect3>
        <title>Editing a Firewall Object</title>

        <para>The firewall object represents the firewall machine and
        is the most complex object in Firewall Builder. It has three
        sets of controls that you can modify, not including the policy
        rule sets. All these controls become available when you
        double-click the firewall object in the tree.</para>

        <figure id="edit_firewall_base_controls">
          <title>Firewall Controls</title>
          <graphic scale="60" fileref="objects/images/edit_firewall_base_controls.png" />
        </figure>

	<sect4>
	  <title>Basic Firewall Controls</title>

	  <para>
            These controls let you specify the basic settings of the
	    firewall, such as the name and firewall platform.
          </para>

          <para>
            <itemizedlist spacing="compact">
              <listitem>
                <para>
                  <guilabel>Name</guilabel>: Specify or change the name
                  of the firewall object.
                </para>
              </listitem>

              <listitem>
                <para>
                  <guilabel>Platform</guilabel>: Specify or change the
                  firewall software.
                </para>
              </listitem>

              <listitem>
                <para>
                  <guilabel>Version</guilabel>: Specify or change the
                  version number of the firewall software. In most
                  cases, you can leave this set
                  to <guilabel>any</guilabel>. In general, setting the
                  version to "any" means the compiler only
                  supports options available in all supported versions
                  of the software. If you need a feature that is 
                  supported only by a particular version, then specify that
                  version.
                </para>
              </listitem>

              <listitem>
                <para>
                  <guilabel>Host OS</guilabel>: Specify or change the
                  host operating system of the firewall device.
                </para>
              </listitem>

              <listitem>
                <para>
                  <guibutton>Firewall Settings</guibutton>: Opens
                  the Advanced Settings dialog for the platform or firewall
                  software. Click <guibutton>Help</guibutton> in the
                  dialog for assistance with dialog options. See
                  <xref linkend="firewall-settings-dialog" /> for a screen
                  shot.
                </para>
              </listitem>

              <listitem>
                <para>
                  <guibutton>Host OS Settings</guibutton>: Opens the
                  Advanced Settings dialog for the indicated Host
                  OS. Click <guibutton>Help</guibutton> in the dialog for
                  assistance with dialog options. See
                  <xref linkend="host-os-settings-dialog" /> for a screen
                  shot.
                </para>
              </listitem>

              <listitem>
                <para>
                  <guilabel>Inactive firewall</guilabel>: Check this
                  box to make the firewall object inactive. The firewall
                  name  changes from bold to a regular font to
                  indicate that it is inactive, and the firewall is not
                  available for compiling or installation. Essentially,
                  this is a way to "comment out" the firewall object
                  without deleting it.
                </para>
              </listitem>

	    </itemizedlist>
          </para>
	</sect4>

	<sect4 id="host-os-settings-dialog">
	  <title>Host OS Settings Dialog</title>

          <para>
            For explanations of the various controls, click
            the <guilabel>Help</guilabel> button in the dialog.
          </para>
          
          <figure id="edit_firewall_howtos_options">
            <title>Firewall Host OS Settings Dialog (Linux)</title>
            <graphic scale="70" fileref="objects/images/edit_firewall_howtos_options.png" />
          </figure>
          
	</sect4>


	<sect4 id="firewall-settings-dialog">
	  <title>Firewall Settings Dialog</title>

	  <para>
            For explanations of the various controls, click
	    the <guilabel>Help</guilabel> button in the dialog.
          </para>
          
          <figure id="edit_firewall_firewallsettings_compiler">
            <title>Firewall Settings Dialog (iptables)</title>
            <graphic scale="60" fileref="objects/images/edit_firewall_firewallsettings_compiler.png" />
          </figure>

	</sect4>

      </sect3>
    </sect2>

    <sect2 id="cluster-object">
      <title>The Cluster Object</title>

      <para>
        The cluster object represents an abstraction of a high
        availability (HA) setup that consists of two or more member
        firewalls, each represented by its own firewall object.
      </para>


      <para>
        The object type "cluster" (located under Clusters in the tree)
        represents the HA pair. You configure policy and NAT rules in the
        rule sets of this object, rather than in those of the actual firewalls.
      </para>

      <para>
       The procedure for setting up HA configuration is as follows:
      </para>

      <para>
        <itemizedlist spacing="compact">
          <listitem><para>Create your firewall objects. Assign
            platform and host OS and name interfaces as usual. Do not
            add any policy or NAT rules. These are your real (member)
            firewalls. Interfaces should have their real IP addresses
            (not CARP or VRRP addresses).
          </para></listitem>

          <listitem>
            <para>
              Create a cluster object. Configure the cluster object with the proper
              platform and host OS. Use the usual <guimenu>New Object</guimenu> menu or
              toolbar button to create this object. Note that in order
              for the firewall object to become a member of a cluster,
              their platform and host OS settings must match.
            </para>

            <para>
              There are two ways to create new cluster object: 
              you can use main menu "Object / New Object" option (or a
              toolbar button that calls the same function) as shown on
              <xref linkend="new_cluster_method_1"/>:
            </para>

            <figure id="new_cluster_method_1">
              <title>Create a New Cluster Using the "Object / New
              Object" Option</title>
              <graphic scale="50" fileref="objects/images/new-cluster-method-1.png"/>
            </figure>

            <para>
              Using this menu option or toolbar button opens a wizard that guides you through the
              steps of creating new cluster object. The first page of
              the wizard shows all the available firewall objects. In this page, you choose which ones become cluster
              members:
            </para>

            <figure id="new_cluster_method_1_1">
              <title>Using the Wizard to Choose Firewall Cluster Members</title>
              <graphic scale="50" fileref="objects/images/new-cluster-method-1-1.png"/>
            </figure>


            <para>
              Another method is to select two or more firewall objects
              that are to become cluster members, then right-click and select the "New
              cluster from selected firewalls" menu item, as shown on
              <xref linkend="new_cluster_method_2"/>. You can select
              two or more objects in the tree by clicking the object
              while holding the "Ctrl" key ("Cmd" on the Macintosh).
            </para>

            <figure id="new_cluster_method_2">
              <title>Using the Right-Click Menu to Choose Firewall Cluster Menus</title>
              <graphic scale="50" fileref="objects/images/new-cluster-method-2.png"/>
            </figure>

            <para>
              Using the right-click options launches the same wizard, but the list on its first
              page is already populated with the selected firewall objects, as shown below.
            </para>

            <figure id="new_cluster_method_2_1">
              <title>Wizard Populated with Selected Firewall
              Objects</title>
              <graphic scale="50" fileref="objects/images/new-cluster-method-2-1.png"/>
            </figure>

            <para>
              Reducing the number of firewall objects displayed in the wizard
              can be helpful when you have many of firewall objects defined in
              the object tree.
            </para>

          </listitem>

          <listitem><para>
            The program guides you through the process of creating
            new cluster objects using a wizard-like dialog. You start with the
            list of firewall objects where you choose which firewalls should
            become members of the cluster. Next, the program finds
            interfaces of the member firewalls that have the same name and
            can be part of the cluster and creates cluster interfaces with
            the same name. Not all interfaces are eligible: for example,
            bridge ports, bonding interface slaves, and parents of VLAN
            interfaces cannot be used for the cluster. Cluster interfaces
            define failover groups. You can add, remove, or rename cluster
            interfaces, as well as change which interfaces of the member
            firewalls are used with each one. On the next page of the wizard
            you can change failover protocols and add, remove, or change IP
            addresses of cluster interfaces. Not all failover protocols
            require IP addresses: for example, VRRP or CARP do but heartbeat
            or OpenAIS do not. Finally, you can choose to use policy and NAT
            rules of one of the member firewalls to populate policy and NAT
            rule sets of the new cluster. If you do this, all references to
            the original member firewall and its interfaces in rules are
            replaced with references to the cluster and its interfaces. The
            program also creates backup copies of the member firewall
            objects with the name with suffix "-bak" and clears policy and
            NAT rule sets of the member firewall objects used with the
            cluster before the new cluster is created.
          </para></listitem>

          <listitem><para>
            OpenBSD or FreeBSD clusters are assigned with CARP interfaces. Name them
            "carp0", "carp1", and so on (or whatever indexes the addresses are assigned on your
            machines). You can add the CARP password and ID at the same time or you can add them later.
          </para></listitem>

          <listitem><para>
            If you use heartbeat or OpenAIS (on Linux) for failover, cluster
            interfaces should have the same names as the corresponding member
            firewall interfaces. In this case, cluster interfaces are
            virtual entities that represent interfaces of the corresponding
            member firewalls. The program makes the necessary substitutions when it
            compiles the rules. This is also how PIX failover
            configuration works.
          </para></listitem>

          <listitem><para>
            Each cluster interface has a child "Failover group" object with
            the name "firewall:carp0:members", or similar. This is the object where you
            configure associated member firewall interfaces. Double-click
            this object in the tree and then click "Manage Members" button
            in the dialog. Select interfaces of the member firewalls in the
            panel on the left-and side and click the Arrow button to add them
            to the list on the right. Use the checkbox to select the master. Click
            OK when done. The platform and host OS of the cluster object and
            members must match, otherwise firewall objects do not appear in
            the "members" dialog panel.
          </para></listitem>

          <listitem><para>
            Besides interfaces, the Cluster object has a new child object
            "State Sync Group". This group represents state synchronization
            protocol. Currently <emphasis>pfsync</emphasis> is supported for OpenBSD and
            <emphasis>conntrackd</emphasis> for Linux. To configure, double-click this object in
            the tree to open it in the dialog and click "Manage
            Members". Select the interfaces of the member firewalls in the panel
            on the left hand side and click the Arrow button to add them to the
            list on the right. Use the checkbox to select the master. Click OK when
            done. The new objects should appear in the "members" table in the State
            Sync Group dialog. The platform and host OS of the cluster
            object and members must match, otherwise firewall objects do not
            appear in the "members" dialog panel.
          </para></listitem>

          <listitem><para>
            The "Edit protocol parameters" button allows you to edit some
            parameters for the chosen failover protocol. This is how you 
            configure an address and port for heartbeat and OpenAIS.
          </para></listitem>

          <listitem><para>
            There are few additional checkboxes in the "Script" tab of the firewall
            object dialog. These allow you to control whether the program
            add shells commands for creating and configuring bonding, bridge,
            and VLAN interfaces.
          </para></listitem>

          <listitem><para>
            Compile by right-clicking the cluster object and
           selecting "Compile". This compiles each member
            firewall separately, resulting in .fw and .conf files for both
            of them.
          </para></listitem>

          <listitem><para>
            Again, you configure all the rules in the policy and NAT rule
            sets that belong to the cluster object. If you put cluster's
            interfaces in rules, the program replaces them with interfaces
            of the member firewall when it compiles rules. If you put
            cluster object in a rule, it is like if you put member firewall
            object there instead, except the program automatically picks the
            member firewall it compiles the policy for.
          </para></listitem>

          <listitem><para>
            First, the program looks at Policy and NAT rule set objects of
            the cluster and member firewalls and compares their names. If
            there is rule set object with the same name in both the cluster
            and member firewall and both have non-zero number of rules, the
            rule set object from the member is used and the one from the
            cluster is ignored. The program prints a warning message when
            this is done. If rule set objects with the same name exist but
            the one in the member firewall has zero rules, it is ignored and
            the one from the cluster is used (no warning is
            issued). Likewise, if there are rule sets with the same name but
            the one in the cluster has zero rules, it is ignored.
          </para></listitem>

          <listitem>
            <para>
              Here is what you need to do if you want to have most rules
              defined in the cluster so they will translate into rules for all
              member firewalls, but have some rules defined in the members so
              you can make configurations of the members slightly different:
              <itemizedlist>

                <listitem><para>Create separate rule set object in the
                  cluster and in each member. Use name different from
                  "Policy" or "NAT". Lets use name
                  "member_override".</para></listitem>

                <listitem><para>Create a rule with action "Branch" in
                  the main Policy or NAT rule set of the cluster, drag
                  rule set object "member_override" that belongs to
                  the cluster to the well in the Branch action
                  parameters dialog.</para></listitem>

                <listitem><para>Leave "member_override" rule set that
                    is a child of the cluster
                    object empty (no rules)</para></listitem>

                <listitem><para>Add rules to the rule set
                  "member_override" in each member
                  firewall</para></listitem>

                <listitem><para>Make sure rule set "member_override"
                  is not marked as "Top ruleset" in the cluster and
                  each member. This rule set translates into
                  user-defined chain (iptables) or anchor (PF) and
                  should not be the "top ruleset".</para></listitem>
                
              </itemizedlist>
              This method works for both policy and NAT rules for all
              platforms.
            </para>
          </listitem>

        </itemizedlist>
      </para>

    </sect2>

    <sect2 id="rule-set-objects">
      <title>Editing Rule Set Objects</title>

      <para>
        Firewalls and clusters can have one or more of the of the
	following types of rule sets: access policy, NAT, and
	routing. A firewall has, by default, one access policy rule
	set, one NAT rule set, and one routing rule set. However, you
	can add additional rule sets if you like.
      </para>

      <para>
        Rule sets are child objects of the a firewall
	object. They cannot stand alone.
      </para>

      <para>
        As objects, rule sets have parameters. In Firewall
	Builder, rule sets have the following parameters:
      </para>

      <itemizedlist>
	<listitem>
          <para><guilabel>Name</guilabel>: The name of the
	    rule set. If you only have one of each type of rule set, you
	    can leave this at its default.
	  </para>
        </listitem>

	<listitem>
          <para><guilabel>Rule set family</guilabel>: This
	    pull-down menu lets you specify whether policy compiler should
	    treat the rule set as an IPv4 rule set, an IPv6 rule set, or a
	    combined rule set. If set to IPv4, then only IPv4 rules are
	    processed and IPv6 rules are ignored. The opposite is
	    true if you specify an IPv6 rule set. If you
	    select <guimenuitem>This is combined IPv4 and IPv6 rule
	      set</guimenuitem>, then the compiler processes both types
	    of rules and places them into the appropriate places in the
	    install script.
	  </para>
        </listitem>

	<listitem>
          <para><guilabel>filter+mangle table</guilabel>
	    or <guilabel>mangle table</guilabel>: These radio buttons let
	    you specify whether the rules apply to the iptables
	    filter table <emphasis>and</emphasis> mangle table, or just to 
	    the mangle table. (These radio buttons only appear for access
	    policy rule sets, and only for iptables.) Under most
	    circumstances, the compiler places each rule into the correct
	    table (filter or mangle) automatically. However, some
	    combinations of service objects and actions are ambiguous and
	    can be used in both filter and mangle tables. In cases like
	    these, you can clarify things for the compiler by creating a
	    separate policy rule set to be translated only into the
	    mangle table.
	  </para>
        </listitem>

	<listitem>
          <para><guilabel>Top ruleset</guilabel>: One of your
	    rule sets must be the "top" rule set. The top rule set is the
	    one used by the firewall. Other rule sets of that type are
	    used only if you branch to them using branching logic in the
	    top rule set. (If you don't use branching, then only the rule
	    set tagged as "top" is used.)
	  </para>
        </listitem>

	<listitem>
          <para><guilabel>Comment</guilabel>: A free-form
	    comment field.
	  </para>
        </listitem>
      </itemizedlist>

      <figure id="rule-set-options1">
	<title>Rule set options</title>
        <graphic scale="70" fileref="objects/images/rule-set-options1.png" />
      </figure>
    </sect2>

    <sect2 id="host-interface">
      <title>Interface Object</title>

      <figure id="host-interface1">
        <title>Interface Object</title>
            <graphic scale="70" fileref="objects/images/host_example_1.png" />
      </figure>

      <para>Interface objects belong to firewall or host
      objects. Interface objects cannot exist alone.</para>

      <para>The dialog for the interface object that belongs to the
      firewall or host provides controls for the parameters described
      here. Controls that are only valid for the firewall, and not
      host objects, are marked as such.</para>

      <figure id="interface1">
        <title>Interface Object</title>
            <graphic scale="70" fileref="objects/images/interface-1.png" />
      </figure>

      <itemizedlist>
	<listitem><para><guilabel>Name</guilabel>: The name of the
	interface object in Firewall Builder must match exactly the
	name of the interface of the firewall machine it
	represents. This will be something like "eth0", "eth1", "en0",
	"br0", and so on.
	</para></listitem>
	<listitem><para><guilabel>Label</guilabel>: On most OSs this
	field is not used and serves the purpose of a descriptive
	label. Firewall Builder GUI uses a label, if it is not blank,
	to show interfaces in the tree. One of the suggested uses for
	this field is to mark interfaces to reflect the network
	topology (for example, "outside," "inside") or the purpose ("web frontend"
	or "backup subnet"). The label is mandatory for Cisco PIX
	though, where it must reflect the network topology.
	</para></listitem>
	<listitem><para><guilabel>Management interface</guilabel>:
	When a firewall has several network interfaces, one of them
	can be marked as the "management interface". The management
	interface is used for all communication between Firewall
	Builder and the firewall. For example, the built-in policy
	installer uses the address of the management interface to
	connect to the firewall via SSH when it copies a generated
	script or configuration file. (This object applies to firewall objects only.)
	</para></listitem>
	<listitem><para><guilabel>External interface
	(insecure)</guilabel>: Marks an interface that connects to the
	Internet, or to an area that is outside the network protected
	by the firewall.  (This obect applies to firewall objects only.)
	</para></listitem>
	<listitem><para><guilabel>Unprotected interface</guilabel>:
	Marks interface to which Firewall Builder should not assign
	any access lists or firewall rules. Unprotected interfaces are
	recognized by policy compilers for Cisco IOS access lists and
	PF. Compiler for IOS ACL just skips unprotected interfaces and
	does not assign any ACL. The compiler for PF generates a "set
	skip on" clause for unprotected interfaces.  (This obect applies to firewall objects only.)
	</para></listitem>
	<listitem><para><guilabel>Regular Interface</guilabel>: Use
	this option if the interface has an IP address assigned to it
	manually (static IP address).
	</para></listitem>
	<listitem><para><guilabel>Address is assigned
	dynamically</guilabel>: Use this option if the interface has a
	dynamic address (obtained by means of DHCP or PPP or another
	protocol). In this case, an address is unknown at the moment
	when Firewall Builder generates the firewall policy. Some
	firewalls allow for using the interface name in the policy
	instead of its IP address; the firewall engine then picks an
	address either when the policy is activated or even at
	run-time. Some other firewalls support special syntax for
	rules that are supposed to match packets headed to or from the
	firewall machine. Examples of these two cases are OpenBSD PF
	and Netfilter. PF rules can be constructed using interface
	names; PF automatically uses the current interface address
	when it loads rules into the memory. Netfilter supports
	special "chains" called "INPUT" and "OUPUT" that are
	guaranteed to inspect only packets destined for the firewall
	machine ("INPUT") or originated on it ("OUTPUT"). Both methods
	allow Firewall Builder to build correct firewall policy rules
	that affect the interface with a dynamic IP address; however,
	the interface must be marked as such for the policy compiler
	to use proper technique depending on the target firewall
	platform. In cases where the rule has to use actual IP address
	of the interface (for example, anti-spoofing rules), the compiler
	emulates this feature by adding a shell script fragment to
	determine the address at the time when firewall script is
	executed and then uses the address in rules. Such emulation is
	only possible on platforms where firewall configuration is in
	the form of the shell script; most notably, an iptables
	script on Linux.
	</para></listitem>
	<listitem><para><guilabel>Unnumbered interface</guilabel>: Use
	this option if the interface can never have an IP address,
	such as the Ethernet interface used to run PPPoE communication
	on some ADSL connections, or a tunnel endpoint
	interface. Although an unnumbered interface does not have an
	address, firewall policy rules or access lists can be
	associated with it.
	</para></listitem>
	<listitem><para><guilabel>Bridge port</guilabel>: This option
	is used for a port of a bridged firewall. The compilers skip
	bridge ports when they pick interfaces to attach policy and
	NAT rules to. For target firewall platforms that support
	bridging and require special configuration parameters to match
	bridged packets, compilers use this attribute to generate a
	proper configuration. For example, in case of iptables, the
	compiler uses <emphasis>-m physdev --physdev-in</emphasis>
	or <emphasis>-m physdev --physdev-out</emphasis> for bridge
	  port interfaces. (This obect applies to firewall objects only.)
	</para></listitem>
	<listitem><para><guilabel>Security level</guilabel>: Depending
	on the firewall platform, the security level is
	either <emphasis>External/Internal</emphasis> or a numeric
	value between 0 and 100, with 0 being least secure and 100
	being most secure. This field in the GUI dialog automatically
	shows controls appropriate to the current firewall. Not all
	firewall support the concept of a security zone. (This obect applies to firewall objects only.)
	</para></listitem>
	<listitem><para><guilabel>Network zone</guilabel>: Used only
        with Cisco PIX (ASA). The Network zone drop-down list shows
        all network objects and groups of addresses and networks
        present in the tree. Choose one of them to tell the compiler
        which networks and blocks of addresses can be reached through
        this interface. Usually the external interface (the one that
        connects your firewall to the Internet) has the Network Zone
        set to <emphasis>Any</emphasis>. It is also recommended that
        you create a group of objects to represent Network Zones for
        all other interfaces on the firewall. The compiler uses this
        information to decide which interface each ACL rule should be
        associated with based on the addresses used in the destination
        of the rule. (This obect applies to firewall objects only.)
	</para></listitem> 
      </itemizedlist>

    <sect3 id="security-levels-and-network-zones">
      <title>More about Security Levels and Network Zones</title>

	<para>Consider the network layout as in
        <xref linkend="network-zones" />. </para>

        <figure id="network-zones">
          <title>Choosing Network Zones</title>
              <graphic scale="100" fileref="objects/images/fwbuilder-using-netzone1.jpg" />
        </figure>

	<para>In this example, the firewall has three interfaces: "outside,"
        "dmz," and "inside." Behind the firewall, there is a router
        which in turn is connected to three subnets: "subnet A,"
        "subnet B," and "subnet C." Subnet A is shared between the
        router and the firewall (each device has an interface on this
        subnet). Let's suppose we have created Network objects for
        each subnet and called them "subnet DMZ," "subnet A," "subnet
        B" and "subnet C." (Recall that spaces are allowed in object
        names.) For this set-up, network zones should be configured as
        follows:</para>

        <para><informaltable frame="none">
            <tgroup cols="2">
              <colspec align="center" colwidth="64pt" />

              <colspec align="center" colwidth="150pt" />

              <thead>
                <row>
                  <entry>Interface</entry>

                  <entry>Network Zone</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><guilabel>outside</guilabel></entry>

                  <entry><emphasis>ANY</emphasis></entry>
                </row>

                <row>
                  <entry><guilabel>dmz</guilabel></entry>

                  <entry><emphasis>subnet DMZ</emphasis></entry>
                </row>

                <row>
                  <entry><guilabel>inside</guilabel></entry>

                  <entry><emphasis>subnet A,</emphasis> <emphasis>subnet
                  B,</emphasis> <emphasis>subnet C</emphasis></entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable></para>

        <para>Since the network zone for
        the <emphasis>"inside"</emphasis> interface consists of
        multiple objects, you must create a group so that you can use
        this group as a Network Zone object.</para>

        <para><xref linkend="platform-specific-interface-parameters"
        /> explains the differences in the way firewall platforms
        interpret values in the Security Level and Network Zone
        parameters of the firewall interfaces.</para>

        <table id="platform-specific-interface-parameters" pgwide="0" tabstyle='reg_table'>
          <title>Platform-Specific Interface Parameters</title>

          <tgroup cols="3">
            <thead>
              <row>
                <entry><para>Firewall Platform</para></entry>

                <entry><para>Security Level Values</para></entry>

                <entry><para>Network Zone</para></entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><para>iptables</para></entry>

                <entry><para>two values: "External" or
                "Internal"</para></entry>

                <entry><para>N/A</para></entry>
              </row>

              <row>
                <entry><para>ipfilter</para></entry>

                <entry><para>two values: "External" or
                "Internal"</para></entry>

                <entry><para>N/A</para></entry>
              </row>

              <row>
                <entry><para>pf</para></entry>

                <entry><para>two values: "External" or
                "Internal"</para></entry>

                <entry><para>N/A</para></entry>
              </row>

              <row>
                <entry><para>Cisco PIX</para></entry>

                <entry><para>numeric, 0 - 100</para></entry>

                <entry><para>a reference to a group or network
                object</para></entry>
              </row>
            </tbody>
          </tgroup>
        </table>

	<para>Note that the "external" interface option may be
	deprecated in the future versions of the program.</para>

	<para>In PIX, access lists must always be attached to
	interfaces. The policy compiler for PIX uses information about
	the network zones of interfaces to decide which interface a
	rule should be associated with if its "Interface" column does
	not specify one (is left set to "All"). Instead of placing
	this rule in access lists attached to all interfaces, it
	compares addresses in the Source and Destination of the rule
	with network zones of interfaces and only uses interfaces that
	match. This helps generate a PIX configuration that is more
	compact.</para>
    </sect3>
    
    <sect3>
      <title>Using Interface Objects in Rules</title>

      <para>Policy rules in Firewall Builder have a rule element
      called <guilabel>Interface</guilabel>. You can drag-and-drop, or
      copy/paste interface object into this column of a rule to make
      the firewall match not only the source and destination address
      and service, but also the interface of the firewall through
      which packets enter or exit. The direction of the packet is
      defined in column <guilabel>Direction</guilabel>. Consider the
      following example:</para>

      <figure id="rules_with_interface_1">
        <title>Rule Using an Interface Object</title>
            <graphic scale="70" fileref="objects/images/rules_with_interface_1.png" />
      </figure>

      <para>Rule #0 is "anti-spoofing" rule which relies on the
      ability to define interface and direction. It matches packets
      with source addresses equal to the addresses of the firewall's
      interfaces or internal network, but that are coming in from
      outside, which is determined by comparing the interface through
      which packets enter the firewall. Packets with "internal"
      addresses cannot normally come from outside, and if they do,
      they must be spoofed and should be dropped. This is what this
      rule does: it drops and logs these packets. Rule #1 permits
      connections originating from the internal network going out, but
      it makes sure these packets enter the firewall through its
      internal interface.</para>

      <para>These two rules generate the following iptables
      script:</para>


      <programlisting>
# 
# Rule 0 (eth0)
# 
$IPTABLES -N In_RULE_0
$IPTABLES -A FORWARD  -i eth0  -s 192.0.2.1  -j In_RULE_0 
$IPTABLES -A FORWARD  -i eth0  -s 172.16.22.1  -j In_RULE_0 
$IPTABLES -A FORWARD  -i eth0  -s 192.168.2.1  -j In_RULE_0 
$IPTABLES -A FORWARD  -i eth0  -s 172.16.22.0/24  -j In_RULE_0 
$IPTABLES -A In_RULE_0  -j LOG  --log-level info --log-prefix "RULE 0 -- DENY "
$IPTABLES -A In_RULE_0  -j DROP 
# 
# Rule 1 (eth1)
# 
$IPTABLES -A FORWARD  -i eth1  -s 172.16.22.0/24  -m state --state NEW  -j ACCEPT 
      </programlisting>

    <para> Here all iptables commands have an "-i eth0" or "-i eth1"
    clause, which makes iptables compare the interface and
    direction.</para>

     <para>Here is what we get if we compile the same rules for
     PF:</para>

      <programlisting>
# Tables: (1)
table &lt;tbl.r9999.d&gt; { 192.0.2.1 , 172.16.22.1 , 192.168.2.1 } 

# 
# Rule  0 (eth0)
# 
block in   log  quick on en0 inet  from &lt;tbl.r9999.d&gt;  to any
block in   log  quick on en0 inet  from 172.16.22.0/24  to any
# 
# Rule  1 (eth1)
# 
pass in   quick on en1 inet  from 172.16.22.0/24  to any keep state
# 
      </programlisting>

      <para> For PF, the compiler generated a "block in log quick on
      eth0" clause to make the rule match interface and
      direction.</para>

      <para>In the case of Cisco IOS access lists, defining an
      interface in the rule makes the compiler place code generated
      for this rule into the ACL attached to the given interface. The
      compiler for IOS ACL always generates both inbound and outbound
      access lists for each interface, but if the rule specifies both
      interface and direction ("Inbound" or "Outbound"), the generated
      configuration goes only into the corresponding access list. Here
      is the output produced for the rules shown above for Cisco IOS
      ACL:</para>

      <programlisting>
ip access-list extended inside_in
! Rule  1 (eth1)
! 
  permit ip 172.16.22.0 0.0.0.255 any  
exit

ip access-list extended outside_in
! Rule  0 (eth0)
! 
  deny   ip host 192.0.2.1 any  log 
  deny   ip host 192.168.2.1 any  log 
  deny   ip 172.16.22.0 0.0.0.255 any  log 
exit

interface FastEthernet1
  ip access-group inside_in in
exit
interface FastEthernet0
  ip access-group outside_in in
exit
      </programlisting>

      <para>So far, the examples in this section have demonstrated how
      to use Interface objects to associate policy rules with
      interfaces so as to match packets crossing certain interface. An
      interface object can be used in the "source" and "destination"
      of rules just like any other addressable object. In this case,
      Firewall Builder replaces the interface object with the set of
      its addresses, picking only those addresses that match the
      address family (IPv4 or IPv6 or both) assigned to the rule
      set.</para>

      <para>For example, we start with a firewall configuration where
      interface eth1 has two IP addresses, one IPv4 and another is
      IPv6. Note that this could be a host object as well because
      interfaces can belong either to a Firewall or a Host
      object.</para>

      <figure id="interface-2">
        <title>Interface Object with Both Address Families</title>
            <graphic scale="70" fileref="objects/images/interface-2.png" />
      </figure>

      <para>Interface eth1 has IPv4 address 172.16.22.1 and IPv6
      address fe80::21d:9ff:fe8b:8e94. It is used in a simple policy
      rule as follows:</para>

      <figure id="interface-rule-1">
        <title>Interface Object in a Rule</title>
            <graphic scale="70" fileref="objects/images/interface-rule-1.png" />
      </figure>

      <para>This policy rule set is configured as a mixed IPv4+IPv6
      rule set. For iptables, the compiler generates the following
      code:</para>

      <programlisting>
# ================ IPv4
# Rule 0 (global)
# 
$IPTABLES -A INPUT -p tcp -m tcp  -d 172.16.22.1  --dport 22  -m state \
 --state NEW  -j ACCEPT 

# ================ IPv6

# Rule 1 (global)
# 
$IP6TABLES -A INPUT -p tcp -m tcp  -d fe80::21d:9ff:fe8b:8e94  --dport 22 \
 -m state --state NEW  -j ACCEPT
      </programlisting>

      <para>For PF we get the following:</para>

      <programlisting>
# Rule  0 (global)
# 
# 
pass in   quick inet proto tcp  from any  to 172.16.22.1 port 22 keep state
pass out  quick inet proto tcp  from any  to 172.16.22.1 port 22 keep state

# Rule  0 (global)
# 
# 
pass in   quick inet6 proto tcp  from any  to fe80::21d:9ff:fe8b:8e94 port 22 \
keep state
pass out  quick inet6 proto tcp  from any  to fe80::21d:9ff:fe8b:8e94 port 22 \
keep state
      </programlisting>

      <para>Since the interface has two addresses, one IPv4 and
      another IPv6, the compiler generates commands in both the IPv4
      and IPv6 sections of the script, but it uses only the
      appropriate address in each. Other than that, the interface
      object behaves just like a set of addresses when used in the
      source or destination element of a rule. It can also be used in
      NAT rules. Here is an example:</para>

      <figure id="interface-nat-rule-1">
        <title>IPv4 Address Object Assigned to an Interface</title>
            <graphic scale="70" fileref="objects/images/interface-nat-rule-1.png" />
      </figure>
    
      <para>This generates the following code for iptables:</para>

      <programlisting>
# Rule 0 (NAT)
# 
$IPTABLES -t nat -A POSTROUTING -o eth0  -s 172.16.22.0/24 -j SNAT \
--to-source 192.0.2.1 
# 
# Rule 1 (NAT)
# 
$IPTABLES -t nat -A PREROUTING  -p tcp -m tcp   -d 192.0.2.1 --dport 80 \
-j DNAT --to-destination 172.16.22.100 
       </programlisting>

		<para>And for PF:</para>
	<programlisting>
# Rule  0 (NAT)
# 
nat on eth0 proto {tcp udp icmp} from 172.16.22.0/24 to any -> 192.0.2.1 
# 
# Rule  1 (NAT)
# 
rdr on eth0 proto tcp from any to 192.0.2.1 port 80 -> 172.16.22.100 port 80 
        </programlisting>
    </sect3>

    <sect3>
      <title>Using Interface Object with Dynamic Address in Rules</title>

      <para>The examples above demonstrated what happens when an
      interface with one or several IP addresses is used in policy and
      NAT rules. Let's look at the case when an interface has an
      address assigned dynamically. This means the address is unknown
      to the Firewall Builder policy compiler when it generates the
      configuration script. The compiler uses features of the target
      firewall to work around this. Here is the configuration of the
      interface object eth0. The radio-button <guilabel>Address is
      assigned dynamically</guilabel> is selected.</para>

      <figure id="interface-3">
        <title>Interface with Dynamic Address</title>
            <graphic scale="60" fileref="objects/images/interface-3.png" />
      </figure>

	<para>The following policy rule uses interface eth0  in destination:</para>

      <figure id="interface-rule-3">
        <title>Interface with Dynamic Address in a Rule</title>
            <graphic scale="70" fileref="objects/images/interface-rule-3.png" />
      </figure>

      <para> Here is the result for iptables:</para>

      <programlisting>
getaddr eth0  i_eth0
getaddr6 eth0  i_eth0_v6

# ================ IPv4

# Rule 0 (global)
# 
test -n "$i_eth0" &amp;&amp; $IPTABLES -A INPUT -p tcp -m tcp  -d $i_eth0  --dport 22 \
  -m state --state NEW  -j ACCEPT 

# ================ IPv6

# Rule 0 (global)
# 
test -n "$i_eth0_v6" &amp;&amp; $IP6TABLES -A INPUT -p tcp -m tcp -d $i_eth0_v6  \
 --dport 22  -m state --state NEW  -j ACCEPT 
        </programlisting>

	<para>The shell functions "getaddr" and "getaddr6" are defined
	earlier in the script. The generated script determines IPv4
	and IPv6 addresses of interface eth0 at the time of execution
	and then uses the values in iptables commands. If the
	interface does not have an address, the corresponding variable
	gets an empty string for its value and the iptables command
	using it is skipped.</para>

	<para>PF allows for using interface name in rules and gets its
	current IP address automatically. This is the result generated
	for PF:</para>

	<programlisting>
# Rule  0 (global)
# 
pass in   quick inet proto tcp  from any  to (en0) port 22 keep state
pass out  quick inet proto tcp  from any  to (en0) port 22 keep state

# Rule  0 (global)
# 
pass in   quick inet6 proto tcp  from any  to (en0) port 22 keep state 
pass out  quick inet6 proto tcp  from any  to (en0) port 22 keep state
         </programlisting>    

	<para>We still get two separate parts for IPv4 and IPv6
	because the rule set is configured as IPv4+IPv6 mix, but in
	both cases compiler just used the interface name because its
	actual IP address is dynamic and was unknown at the time the
	configuration was generated.</para>

    </sect3>
    
    <sect3>
      <title>Using Interface Object in Rules of Bridging iptables Firewall</title>

      <para>In case of the "normal" iptables firewall, Firewall
      Builder adds an "-i eth0" or "-o eth0" parameter to the
      generated iptables command to make it match interface and
      direction. If radio button <guilabel>"Bridge port"</guilabel> is
      turned on in the interface object, the compiler uses a different
      option to make iptables match packets crossing bridge
      ports. Here is the interface "eth1" which is configured as a
      bridge port:</para>

      <figure id="bridge_interface_dialog_1">
        <title>Bridge Interface</title>
            <graphic scale="60" fileref="objects/images/bridge_interface_dialog_1.png" />
      </figure>

      <para>Consider the following rule in the policy of the firewall
      this interface belongs to:</para>

      <figure id="rules_with_interface_2">
        <title>Bridge Interface in Rule</title>
            <graphic scale="70" fileref="objects/images/rules_with_interface_2.png" />
      </figure>

      <para> This rule matches interface "eth1" and generates the
      following iptables command:</para>

      <programlisting>
$IPTABLES -A FORWARD  -m physdev --physdev-in eth1  -s 172.16.22.0/24 \
 -d 172.16.22.255  -m state --state NEW  -j ACCEPT 
      </programlisting>

      <para>Since the interface is now a bridge port, the compiler
      uses "-m physdev --physdev-in eth1" to match it.</para>

    </sect3>
  </sect2>

    <sect2 id="address-object">
      <title>IPv4 Address Object</title>

      <para>The regular address object describes single a IPv4
      address. It can be a child of an interface object, in which case
      it represents an IP address and netmask of the interface, or it
      can be used as a standalone object. In the latter case it does
      not have a netmask and is located in the Objects/Addresses
      branch of the objects tree.</para>

      <sect3>
	<title>IPv4 Address Object When Used as an Address of an Interface</title>

	  <para>In this case the object is a "child" or "leaf" under
	  the an interface object, either on a host or a firewall
	  object. To create this kind of an address, right-click 
	  the interface object to bring up the context menu.</para>

      <figure id="ipv4-address1">
        <title>IPv4 Address Object Assigned to an Interface</title>
            <graphic scale="50" fileref="objects/images/ipv4_1.png" />
      </figure>
      <para>Its dialog provides the following entry fields:</para>

      <para><itemizedlist spacing="compact">
          <listitem>
            <para>Name</para>

            <para>This is the name of the object. Use a descriptive
            name because when the address object is used in the
            firewall policy, it is labeled with this name. It may be
            hard to tell one address from another if their names are
            similar.</para>
          </listitem>

          <listitem>
            <para>Address</para>

            <para>This is an IP address. The GUI widget provides
            syntax control for the values entered in the field. (This
            syntax control activates when you save the object.)</para>

            <note>
              <para>A typical error is to interpret this object as an address
              of the subnet to which the interface of the host or firewall
              belongs. This object represents an address of the interface, not
              a network address. (So, 192.168.1.1, not 192.168.1.0)</para>
            </note>
          </listitem>

          <listitem>
            <para>Netmask</para>

            <para>This is a netmask assigned to the interface. You can
            enter the netmask using the traditional method
            (255.255.255.0) or using network bit length notation
            ("24"). Bit length notation is converted to a traditional
            netmask by Firewall Builder.</para>
          </listitem>

          <listitem>
            <para>DNS Lookup</para>

            <para>If the host object has the same name as the actual
            machine, then clicking this button generates a DNS query
            that populates the interface IP address and subnet. Only
            the parent host or firewall object's name is used for the
            DNS query; the name of the interface is ignored and can be
            anything.</para>
          </listitem>

          <listitem>
            <para>Comment</para>

            <para>This is free-form text field for a comment.</para>
          </listitem>
        </itemizedlist></para>

	<para>Here we use our IPv4 address in a rule (remember, it belongs to the interface):</para>

      <figure id="ipv4-address2">
        <title>IPv4 Address Object Assigned to an Interface and Used in a Rule</title>
            <graphic scale="70" fileref="objects/images/ipv4_1_rule_1.png" />
      </figure>

	<para>Firewall Builder's iptables compiler, for example,
	generates the following command from this rule:</para>

	<programlisting>$IPTABLES -A INPUT -p tcp -m tcp  -d 172.16.22.1  --dport 22  -m state \
	--state NEW  -j ACCEPT</programlisting>

	<para>Note how even though the address object has a netmask,
	the generated command matches the address as a host address,
	not as a subnet. This is because the netmask is used only to
	describe the subnet for the interface, not to describe the
	subnet. When this address object is used in a rule, it is
	understood that the intention is to match the address of the
	interface it belongs to rather than any address on the
	subnet. Use the network object if you need to match a whole
	subnet.</para>

	<para>This iptables rule was placed in the INPUT chain because
	the object in the "Destination" was an address of an interface
	of the firewall. While processing the policy for the iptables
	target firewall platform, Firewall Builder compares addresses
	in the source and destination of a rule to the addresses of
	all interfaces of the firewall to find rules that control
	access to and from the firewall. Firewall Builder places these
	rules into INPUT or OUTPUT chains. This is only necessary for
	iptables.</para>

      </sect3>
      <sect3>
	<title>IPv4 Address Object When Used as a Stand-Alone Object</title>

	  <para>In this case the object is located in
	  the <guimenuitem>Objects / Addresses</guimenuitem> part of
	  the objects tree and does not have a netmask entry field. To
	  create this kind of an address, use the <guimenu>New
	  Object</guimenu> menu to select <guimenuitem>New
	  Address</guimenuitem> or use the right-click menu associated
	  with the addresses folder in the tree.</para>

      <figure id="ipv4-address3">
        <title>Stand-Alone IPv4 Address Object</title>
            <graphic scale="50" fileref="objects/images/ipv4_2.png" />
      </figure>

	<para>Dialog
	fields <guilabel>Name</guilabel>, <guilabel>Address</guilabel>
	and <guilabel>Comment</guilabel> have the same purpose and
	properties as an address object assigned to an interface
	object.</para>

	<para>The DNS Lookup button can be used to automatically
	populate the address field using a DNS query. The program runs
	DNS query for the "A" record with the name of the address
	object. The object name does not have to match any DNS record
	if you never plan to use this feature. DNS query function is
	just a convenience, but to use it, the name of the object must
	match a DNS record.</para>

      </sect3>
    </sect2>

    <sect2 id="ipv6-address-object">
      <title>IPv6 Address Object</title>

	<para>The IPv6 address object is similar to the IPv4 address
	object. Like IPv4 address objects, it can be used both as a
	child of an interface object or as a stand-alone
	object.</para>

      <sect3>
	<title>IPv6 Address Object When Used as an Address of an Interface</title>

      <figure id="ipv6-address1">
        <title>IPv6 Address Object Assigned to an Interface Object</title>
            <graphic scale="60" fileref="objects/images/ipv6_1.png" />
      </figure>

      <para>If it is used to describe an IPv6 address of an interface,
      it has a netmask represented as bit length. Unlike with IPv4
      address object, an IPv6 netmask is never represented as a
      colon-separated string of octets.</para>
      </sect3>

      <sect3>
	<title>IPv6 Address Object When Used as Stand-Alone Object</title>

      <figure id="ipv6-address2">
        <title>Stand-Alone IPv6 Address Object</title>
            <graphic scale="60" fileref="objects/images/ipv6_2.png" />
      </figure>

      <para>In this case this object is located in
      the <guimenuitem>Objects / Addresses</guimenuitem> part of the
      objects tree (the same place where stand-alone IPv4 addresses
      are located) and does not have a netmask entry field. To create
      this kind of an address, use the <guimenu>New Object</guimenu>
      menu item <guimenuitem>New Address IPv6</guimenuitem> or the
      right-click menu associated with the addresses folder in the
      tree.</para>

      <para>Policy compilers treat IPv6 addresses in policy rules
      according to the same algorithms as those for IPv4 rules. For
      example, just like with IPv4, the compiler for iptables checks
      whether an address matches an address of any interface of the
      firewall to determine if the rule should be placed in the INPUT
      or OUTPUT chain.</para>

      <para>Consider the rule shown in the screenshot below where we
      use two IPv6 address objects. One object belongs to the
      interface inside of the firewall while another is the IPv6
      address of the project's web site.</para>

      <figure id="ipv6-address3">
        <title>IPv6 Address Objects in a Rule</title>
            <graphic scale="70" fileref="objects/images/ipv6_1_rule_1.png" />
      </figure>

      <para>For iptables, Firewall Builder generates the following commands from this rule:</para>

      <programlisting>
$IP6TABLES -A INPUT -p tcp -m tcp  -d fe80::21d:9ff:fe8b:8e94  --dport 80  \
-m state --state NEW  -j ACCEPT 
$IP6TABLES -A FORWARD -p tcp -m tcp  -d 2001:470:1f0e:162::2  --dport 80  \
-m state --state NEW  -j ACCEPT
      </programlisting>

      <para>The rule that matches the address described
      by <emphasis>object guardian-2:eth1:ipv6</emphasis> went to the
      INPUT chain because compiler detected that this rule matches
      packets that are headed for the firewall itself, which iptables
      inspects in the INPUT chain. The rule that matches the address
      described by the object <emphasis>ipv6.fwbuilder.org</emphasis>
      went to the FORWARD chain because these packets go through the
      firewall.</para>
      </sect3>
    </sect2>

    <sect2 id="attached-network-objects">
      <title>Attached Network Objects</title>

      <para>
        There is a special type of interface child object, called the 
        Attached Network object, that represents the networks that are 
        directly attached to the interface. <xref linkend="attached-net-diag"/> 
        shows an example firewall configuration for a firewall with 
        two network interfaces.
      </para>

      <figure id="attached-net-diag">
        <title>Example Firewall Configuration</title>
            <graphic scale="60" fileref="objects/images/attached_network_example.png" />
      </figure>
      
      <para>
        In the example configuration one of the interfaces, 
        <emphasis>eth0</emphasis>, has one IP address and the other 
        interface, <emphasis>eth1</emphasis>, has two IP addresses 
        as shown in <xref linkend="attached-net-table"/>.
      </para>

      <table id="attached-net-table" frame='none'  tabstyle='reg_table'>
        <title>Attached Networks</title>
        <tgroup cols='3' align='left'  rowsep='1'>
          <colspec colnum="1" colname="col1" colwidth="1*"/>
          <colspec colnum="2" colname="col2" colwidth="1*"/>
        <thead>
          <row>
            <entry>Interface</entry>
            <entry>Attached Network</entry>
          </row>
        </thead>

        <tbody>
            <row>
              <entry>eth0</entry>
              <entry>192.0.2.0/24</entry>
            </row>

            <row>
              <entry>eth1</entry>
              <entry>10.10.10.0/24</entry>
            </row>

            <row>
              <entry>eth1</entry>
              <entry>172.16.0.0/24</entry>
            </row>
          </tbody>
          </tgroup>
        </table>

      <para>
        To create an object that matches the attached networks, select 
        an interface, right-click on the interface and select New Attached 
        Network from the context menu as shown in <xref linkend="attached-net-menu"/>.
      </para>

      <figure id="attached-net-menu">
        <title>Adding Attached Network Object to Interface eth1</title>
            <graphic scale="60" fileref="objects/images/attached_network_menu.png" />
      </figure>

      <para>
        This will create a new child object under the eth1 interface object 
        called <emphasis>linux-1:eth1:attached</emphasis>.
      </para>
      
      <figure id="attached-net-eth1">
        <title>Adding Attached Network Object to Interface eth1</title>
            <graphic scale="60" fileref="objects/images/attached_network_eth1.png" />
      </figure>

      <para>
        If you open the object for editing as shown in 
        <xref linkend="attached-net-editor"/> you will see the list of 
        all networks that are currently attached to the eth1 interface. If you 
        add or delete IP addresses from the interface the Attached 
        Network object will be automatically updated. 
      </para>

      <figure id="attached-net-editor">
        <title>Adding Attached Network Object to Interface eth1</title>
            <graphic scale="60" fileref="objects/images/attached_network_editor.png" />
      </figure>
      
      <para>
        The Attached Network object can than be used in rules just like any 
        other Network object. <xref linkend="attached-net-rule"/> shows an 
        example of using the Attached Network object from the eth1 interface 
        in a NAT policy rule.
      </para>

      <figure id="attached-net-rule">
        <title>Adding Attached Network Object to Interface eth1</title>
            <graphic scale="60" fileref="objects/images/attached_net_rule.png" />
      </figure>

      <para>
        Compiling this rule for an iptables firewall results in the output 
        shown below.
      </para>

<programlisting>
echo "Rule 0 (NAT)"
# 
$IPTABLES -t nat -A POSTROUTING -o eth0 -s 10.10.10.0/24 -j SNAT --to-source 192.0.2.1
$IPTABLES -t nat -A POSTROUTING -o eth0 -s 172.16.0.0/24 -j SNAT --to-source 192.0.2.1
</programlisting>
        
      <note>
      <para>
        You can also use the Attached Network object with interfaces that are 
        configured as "Address is assigned dynamically". In this case the script 
        generated by Fireawll Builder will determine the attached network based 
        on the IP address that is assinged to the interface at the time that 
        the script is run.
      </para>
      </note>

    </sect2>

    <sect2 id="physical-address-object">
      <title>Physical Address Objects</title>

      <figure id="physAddress1">
        <title>The Physical Address Object</title>
            <graphic scale="60" fileref="objects/images/physaddress1.png" />
      </figure>

      <para>The physical address object describes the hardware, or
      media, address of an interface. Currently only Ethernet MAC
      addresses are supported, but support for other kinds of physical
      addresses may be added in the future.</para>

      <para>The physical address object can only be a child of an
      interface; it cannot exist as a stand-alone object. To create
      this kind of address object, right-click an interface object
      in the tree, then select <guimenuitem>Add MAC
      Address</guimenuitem>. Only one physical address object is
      allowed per interface; the program enforces this restriction. If
      you create a firewall or host object using SNMP discovery, all
      interfaces are automatically populated with their MAC
      addresses.</para>

      <para><itemizedlist spacing="compact">
          <listitem>
            <para>Name</para>

            <para>This is the name of the object. The field is
            populated automatically with a host:interface:addressType
            descriptive name when the object is created, but you can
            change it immediately or later. If you change the name,
            use something descriptive because when the address object
            is used in the firewall policy, it is labeled with this
            name. It may be hard to tell one address from another if
            their names are similar. </para>
          </listitem>

          <listitem>
            <para>Address</para>

            <para>This is a string representation of the physical or media
            address. For many types of media, this will be in a binary
            representation. For example, an Ethernet address would be
            represented as a string of six octets.</para>
          </listitem>

          <listitem>
            <para>Comment</para>

            <para>This is free-form text field for a comment.</para>
          </listitem>
        </itemizedlist></para>

      <sect3 id="using-mac-address">
        <title>Using The Physical Address Object in Policy Rules</title>

        <para>Only a few firewall platforms really support physical
        address filtering. Currently, Netfilter/iptables is the only
        firewall platform supported by Firewall Builder that can do
        physical address filtering.</para>

        <para>As described in <xref linkend="multiple-addresses"/>,
        if an interface object that has multiple child address objects
        is used in a rule element (either
        <emphasis>Source</emphasis> or <emphasis>Destination</emphasis>), then
        the policy compiler tries to generate a rule using all of them. <xref linkend="multiple-addresses"/> explains that the compiler actually does
        this by generating multiple rules using each address in turn. This
        roughly corresponds to using the logical operation "OR" on the IP
        addresses: if our interface has two addresses,
        <emphasis>Address1</emphasis> and <emphasis>Address2</emphasis>, then
        the generated rule matches if the address in the packet is either
        <emphasis>Address1</emphasis>
        OR <emphasis>Address2</emphasis>. The case of a physical
        address is different, though. If the interface has a physical
        address, then the compiler builds a rule that has to match an
        IP address <emphasis>and</emphasis> the MAC address. The
        reason is to combat IP spoofing.</para>

        <para>Suppose we have a very important host on the network. We
        create a host object, then add an interface to it. The
        interface should have both address and physical address
        objects as shown in
        <xref linkend="host-with-addr-and-physaddr" />. The two child
        objects are visible in the tree under the Interface
        "eth0". </para>

        <figure id="host-with-addr-and-physaddr">
          <title>The Host Object with Address and Physical Address</title>
              <graphic scale="60" fileref="objects/images/using-physaddress-1.png" />
        </figure>

	<note><para>Note how <guilabel>MAC matching</guilabel> is
	checked in the host object dialog. This makes the compiler use
	the MAC addresses of the interfaces of this
	host.</para></note>

        <para>Because this is a very important host, we would like to
        be sure that packets whose source IP is that of this host are
        really coming from it and are not spoofed. The best way to
        achieve this goal is to use strong authentication, for example,
        using the IPSec protocol. The use of IPSec is outside the scope of this
        document, since our goal here is to show that inspecting
        the MAC address of the packet can improve security. </para>

        <para>Both a real packet originated from this host and a
        spoofed packet have a source IP address of the interface of
        this host, but the source MAC address is going to be different
        if spoofing is occurring. We can use this fact to catch and drop
        spoofed packets. Here are three possible ways to build
        security policy for this situation: </para>

        <para><itemizedlist>
            <listitem>
              <para>Using only address object in the rule element. This means
              the firewall inspects only IP address and ignores the MAC
              address of the packets.</para>

              <figure id="only-addr">
                <title>Policy Rule Using Only Address Object</title>
		  <graphic scale="70" fileref="objects/images/using-physaddress-4.png" />
              </figure>

	    <para> Firewall Builder generates the following simple iptables command for this rule:</para>
<programlisting>
$IPTABLES -A FORWARD  -s 10.3.14.44  -m state --state NEW  -j ACCEPT 
</programlisting>                
            </listitem>

            <listitem>
              <para>Using only a physical Address object. A rule built this way
              permits all kinds of traffic coming from the trusted host even
              if its IP address changes.</para>

              <figure id="only-phaddr">
                <title>Policy Rule Using Only a Physical Address Object</title>
		  <graphic scale="70" fileref="objects/images/using-physaddress-5.png" />
              </figure>

	      <para> For this rule, the following iptables command is generated:</para>
	      <programlisting>
$IPTABLES -A FORWARD  -m mac --mac-source 00:1D:09:8B:8E:94 -m state --state NEW \
-j ACCEPT 
              </programlisting>
            </listitem>

            <listitem>
              <para>Using a host or interface object. This way we end up with a
              rule that matches on a <emphasis>combination</emphasis> of the
              IP address and MAC address. This may be used as a sophisticated
              anti-spoofing rule.</para>

              <figure id="using-host">
                <title>Policy Rule Using a Host Object</title>
		  <graphic scale="70" fileref="objects/images/using-physaddress-6.png" />
              </figure>

              <figure id="using-interface">
                <title>Policy Rule Using an Interface Object</title>
		  <graphic scale="70" fileref="objects/images/using-physaddress-3.png" />
              </figure>

	      <para> For this rule, the following iptables command is generated:</para>
	      <programlisting>
$IPTABLES -A FORWARD  -m mac --mac-source 00:1D:09:8B:8E:94 -s 10.3.14.44  -m state \
--state NEW  -j ACCEPT 
              </programlisting>
            </listitem>
          </itemizedlist></para>

        <para>Using address and physical address objects in a rule is
        not the same as using the host or interface object to which
        these address and physical address belong. Here is what
        happens if we put objects representing IP address and MAC
        address in the rule:</para>

        <figure id="addr-and-phaddr">
          <title>Policy Rule Using Address and Physical Address
          Objects</title>
              <graphic scale="70" fileref="objects/images/using-physaddress-7.png" />
        </figure>

	<para> For this rule, the following iptables commands are generated:</para>
	<programlisting>
$IPTABLES -A FORWARD  -s 10.3.14.44  -m state --state NEW  -j ACCEPT 
$IPTABLES -A FORWARD  -m mac --mac-source 00:1D:09:8B:8E:94 -m state --state NEW \
-j ACCEPT 
        </programlisting>  

	<para>As described in <xref linkend="multiple-addresses"/>,
        using an multiple objects in the rule element is like bundling
        them together using logical
        operation <emphasis>OR</emphasis>. If we were to put address
        and physical address in the rule as in
        <xref linkend="addr-and-phaddr"/>, we would end up with a
        policy matching packets that have the source address
        10.3.14.44 or MAC address 00:1D:09:8B:8E:94, but not
        necessarily both at the same time. Any host that manages to
        pretend to have the IP address 10.3.14.44 would be able to
        send packets through our firewall even if its MAC address is
        different. To achieve our goal and make sure packets with the
        source 10.3.14.44 really belong to our important host, we
        should be checking its IP address and MAC address at the same
        time and let a packet through only if its IP
        address <emphasis>AND</emphasis> MAC address are what we
        expect them to be. That is why Firewall Builder treats
        physical addresses differently and generates firewall code
        that inspects both IP address and physical address.</para>

        <para>Firewall Builder generates firewall code to inspect MAC
        address only for host objects with the option <guilabel>MAC
        address filtering</guilabel> turned on. If this option is off,
        the physical address object is ignored even if it is
        present in the host object's interface. This is because host
        objects created using the Network Discovery Druid (
        <xref linkend="network-discovery"/> ) are often populated
        with both IP address and MAC address information (available
        through SNMP query), but inspection of MAC addresses is rarely
        needed. Use the <guilabel>MAC address filtering</guilabel>
        option in the host object to specify that you want the MAC
        address to be verified for the host.</para>

	<note><para>The target firewall imposes certain restrictions
	on rules matching the MAC address. For example, only source
	MAC addresses can be matched. Firewall Builder is aware of
	these restrictions, and the policy compiler issues an
	error if a physical address object is used in a rule that
	would lead to an impossible iptables command.</para></note>
      </sect3>
    </sect2>

    <sect2 id="host-object">
      <title>Host Object</title>

      <para>The host object in Firewall Builder is designed to
      represent real hosts in the network: workstations, servers, and
      any other network node with an address. Just like real hosts,
      host objects have interfaces that represent different physical
      connections to the network. </para>

      <para>Most hosts have just a single (visible) interface with a
      single IP address. In that case the actual interface and its
      name do not matter. For most foreign hosts, Firewall Builder
      assigns an arbitrary name, like
      <quote>interface1</quote>, to the host's interface. However, by using the tree-like
      hierarchy of hosts -&gt; interfaces -&gt; addresses, it is possible
      to specify the exact address and/or interface of a host in cases where it does matter.</para>

      <para>As in the Firewall object, interfaces and addresses are
      represented by objects that are organized in a tree. An
      interface can have multiple addresses. An example of a host with
      one interface and multiple addresses is shown in
      <xref linkend="host-in-tree" />. Host <quote>test server</quote>
      is located on the LAN and has three virtual IP addresses that
      all belong to the same interface, <quote>eth0</quote>.</para>

      <para>Note that in Firewall Builder, the host object is an
      abstraction. It does not have to conform to an individual
      host. This host object may in fact represent a web farm that
      accepts connections on three IP addresses, each on a different
      computer.
      </para>

      <figure id="host-in-tree">
        <title>A Host Object with One Interface and Multiple Virtual
        Addresses</title>
            <graphic scale="70" fileref="objects/images/host_in_tree.png" />
      </figure>

      <note>
        <para>The host object cannot have any access, NAT, or routing
        policy associated with it; only firewall objects can have
        policies.</para>
      </note>

    <sect3>
      <title>Creating a Host Object</title>

      <para>To speed up the process and make it simpler, creating a new host
      object is aided by a wizard that is similar to the one for creating a new Firewall Objects.</para>

      <para>To launch the wizard, select <guimenuitem>New
      Host</guimenuitem> from the <guimenu>New Object</guimenu> menu
      or right-click  <guimenuitem>Hosts</guimenuitem> and select it
      from there.</para>

      <para><xref linkend="firewall-object"/> shows how to use the
     firewall object wizard. The host object wizard is the same, with
      the following exceptions:</para>

      <itemizedlist spacing="compact">
          <listitem>
            <para>All methods</para>

            <para>You do not specify the operating system or platform for host objects.</para>
          </listitem>

          <listitem>
            <para>From template</para>

            <para>The Host object templates are different than those
            for Firewall objects. Browse through the list in Firewall
            Builder to see what's available.</para>
          </listitem>

          <listitem>
            <para>Manually</para>

            <para>This method works the same as for the Firewall
            object, though the <guilabel>Add Interfaces</guilabel>
            page is slightly different. You cannot tag an interface as
            a "bridge port" interface. You can, however, indicate it
            is unnumbered or dynamic by selecting the appropriate
            checkbox. If neither checkbox is selected, then the
            interface is assumed to have a static IP address. As with
            the firewall object wizard, you can only add IPv4
            addresses in this way. If you need to use IPv6 addresses,
            create the host object without IP addresses and add them
            later.</para>
          </listitem>

          <listitem>
            <para>Via SNMP</para>

            <para>This method works the same as for a Firewall
            object. The host object must have the same name as the
            actual device and the host must respond to SNMP.</para>
          </listitem>
        </itemizedlist>

      <note>
        <para>You can always add, modify, and remove interfaces of the new host
        object later using controls provided in the main window and object
        tree view.</para>
      </note>
    </sect3>

    <sect3>
      <title>Editing a Host Object</title>

      <figure id="host-dialog1">
        <title>Editing the Host Object</title>
            <graphic scale="60" fileref="objects/images/host_dialog1.png" />
      </figure>

      <para>The Host object dialog allows you to edit the following parameters:</para>

      <para><itemizedlist spacing="compact">
          <listitem>
            <para>Name:</para>

            <para>The host object name.</para>
          </listitem>

          <listitem>
            <para>MAC matching:</para>

            <para>If this option is activated, the policy compiler
            uses the MAC addresses of all interfaces of this host in
            the firewall rules. Not all firewall platforms support MAC
            address filtering, so this option may have no effect on
            the generated firewall script. This is treated as a
            non-critical situation, and the policy compiler will only
            generate a warning while processing a firewall policy
            where such a host is used. You cannot enter the physical
            (MAC) address in this dialog, however. See
            <xref linkend="using-mac-address" />.</para>
          </listitem>

          <listitem>
            <para>Comment:</para>

            <para>This is a free-form text field which can be used to add
            comments.</para>
          </listitem>
        </itemizedlist></para>
      </sect3>
      
      <sect3>
	<title>Using a Host Object in Rules</title>

	<para>When a host object is used in a rule, it acts as a group
	of all of the addresses that belong to all of its
	interfaces. The only exception is the loopback interface; the
	compiler skips that address when replacing the host object
	with its addresses.</para>

	<para>Consider the following Host object. It has interface
	eth0 with two IP addresses and a MAC address, interface
	he-ipv6 with an IPv6 address and a MAC address, interface lo
	(loopback) with its own IP address and interface sit0 (tunnel)
	with no address.</para>

      <figure id="host_example_1">
        <title>Host with multiple interfaces, Some with Multiple Addresses</title>
            <graphic scale="70" fileref="objects/images/host_example_1.png" />
      </figure>

      <para>Let's put this host object in a rule as follows:</para>

      <figure id="host_example_2">
        <title>Host in a Rule</title>
            <graphic scale="70" fileref="objects/images/host_example_2.png" />
      </figure>

      <para>The rule set is configured as "IPv4 only", so even though
      interface he-ipv6 has IPv6 address, Firewall Builder will ignore
      it while generating iptables commands for this rule. Interface
      eth0 has two IPv4 addresses and both will be used. Here are
      iptables commands generated for this rule:</para>

      <programlisting>
$IPTABLES -A FORWARD -p tcp -m tcp  --dport 22  -m state --state NEW \
-j Cid6066X5981.1 
$IPTABLES -A Cid6066X5981.1  -d 10.3.14.44  -j ACCEPT 
$IPTABLES -A Cid6066X5981.1  -d 10.3.14.55  -j ACCEPT 
$IPTABLES -A Cid6066X5981.1  -d  -j ACCEPT 
      </programlisting>

      <para>Let's see what we get for the same rule if we configure rule set object as "IPv4+IPv6":</para>

      <figure id="host_example_3">
        <title>Host in a Rule with both IPv4 and IPv6</title>
            <graphic scale="70" fileref="objects/images/host_example_3.png" />
      </figure>

      <para>Since the rule is now configured to compile for both
      address families, Firewall Builder processes it twice, once for
      each address family. Here is what we get (these are relevant
      fragments of the generated script):</para>

      <programlisting>
# ================ IPv4

$IPTABLES -A FORWARD -p tcp -m tcp  --dport 22  -m state --state NEW  \
-j Cid6066X5981.1 
$IPTABLES -A Cid6066X5981.1  -d 10.3.14.44  -j ACCEPT 
$IPTABLES -A Cid6066X5981.1  -d 10.3.14.55  -j ACCEPT 
$IPTABLES -A Cid6066X5981.1  -d  -j ACCEPT 

# ================ IPv6

$IP6TABLES -A FORWARD -p tcp -m tcp  --dport 22  -m state --state NEW  \
-j Cid6066X5981.1 
$IP6TABLES -A Cid6066X5981.1  -d fe80::a3:e2c  -j ACCEPT 
     </programlisting>
      </sect3>

        <sect3 id="multiple-addresses">
      <title>Using Objects With Multiple Addresses in the Policy and NAT
      Rules</title>

      <para>Host and firewall objects have child interface objects,
      which in turn have child address and physical address
      objects. In fact, an interface object can have more than one
      associated address object. Let's see how this works:</para>

      <figure id="multiple-addresses-obj1">
        <title>Host Object with an Interface with Multiple
        Addresses</title>
            <graphic scale="70" fileref="objects/images/multiple-addresses-obj1.png" />
      </figure>

      <figure id="multiple-addresses1">
        <title>Using Objects with Multiple Addresses in Policy
        Rules</title>
            <graphic scale="70" fileref="objects/images/multiple-addresses-rule1.png" />
      </figure>

      <para>Consider example <xref linkend="multiple-addresses-obj1" />, <xref
      linkend="multiple-addresses1" />. Here interface
      <emphasis>eth0</emphasis> of "test
      server" has three IP addresses (named "test
      server:eth0:0" through "test
      server:eth0:2") and interface <emphasis>eth0</emphasis> of
       "dmz host" has only one IP address:
      "dmz host:eth0". Policy rule #9 says that
      "dmz host" can talk to "test
      server" using any protocol. Since "test
      server" has three different addresses, we need to generate
      policy a rule that will match any of them. (Obviously we cannot match all three at
      once, so the compiler uses a logical "OR", not a logical 
      "AND" here.) Basically, rule #9 is equivalent to three separate rules,
      each of them using one address of "test server" in
      turn. These three rules are represented in <xref
      linkend="multiple-addresses2" /> (original rule #9 also shown there, but
      it is disabled.)</para>

      <figure id="multiple-addresses2">
        <title>Equivalent Rules</title>
            <graphic scale="60" fileref="objects/images/multiple-addresses-rule2.png" />
      </figure>

      <para>Firewall Builder takes care of this situation automatically and
      generates the firewall policy described in <xref
      linkend="multiple-addresses1" /> as if a user had built a policy in the
      GUI using the three rules as shown in <xref
      linkend="multiple-addresses2" />.</para>

      <para>In fact, the algorithm used is even more general. In the
      example <xref linkend="multiple-addresses1"/>, host "test
      server" has a single interface with multiple addresses that the 
      compiler used to generate the target firewall code. The policy compiler
      works in a similar way even if the host or firewall object used in the rule
      has multiple interfaces and each interface, in turn, has multiple
      addresses. If a host (or firewall) object is used in the rule, then the
      compiler scans all its interfaces, finds all corresponding addresses, and
      uses them to generate the firewall configuration. If an interface object is
      used in the rule, then the compiler uses all its addresses. And finally,
      if an address or physical address object is used in the rule, then the compiler
      uses only this parameter to generate the firewall configuration.
      In other words, the compiler always traverses the tree, starting from the
      object found in the policy rule, and uses the parameters of all address and
      physical address objects it finds. Since address and physical address
      objects are the leaf nodes in the tree and have no other objects beneath
      them, the compiler uses the parameters of these objects to
      generate the target code.</para>

      <note>
        <para>There is an exception to this algorithm, see <xref
        linkend="using-mac-address" /></para>
      </note>
    </sect3>
    </sect2>

    <sect2 id="ipv4-network-object">
      <title>IPv4 Network Object</title>

      <figure id="network-dialog1">
        <title>The Network Object</title>
            <graphic scale="60" fileref="objects/images/network_dialog1.png" />
      </figure>

      <para>The network object describes an IP network or subnet. Use
      main menu <guimenuitem>Net Object / New Network</guimenuitem>
      item to create objects of this type. The Network object dialog 
      object provides the following entry fields: </para>

      <para><itemizedlist spacing="compact">
          <listitem>
            <para>Name:</para>

            <para>Network Object Name</para>
          </listitem>

          <listitem>
            <para>Address:</para>

            <para>The IPv4 address of the network.</para>
          </listitem>

          <listitem>
            <para>Netmask:</para>

            <para>The netmask, in combination with an address, defines
            the subnet. You can enter either a string octet
            representation of the mask or its bit length here; however
            the program always converts it to the octet
            representation. The netmask in the network object is always
            entered in the "natural" way, such as "255.255.255.0",
            even if the object is going to be used to build Cisco IOS
            access lists which require reversed "bit mask"
            presentation instead (e.g., "0.0.0.255" for the netmask
            above). The Firewall Builder policy compiler automatically makes the required conversion. </para>
          </listitem>

          <listitem>
            <para>Comment:</para>

            <para>This is a free-form text field used for comments.</para>
          </listitem>
        </itemizedlist></para>

	<para>Let's use the network object shown above in a policy rule compiled for different target platforms.</para>

      <figure id="network_example_1">
        <title>IPv4 Network Object Used in a Rule</title>
            <graphic scale="70" fileref="objects/images/network_example_1.png" />
      </figure>

	<para> Here is what we get for iptables:</para>
<programlisting>
$IPTABLES -A FORWARD -p tcp -m tcp  -s 172.16.22.0/24  --dport 80  -m state \
--state NEW  -j ACCEPT 
</programlisting>

	 <para>Here is the output produced for PF:</para>
<programlisting>
pass in   quick inet proto tcp  from 172.16.22.0/24  to any port 80 keep state
pass out  quick inet proto tcp  from 172.16.22.0/24  to any port 80 keep state
</programlisting>          

	  <para>Here is how the output looks like when the rule is
	  compiled into Cisco IOS access lists. (This is one of the
	  generated access lists.)</para>

          <programlisting>
ip access-list extended outside_out
  permit tcp 172.16.22.0 0.0.0.255 any  eq 80 
exit
          </programlisting>          

	  <para>Here is what we get when the rule is compiled into
	  Cisco ASA (PIX) configuration. Note how the compiler uses
	  netmask 255.255.255.0 for PIX, while for IOS it was
	  converted to 0.0.0.255. Also, the interface "inside" was
	  configured with network zone 172.16.0.0/12, which matched
	  network object used in the source element of the
	  rule. Because of that, the compiler put the rule only into
	  the access list attached to interface "inside."</para>

          <programlisting>
access-list inside_acl_in permit tcp 172.16.22.0 255.255.255.0 any eq 80 
access-group inside_acl_in in interface inside
          </programlisting>          

    </sect2>

    <sect2 id="ipv6-network-object">
      <title>IPv6 Network Object</title>

      <figure id="ipv6-network-dialog1">
        <title>IPv6 Network Object</title>
            <graphic scale="60" fileref="objects/images/ipv6-network_dialog1.png" />
      </figure>

      <para> The network object describes an IPv6 network or
      subnet. This object is very similar to the IPv4 network object,
      except you can only enter netmask as a bit length. Use main menu
      "Net Object / New Network IPv6" item to create objects of this
      type.</para>

      <para>Let's see what we get if we use an IPv6 network object in a policy rule as shown:</para>

      <figure id="ipv6_network_example_1">
        <title>IPv6 Network Object Used in a Rule</title>
            <graphic scale="70" fileref="objects/images/ipv6_network_example_1.png" />
      </figure>

      <para> Here is the command generated for iptables:</para>
      <programlisting>
$IP6TABLES -A FORWARD -p tcp -m tcp  -s 2001:470:1f0e:162::/64  --dport 80  \
-m state --state NEW  -j ACCEPT 
      </programlisting>

      <para>Here is what we get for PF:</para>
      <programlisting>
pass in   quick inet6 proto tcp  from 2001:470:1f0e:162::/64  to any port 80 keep state
pass out  quick inet6 proto tcp  from 2001:470:1f0e:162::/64  to any port 80 keep state
      </programlisting>          

      <para>Here is the output for Cisco IOS access lists (only one ACL is shown):</para>
      <programlisting>
ipv6 access-list ipv6_outside_out
  permit tcp 2001:470:1f0e:162::/64 any  eq 80 
exit

interface eth0
  ipv6 traffic-filter ipv6_outside_out out
exit
      </programlisting>             

      <para>There is no IPv6 support for Cisco ASA (PIX) in Firewall Builder at this time.</para>

    </sect2>

    <sect2 id="address-range-object">
      <title>Address Range Object</title>

      <figure id="address_range_1">
        <title>The Address Range Object</title>
            <graphic scale="60" fileref="objects/images/address_range_1.png" />
      </figure>

      <para>The address range object describes a continuous range of
      IPv4 addresses. (Arbitrary address ranges for IPv6 is not supported.) To create a new address rRange object, use the main
      menu <guimenuitem>New Object / New Address
      Range</guimenuitem>option. Its dialog provides the following entry
      fields:</para>

      <para><itemizedlist spacing="compact">
          <listitem>
            <para>Name:</para>

            <para>The name of the address range object</para>
          </listitem>

          <listitem>
            <para>Range start:</para>

            <para>The address of the start of the range.</para>
          </listitem>

          <listitem>
            <para>Range end:</para>

            <para>The address of the end of the range.</para>
          </listitem>

          <listitem>
            <para>Comment:</para>

            <para>A free-form text field used for comments.</para>
          </listitem>
        </itemizedlist></para>

      <para>The address range is inclusive; that is, both the start and the
      end addresses are included in the range.</para>

      <para> When the address range object is used in a rule, Firewall
      Builder replaces it with a list of addresses equivalent to the
      specified range. The program tries to generate the most
      economical representation of the range using a combination of
      subnets of different lengths. Consider the address range object
      shown above. This address range object represents IP addresses
      between 192.168.1.100 and 192.168.1.160 (inclusively). It would
      be wasteful to generate 61 iptables commands to represent this
      range. Instead, the compiler uses a combination of several
      subnets of different lengths and ends up with the
      following:</para>

      <programlisting>
$IPTABLES -A FORWARD  -s 192.168.1.100/30  -m state --state NEW  -j ACCEPT 
$IPTABLES -A FORWARD  -s 192.168.1.104/29  -m state --state NEW  -j ACCEPT 
$IPTABLES -A FORWARD  -s 192.168.1.112/28  -m state --state NEW  -j ACCEPT 
$IPTABLES -A FORWARD  -s 192.168.1.128/27  -m state --state NEW  -j ACCEPT 
$IPTABLES -A FORWARD  -s 192.168.1.160  -m state --state NEW  -j ACCEPT 
      </programlisting>        

      <para>Here is how the generated configuration looks for PF (this
      is essentially the same, except it uses tables for
      brevity):</para>
      
      <programlisting>
table &lt;tbl.r0.s&gt; { 192.168.1.100/30 , 192.168.1.104/29 , 192.168.1.112/28 , \
192.168.1.128/27 , 192.168.1.160 } 

pass in   quick inet  from &lt;tbl.r0.s&gt;  to any keep state
      </programlisting>

      <para>Just for completeness, let's look at the configuration
      generated for the same rule for Cisco IOS access lists. This is
      really just a fragment of the generate router access list
      configuration because generated ACLs are attached to interfaces
      and, since the rule in the example was not associated with any
      interfaces, it is attached to all of them. Here we show only
      one generated ACL:</para>

      <programlisting>
ip access-list extended inside_in
! 
! Rule  0 (global)
! 
! 
  permit ip 192.168.1.100 0.0.0.3 any  
  permit ip 192.168.1.104 0.0.0.7 any  
  permit ip 192.168.1.112 0.0.0.15 any  
  permit ip 192.168.1.128 0.0.0.31 any  
  permit ip host 192.168.1.160 any  
exit
      </programlisting>

    </sect2>



    <sect2 id="address-table-object">
      <title>Address Tables Object</title>

      <para>Sometimes you need to apply a rule to a set of addresses,
      but you don't know what those addresses will be when you're
      writing the policy. The address table object 
      object can help in these situations.</para>

      <figure id="address-table-dialog1">
        <title>The Address Table Object</title>
            <graphic scale="70" fileref="objects/images/address_table_2.png" />
      </figure>

      <para>The address table object has the following fields:</para>

      <itemizedlist spacing="compact">
          <listitem>
            <para>Name:</para>

            <para>The name of the address rable object.</para>
          </listitem>

          <listitem>
            <para>Compile Time / Run Time:</para>

            <para>Indicates whether you want the file to be loaded with
            the firewall compiler runs (Compile Time) or when the
            firewall runs the firewall script (Run Time). </para>
          </listitem>

          <listitem>
            <para>File name:</para>

            <para>The name of the text file you want to load. (The
            file contains IP addresses or IP address ranges.) The
            filename can have any extension. If you want the file to
            load at run time, you must specify the path and name where
            the file will be on the firewall
            machine, not on the client machine.</para>
          </listitem>

          <listitem>
            <para>Choose File button:</para>

            <para>
              Used to populate the file name and path if the file 
              is on the local machine. You can also type in a path 
              to a filename that you want to create.
            </para>
          </listitem>

          <listitem>
            <para>Edit File button:</para>

            <para>
              Once the File name field is populated, use this button 
              to view and update the file. If the file does not already 
              exist, Firewall Builder will generate a warning message.
            </para>
          </listitem>

          <listitem>
            <para>Comment:</para>

            <para>A free-form text field used for comments</para>
          </listitem>
        </itemizedlist>

	<para>
    The <guilabel>Compile Time</guilabel> and <guilabel>Run
    Time</guilabel> radio buttons define when the addresses will
    be read from the file: when the firewall script is generated
    by Firewall Builder or when the firewall runs the script.
  </para>
  
  <para>
    If object is configured as <guilabel>Compile Time</guilabel>, the
    Firewall Builder policy compiler opens the file during
    compilation and replaces the address
    table object in policy rules with the set of
    addresses from the file. This means the file with addresses
    must be accessible on the machine where the Firewall Builder
    GUI and policy compilers run. 
  </para>
  
  <para> 
    If the object is configured as <guilabel>Run Time</guilabel>, 
    policy compiler does not try to find and open the file but 
    instead generates a firewall script that will do this when it 
    is activated. This means the file with addresses must be located 
    where it is accessible by	the firewall, and the object must be 
    configured with the full path to it on the firewall.
  </para>

	<para>Here is an example of the file contents (this is what
	you see if you click the <guilabel>Edit File</guilabel> button in the object
	dialog):</para>

      <figure id="address-table-textfile">
        <title>Address Table Text File</title>
            <graphic scale="70" fileref="objects/images/edit_address_table.png" />
      </figure>

      <para>Note that comments in the file can start with "#" or ";",
      that a comment can follow an address on the same line or take
      the whole line, and that lines can start with white space for
      formatting. This example file contains both IPv4 and IPv6
      addresses for illustration purposes.</para>

      <para>Compile-time address table objects are supported on all
      target firewall platforms because addresses are read by the
      compiler. The compiler then generates normal configuration lines
      or script commands. Run-time address table objects require
      special support from the target firewall and are therefore supported
      only on some of them. Currently run-time address table objects
      can be used in rules for iptables and PF firewalls.</para>

      <para>Let's look at the firewall script generated by Firewall
      Builder for the iptables and PF when the Address Table object
      used in the policy rule is configured first as "Compile Time"
      and then as "Run Time". The rule is very simple and looks like
      (<xref linkend="address-table-rule" />):</para>

      <figure id="address-table-rule">
        <title>Rule Using an Address Object</title>
            <graphic scale="70" fileref="objects/images/address_table_3.png" />
      </figure>

      <para>This rule, with the object set to <guilabel>Compile Time</guilabel>, generates the following output:</para>

      <figure id="address-table-compile-iptables">
        <title>Compile Time, iptables Compile Output</title>
            <programlisting>
# Rule 0 (global)
# 
$IPTABLES -A INPUT  -d 192.168.1.1  -j DROP 
$IPTABLES -A FORWARD  -d 192.168.1.2  -j DROP 
$IPTABLES -A FORWARD  -d 192.168.1.3/30  -j DROP 
$IPTABLES -A FORWARD  -d 192.168.2.128/25  -j DROP 
$IPTABLES -A FORWARD  -d 192.168.1.200  -j DROP 
$IPTABLES -A FORWARD  -d 192.168.1.201  -j DROP 
</programlisting>
      </figure>

      <para>The compiler replaced
     the object <guilabel>address_table_1</guilabel> in the Destination
      with addresses it took from the file. Option <guilabel>assume
      firewall is part of any</guilabel> was turned off in the
      firewall object settings, which is why compiler did not generate
      rules in the OUTPUT chain. However, one of the addresses in the
      file matched the address of one of the interfaces of the
      firewall (192.168.1.1) and the corresponding rule went into the
      INPUT chain. Other addresses were copied from the file verbatim,
      including netmask specifications. The policy object of this
      firewall was configured as "IPv4 rule set", because of this the
      compiler dropped the IPv6 addresses it found in the file. If the
      rule set was configured as a mix of IPv4 and IPv6, compiler
      would use IPv4 addresses in IPv4 rules and IPv6 addresses in
      IPv6 rules.</para>

      <figure id="address-table-compile-pf">
        <title>Compile Time, PF Compile Output</title>
            <programlisting>
# Tables: (1)
table  { 192.168.1.1 , 192.168.1.2 , 192.168.1.3/30 , 192.168.2.128/25 , \
192.168.1.200 , 192.168.1.201 }

# Rule  0 (global)
# 
block in   quick inet  from any  to &lt;tbl.r0.d&gt;
block out  quick inet  from any  to &lt;tbl.r0.d&gt;

</programlisting>
      </figure>

      <para>The output for PF is simple because Firewall Builder can
      use the built-in table facility. All addresses are copied from
      the file verbatim into the table tbl.r0.d.</para>

      <figure id="address-table-run-iptables">
        <title>Run Time, iptables Compile Output</title>
            <programlisting>
# Using 1 address table files
check_file "address_table_1" "/home/vadim/addr-table-1.tbl"

# Rule 0 (global)
# 
grep -Ev '^#|^;|^\s*$' /home/vadim/addr-table-1.tbl | while read L ; do
  set $L; at_address_table_1=$1; $IPTABLES -A FORWARD  -d $at_address_table_1  -j DROP 
done
</programlisting>
      </figure>

      <para> First, the generated script checks if the file specified
      in the address table object exists on the firewall machine. If
      the file is not found, the script aborts execution to avoid
      loading incomplete iptables rules. However, the script cannot
      verify that the file is the one you intended it to be; it just
      assumes that if the file with this name exists it is the right
      one and tries to interpret it as a list of IP addresses, with
      one address per line. Then the script reads the file line by
      line, skipping comments, and assigns IP addresses to the shell
      variable at_address_table_1, which it then uses in the iptables
      command.</para>

      <para>Since the compiler did not see the addresses from the
      file, it could not detect that one of them matched an address of
      the firewall and all iptables commands went to the FORWARD
      chain. The file /home/vadim/addr-table-1.tbl should be located
      on the firewall where the generated iptables script will be
      executed so the script can find it.</para>

      <para>Here is what you get if the option <guilabel>"Assume
      firewall is part of any"</guilabel> is turned on in the firewall
      object settings:</para>

      <figure id="address-table-run-iptables-assume">
        <title>Run Time, iptables Compile Output: assume firewall is part of "any"</title>
            <programlisting>
# Rule 0 (global)
# 
grep -Ev '^#|^;|^\s*$' /home/vadim/addr-table-1.tbl | while read L ; do
  set $L; at_address_table_1=$1; $IPTABLES -A OUTPUT  -d $at_address_table_1  -j DROP 
done
grep -Ev '^#|^;|^\s*$' /home/vadim/addr-table-1.tbl | while read L ; do
  set $L; at_address_table_1=$1; $IPTABLES -A FORWARD  -d $at_address_table_1  -j DROP 
done
</programlisting>
      </figure>

      <para>The difference is that compiler generated two sets of
      commands, one in chain OUTPUT and another in chain FORWARD. The
      original rule has "any" in source, and if the 
      option <guilabel>Assume firewall is part of any</guilabel> is
      turned on, the compiler assumes the source of the rule can have
      either an unknown address or the firewall. The former makes it
      generate iptables command in the FORWARD chain and the latter
      makes it generate iptables command in the OUTPUT chain. This
      logic is not specific to the address table object type; the
      compiler does this regardless of the type of the object used in
      destination if source is "any" and option <guilabel>Assume
      firewall is part of any</guilabel> is turned on.</para>

      <figure id="address-table-run-pf">
        <title>Run Time, PF Compile Output</title>
            <programlisting>
# Tables: (1)
table  persist file "/home/vadim/addr-table-1.tbl"
# Rule  0 (global)
# 
# 
block in   quick inet  from any  to &lt;address_table_1&gt;
block out  quick inet  from any  to &lt;address_table_1&gt;
</programlisting>
      </figure>

      <para>PF is even easier in the case of run time address
      tables. The compiler just uses <emphasis>table</emphasis> facility
      with <emphasis>persist</emphasis> and <emphasis>file</emphasis>
      options to direct pfctl to open the file and read its
      contents. In this case, the file should follow the formatting
      requirements of PF.</para>

      <para>Policy compiler for PF treats address table objects with
      empty file name in a special way. It just generates the line "table
      &lt;table_name&gt;" at the beginning of the .conf file with no
      file specification. This table will not be populated when .conf
      file is loaded and therefore will remain empty, but it can be
      used in the rules.</para>

      <para>Addresses can be added to the table later using external scripts that call pfctl like this:</para>

      <figure id="pfctl-add-host">
        <title>Using pfctl to add a host to the table</title>
      <programlisting>
pfctl -t bad_hosts -T add 192.0.2.1
      </programlisting>
      </figure>

      <para>Another interesting possibility is to automatically
      populate the table if option "overload" is used in combination
      with other rate limiting options on a rule. Taking an example
      from the man page for pf.conf, here is how it looks:</para>

        <figure id="example-auto-populating-table">
            <title>Example using the "overload" command to auto populate a table</title>
            <programlisting>
block quick from &lt;bad_hosts&gt;
pass in on $ext_if proto tcp to $webserver port www keep state \
                   (max-src-conn-rate 100/10, overload &lt;bad_hosts&gt; flush global)
            </programlisting>
        </figure>

      <para>The idea behind these rules is that if some host tries to
      connect to the web server too often -- more often than is
      allowed by max-src-conn-rate 100/10 -- its address will be
      added to the table &lt;bad_hosts&gt; by PF. The next time this
      host tries to connect, the packet coming from it will be denied
      by the blocking rule right away.</para>

      <para>To implement these rules in Firewall Builder, you would
      create an Address Table object with the name "bad_hosts" but a blank
      file name, configured to resolve at run time:</para>

      <figure id="address-table-bad-hosts">
        <title>Address Table Object bad_hosts</title>
            <graphic scale="70" fileref="objects/images/address_table_5.png" />
      </figure>

      <para>Then, use this address table object in the source field of
      a policy rule with action "Deny". This is rule #0 in the
      screenshot below. Another rule, rule #1 in the screenshot, has
      action "Accept" and matches destination against address of the
      web server, protocol http, and has limiting options set up to
      restrict the number of connections and to
      turn <guilabel>overload table</guilabel> on, with the name of
      the overload table "bad_hosts" that matches the name of the
      address table object.</para>

      <figure id="address-table-bad-hosts-rules">
        <title>Address Table Object bad_hosts Rules</title>
            <graphic scale="60" fileref="objects/images/address_table_6.png" />
      </figure>

      <para>These two rules, as shown on the screen shots, yield the
      following PF configuration that matches the one given in the man
      page:</para>

        <figure id="example-using-pf-tables">
            <title>Example pf rules using table objects</title>
            <programlisting>
# Tables: (1)
table &lt;bad_hosts&gt; persist

# Rule  0 (global)
# 
block in   log  quick inet  from &lt;bad_hosts&gt;  to any 
# 
# Rule  1 (global)
# 
pass in   quick inet proto tcp  from any  to 192.168.1.1 port 80 \
   keep state  (  max-src-conn-rate 100/10, overload &lt;bad_hosts&gt; flush global ) 

            </programlisting>
        </figure>

    <sect3 id="set-address-table-object">
      <title>Using Address Tables Objects with iptables IP Sets</title>

    <para>
    Beginning with Firewall Builder version 4.1, there is support for iptables 
    firewalls to use the netfilter <emphasis>ipset</emphasis> module.  The 
    ipset module  provides a method for storing a list of IP addresses or IP 
    subnets in  memory. This allows firewall administrators to define a single 
    iptables  rule that matches multiple IP addresses or IP subnets as the 
    source and/or destination. In Firewall Builder an "ipset" is associated 
    with an address table object where the list of addresses and subnets are 
    defined in a file.
    </para>

    <para>
    Using the IP sets feature requires an iptables version of at least 1.4.1.1 
    and requires that the target firewall have the ipset module installed.  There
    are instructions for installing the ipset module for some distributions described 
    in the Appendix <xref linkend="iptables_install_ipset"/>.  If you have installation
    instructions for installing the ipset module on a distribution not listed 
    in the Appendix please e-mail <ulink url="mailto:info@fwbuilder.org">
    info@fwbuilder.org</ulink>. 
    </para>

    <para>
    You can find more information about the netfilter ipset module 
    <ulink url="http://ipset.netfilter.org/features.html"><citetitle>at the netfilter IP sets page</citetitle></ulink>.
    </para>

    <note><title>NOTE: Testing if your iptables firewall supports IP set</title>
    <para>
    To test if your firewall has the ipset module and ipset tools installed 
    run the following commands from a shell.  Note you must be root or have sudo
    rights to run the command.
    </para>
    <para>
    <emphasis>Test to check if ipset tools are installed</emphasis>
    <programlisting>
fwadmin@guardian:~$ sudo ipset --version
ipset v2.5.0 Protocol version 2.
fwadmin@guardian:~$
    </programlisting>
    </para>

    <para>
    <emphasis>Test to check if ipset module is installed</emphasis>
    <programlisting>
fwadmin@guardian:~$ sudo ipset -N test iphash
FATAL: Module ip_set not found.
ipset v4.1: Couldn't verify kernel module version!
fwadmin@guardian:~$
    </programlisting>
    </para>
    </note>

    <para>
    To enable the iptables "IP sets" functionality in Firewall Builder, you must 
    explicitly set the version of the iptables firewall that you want to use 
    with the ipset module. Navigate to the firewall and double-click to open 
    the object in the editor window. Set the iptables version number to a 
    version that is at least 1.4.1.1.
    </para>

      <figure id="ipset-firewall-version-setting">
        <title>Set the firewall iptables version number</title>
            <graphic scale="70" fileref="objects/images/ipset_firewall_version.png" />
      </figure>

    <para>
    After you have set the iptables version number, click  <guilabel>Firewall 
    Settings</guilabel> for this firewall.  Near the bottom of the <guilabel>
    Firewall Settings</guilabel> dialog window you there is a checkbox that
    says:
    </para>
    <para>
    <emphasis>
    Use module "set" for run-time address table objects. (This module is only 
    available in iptables v 1.4.1.1 and later.)
    </emphasis>
    </para>
    <para>
    Select this checkbox to enable using the iptables ipset module.
    </para>

      <figure id="ipset-firewall-setting">
        <title>Set the Firewall Settings to Use the "IP set" Module</title>
            <graphic scale="50" fileref="objects/images/ipset_firewall_settings.png" />
      </figure>

    <para>
    If the checkbox and text are shown as greyed out, then go back and check
    that you set the iptables version number for this firewall.
    </para>

    <para>
    You can only use address tables that are set to <guilabel>Run Time
    </guilabel> with the ipset module.  <guilabel>Compile Time</guilabel> 
    address table objects will behave as before with the objects in the 
    specified file being expanded when the firewall is compiled.
    </para>

    <note><title>NOTE: Mixed IP addresses and IP Subnets in "IP Sets"</title>
    <para>
    Normally the ipset module requires you to create separate "sets" for
    IP addresses and IP subnets.  Firewall Builder, through its abstraction 
    layer, enables you to create mixed IP addresses and IP subnets in the 
    same file. This creates what is known as a "set list" that contains two
    "sets", one "set" that includes only IP addresses and another "set" that
    includes only IP subnets.
    </para>
    </note>

    <para>
    The following example shows the Firewall Builder configuration steps for
    setting up an Addresss Table called "bad_hosts", using that address table
    in a rule, and confirming the ipset configuration.
    </para>

    <figure id="ipset-address-table-object">
        <title>Address Table Object</title>
            <graphic scale="50" fileref="objects/images/ipset_address_table_object.png" />
    </figure>

    <figure id="ipset-address-table-file">
        <title>Editing the Address Table File</title>
            <graphic scale="50" fileref="objects/images/ipset_address_table_file.png" />
    </figure>
    
    <figure id="ipset-address-table-rule">
        <title>Rule Using Address Table Object</title>
            <graphic scale="50" fileref="objects/images/ipset_address_table_rule.png" />
    </figure>

    <para>
    You can use the ipset tools to view the configuration of your "sets" once
    they have been created by Firewall Builder on your firewall.  For example,
    the command <command>ipset --list</command> will list all the configured
    "sets" on your firewall.
    </para>

    <para>
    If you install a firewall that is using address tables with ipset enabled
    you can update the list of addresses that are stored in memory for that 
    "set" by updating the file associated with the address table object and then
    running the <command>firewallscript.fw reload_address_table</command> command.  For
    the examples shown above you would enter:
    <programlisting>guardian.fw reload_address_table bad_hosts /etc/fw/bad_hosts
    </programlisting>
    where "guardian.fw" matches the name of your Firewall Builder script file 
    and "bad_hosts" is your address table object. This dynamically updates the
    list of addresses stored in memory for the bad_hosts set while iptables is
    running.
    </para>

    <note><title>NOTE: Naming Convention for Address Table Objects and "Sets"</title>
    <para>
    When Firewall Builder creates the "set" it substitutes an underscore ("_")
    for any spaces.  For example, the address table named "My Address List"
    would have a "set" name of "My_Address_List".  Also, note that the name
    of the address table object cannot start with colon (":") due to 
    restrictions in the ipset module.
    </para>
    </note>

    <para>
    There are two primary benefits of using the ipset module.  First, the
    performance for matching a single rule that is using a set to hold a 
    large number of addresses is better than having individual rules for each
    of these addresses. Second, the ipset module and tools provide a way to
    dynamically update the addresses in a list while the firewall is still
    running.
    </para>

    </sect3>

    </sect2>

	
    <sect2 id="special-case-addresses">
      <title>Special-Case addresses</title>

	<para>Policy compilers treat some addresses in policy rules in
	special ways, depending on the requirements of the target
	firewall platform. For example, the compiler for iptables
	checks if the address found in "Destination" or "Source" of a
	rule matches the address of any interface of the firewall to
	determine if the rule should be placed in INPUT or OUTPUT
	chain. The compiler for PIX uses the command ssh
	&lt;address&gt; &lt;netmask>&gt; inside when it detects such
	an address in the destination of a rule where the service is
	TCP Service object "SSH". There are other special cases as
	well.</para>

      <sect3>
	<title>Broadcast and Multicast Addresses, iptables Firewall</title>

	<para>Two important special cases are broadcast and multicast
	addresses. It is important to place rules in the correct chain
	in generated iptables script, because even though these
	addresses are not equal to those of the firewall's interfaces,
	iptables processes packets with broadcast or multicast
	destination in the INPUT chain. Firewall Builder is aware of
	this and generates the correct iptables commands.</para>

	<para>In order to match broadcast or multicast addresses in
	the rules, we need to create objects to describe them. The
	choice of object type to describe broadcast or multicast
	address depends on whether this is just a single address, a
	range or a block. An address object is good for defining a
	single address, address range is good for sets of consecutive
	addresses and network object is good for describing a
	block. For example, you can use an address object with address
	"255.255.255.255" to describe a broadcast. address range with
	addresses "224.0.0.5 - 224.0.0.6" would work well to describe
	two multicast groups used by OSPF. A network object with
	address "224.0.0.0" and netmask "240.0.0.0" can be used to
	describe a whole multicast address block.</para>

	<para>Here are few examples:</para>

      <figure id="multicast_object_1">
        <title>Multicast Object</title>
            <graphic scale="60" fileref="objects/images/multicast_object_1.png" />
      </figure>

	<para>Object "all multicasts" is part of the Standard Objects
	library that comes with the program. It describes an entire
	address block allocated for multicasts. Consider a simple
	policy rule that permits all multicasts:</para>

      <figure id="multicast_rule_1">
        <title>Multicast Rule</title>
            <graphic scale="70" fileref="objects/images/multicast_rule_1.png" />
      </figure>

	<para>For iptables, this rule translates into the following script:</para>

        <programlisting>
$IPTABLES -A INPUT  -d 224.0.0.0/4  -m state --state NEW  -j ACCEPT 
        </programlisting>        

	 <para>The rule went into the INPUT chain because iptables processes multicast there.</para>

	  <para>Here is another example, this time it involves
	  broadcast addresses. The interface "inside" of the test firewall
	  has address 172.16.22.1 with netmask 255.255.255.0. This
	  defines subnet 172.16.22.0/255.255.255.0 with broadcast
	  address 172.16.22.255. We create an address object with the
	  name "net-172.16.22 broadcast" and address "172.16.22.255"
	  and use it in the destination field of a policy
	  rule. Another rule in the same example will match broadcast
	  address "255.255.255.255"; an address range object that
	  defines this address is present in the standard objects
	  library under the name "broadcast". Here are the
	  rules:</para>

      <figure id="broadcast_rules_1">
        <title>Broadcast Rules</title>
            <graphic scale="70" fileref="objects/images/broadcast_rules_1.png" />
      </figure>

	  <para>These two rules translate into the following script for iptables:</para>
          <programlisting>
# Rule 0 (global)
# 
$IPTABLES -A INPUT  -d 255.255.255.255  -m state --state NEW  -j ACCEPT 
# 
# Rule 1 (global)
# 
$IPTABLES -A INPUT  -d 172.16.22.255  -m state --state NEW  -j ACCEPT 
          </programlisting>

	  <para>Both rules went into INPUT chain as expected.</para>
      </sect3>

      <sect3>
	<title>Broadcast and Multicast Addresses and Bridging iptables Firewall</title>

	<para>Compilers treat broadcast and multicast addresses
	differently if the firewall object is set to be a bridging
	firewall. In this case the checkbox "Bridging firewall" should
	be turned on in the firewall settings dialog and one or more
	interface objects should be marked as "Bridge port":</para>

      <figure id="bridge-broadcast-multicast">
        <title>Broadcast and Multicast Address in a Bridging Firewall</title>
            <graphic scale="50" fileref="objects/images/bridge_interface_dialog_1.png" />
      </figure>

	<para>Now the rule that matches the broadcast destination address will be treated differently:</para>

      <figure id="broadcast_rules_2">
        <title>Broadcast and Multicast Address in a Rule</title>
            <graphic scale="70" fileref="objects/images/broadcast_rules_2.png" />
      </figure>

	<para>This produces the following iptables commands:</para>

        <programlisting>
$IPTABLES -A FORWARD  -d 172.16.22.255  -m state --state NEW  -j ACCEPT 
$IPTABLES -A INPUT  -d 172.16.22.255  -m state --state NEW  -j ACCEPT 
        </programlisting>        

        <para>
          Rules went into both INPUT and FORWARD chains because the
          bridging firewall passes broadcasts through, but at the same
          time accepts them as packets headed for itself. Since the
          rule did not specify which interface it should look at,
          Firewall Builder assumed that the generated rule should
          inspect packets crossing all interfaces, both bridge ports
          and "normal" ones, and therefore placed the rule in both
          INPUT and FORWARD chains.
        </para>

      </sect3>
    </sect2>

    <sect2 id="dns-name-object">
      <title>DNS Name Objects</title>

      <para>A DNS Name object represents a DNS "A" or "AAAA"
      record. The object resolves into IP address at compile or run
      time. The address (IPv4 or IPv6) the object resolves to depends
      the address family or families of the rule set it is used
      in. That is, if the object is used in a rule that is part of
      IPv4 rule set, the compiler will try to resolve the object using
      DNS query for the "A" record, but if the object is used in a
      rule that is part of an IPv6 rule set, the compiler will run a
      "AAAA" query. If the rule set where the object is used is a
      mixed type (IPv4+IPv6), the compiler will resolve the same
      object twice using different queries.</para>

      <para>The <guilabel>DNS Name</guilabel> object dialog looks like this:</para>

      <figure id="dns-name">
        <title>DNS Name Object</title>
            <graphic scale="70" fileref="objects/images/dns_name_2.png" />
      </figure>

<itemizedlist spacing="compact">
          <listitem>
            <para>Name:</para>

            <para>The name of the DNS Name object</para>
          </listitem>

          <listitem>
            <para>DNS Record:</para>

            <para>The DNS record you want to resolve.</para>
          </listitem>

          <listitem>
            <para>Compile Time / Run Time:</para>

            <para>Indicate whether you want to resolve the IP address
            when you create the firewall script (compile time) or when
            you run the script on the firewall (run time).</para>
          </listitem>

          <listitem>
            <para>Comment:</para>

            <para>A free-form text field used for comments</para>
          </listitem>
        </itemizedlist>

	<para> The <guilabel>DNS Record</guilabel> parameter is the
	name of the A or AAAA record we want to resolve. In this
	example, it is the host name of the Firewall Builder project
	web site "www.fwbuilder.org". Note that IPv6 web server for
	the project is accessible as "ipv6.fwbuilder.org" so we are
	going to need second DNS name object for IPv6
	examples. <guilabel>Compile Time</guilabel> and <guilabel>Run
	Time</guilabel> options have the same meaning as those in the
	address table object, that is, a compile-time DNS name object is
	converted to the IP address by the policy compiler, while a run-time DNS name object is not. In the latter case, the compiler
	puts the DNS record name into the generated script or
	configuration file and leaves it up to the firewall to resolve
	it when the script is activated.</para>

	<para>Both compile-time and run-time DNS name objects are supported on all target firewall platforms.</para>

	<para>Let's look at how the simple rule shown in <xref linkend="group-dialog1"/> compiles for iptables and PF, both for compile-time and run-time DNS name objects.</para>

      <figure id="dns-name-3">
        <title>Rule Using DNS Name Object</title>
            <graphic scale="70" fileref="objects/images/dns_name_3.png" />
      </figure>

      <figure id="dns-name-compile-iptables">
        <title>DNS Name Compile Time, iptables Compile Output</title>
            <programlisting>
# Rule 0 (global)
# 
$IPTABLES -A FORWARD  -d 70.85.175.170  -m state --state NEW  -j ACCEPT  
</programlisting>
      </figure>

      <para>In this trivial case, the compiler simply resolved
      "www.fwbuilder.org" to an IP address and used it in the iptables
      command. However, if the policy rule was in a rule set configured
      as an IPv6-only rule set, the rule would not produce any
      iptables command at all because there is no AAAA DNS record with
      name "www.fwbuilder.org". If the rule set was both IPv4+IPv6,
      then the rule would generate iptables command only in the IPv4
      part. The opposite is also true: the DNS name object with record
      "ipv6.fwbuilder.org" will only produce iptables commands when
      used in IPv6 rule set because there is only an AAAA record with
      this name.</para>

      <figure id="dns-name-compile-pf">
        <title>DNS Name Compile Time, PF Compile Output</title>
            <programlisting>
# Rule  0 (global)
# 
pass in   quick inet  from any  to 70.85.175.170 keep state
</programlisting>
      </figure>

      <para>The same is true in the case of PF: the compiler simply
      resolved the name "www.fwbuilder.org" and put the address in the
      generated pf.conf file. Since this name does not resolve into
      any IPv6 address, IPv6 PF policy would not have any line for
      this rule. The DNS record "ipv6.fwbuilder.org" resolves only into an
      IPv6 address, and therefore DNS name object with this record
      would only produce pf.conf configuration for IPv6 and not for
      IPv4.</para>

      <figure id="dns-name-run-iptables">
        <title>DNS Name Run Time, iptables Compile Output</title>
        <programlisting>
# Rule 0 (global)
# 
$IPTABLES -A FORWARD  -d www.fwbuilder.org -m state --state NEW  -j ACCEPT
        </programlisting>
      </figure>


      <para>Here the compiler used the line entered in the DNS record
      parameter literally, leaving it up to iptables on the firewall
      machine to resolve this name into an IP address. Using a run
      time DNS name object in IPv6 policy generates the following
      iptables command:</para>

      <programlisting>
# Rule 0 (global)
# 
$IP6TABLES -A FORWARD  -d ipv6.fwbuilder.org -m state --state NEW  -j ACCEPT 
      </programlisting>

      <para>
        $IP6TABLES is the shell variable defined at the beginning of
        the generated script; the value of this variable is the full
        path to the <command>ip6tables</command> command line
        utility. <command>ip6tables</command> will try to resolve
        given name to an IPv6 address since it processes IPv6 iptables
        policy.
      </para>

      <figure id="dns-name-run-pf">
        <title>DNS Name Run Time, PF Compile Output</title>
        <programlisting>
# Rule  0 (global)
#
pass in   quick inet  from any  to www.fwbuilder.org keep state
pass out  quick inet  from any  to www.fwbuilder.org keep state
	</programlisting>
      </figure>
      
      <para>Run-time DNS name object translates into PF configuration
      lines that also use the name of the DNS record and leave it up
      to PF to actually resolve it to an IP address when the
      configuration is loaded.</para>

    </sect2>

    <sect2 id="group-objects">
      <title>A Group of Addressable Objects</title>

      <figure id="group-dialog1">
        <title>Group of Objects</title>
            <graphic scale="50" fileref="objects/images/group-view1.png" />
      </figure>

      <para>The group of objects holds references to hosts, networks,
      address ranges, firewalls and other groups of addressable
      objects (<xref linkend="group-dialog1"/>). Use the <guimenuitem>New
      Object / New Object Group</guimenuitem> option to create a new
      group. Objects can be added to the group using the following
      methods:</para>

      <para><itemizedlist spacing="compact">
          <listitem>
            <para>Using drag and drop:</para>

            <para>Objects can be dragged from the tree into the group dialog.
            Click, hold down the mouse button, and drag the object to add it to the group.</para>
          </listitem>

          <listitem>
            <para>Using the popup menu:</para>

            <para>You can use copy and paste operations between the tree
            and group dialog. Right-clicking the object in the tree
            opens a pop-up menu. Choose <guimenuitem>Copy</guimenuitem> in this
            menu, then move the mouse to the group dialog and right-click in the
            icon field. This also opens a pop-up menu, where you choose
            <guimenuitem>Paste</guimenuitem>. This inserts a reference to the object in the
            group.</para>
          </listitem>

          <listitem>
            <para>Using the <guimenu>Edit</guimenu> main menu:</para>

            <para>Select the object in the tree, select 
            <guimenu>Edit</guimenu>/<guimenuitem>Copy
            Object</guimenuitem> from the menu bar,  click  the
            group dialog, and then
            select <guimenuitem>Edit</guimenuitem>/<guimenuitem>Paste
            Object</guimenuitem> from the menu bar.</para>
          </listitem>
        </itemizedlist></para>
    </sect2>
   </sect1>
