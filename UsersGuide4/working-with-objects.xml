<?xml version="1.0"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
                 "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

  <chapter id="working-with-objects">
    <title>Working With Objects</title>

      <para>Firewall Builder supports a variety of object types, both
      simple and complex. Simple object types include Address,
      Network, Host, and IP, TCP, UDP and ICMP service objects. More
      complex object types are Firewall, Address Table, DNS Name, and
      User Service.</para>

      <para>There are the following types of objects in Firewall
      Builder:</para>
      <itemizedlist spacing="compact">
              <listitem>
                <para>Addressable objects:
                <xref linkend="addressable-objects" /> describes
                objects that have, either directly or indirectly, an
                address of some kind. This category includes the
                physical objects (firewalls, hosts, interfaces) as
                well as some logical objects (networks, address
                ranges, individual addresses). Addressable objects can
                be grouped together into Object groups.</para>
		</listitem>
	      <listitem>
                <para>Service objects:
                <xref linkend="working-with-services" /> describes
                objects that represent services. They include IP, TCP,
                UDP, and ICMP services, as well as user
                services. Service objects can be grouped together into
                Service groups.</para>
		</listitem>
	      <listitem>
                <para>Time Interval objects: Described in
                <xref linkend="time-interval-objects" />, these
                represent a discreet or recurring period of time. They
                can be used as part of a rule in the firewall. For
                example, you could have a rule that matches on
                weekends, but not during the week.</para>
		</listitem>
	      <listitem>
		<para>Rule set objects: Described in
		<xref linkend="rule-set-objects" />, these represent
		the various rule sets in a firewall. By default, a
		firewall starts with one access policy, one NAT, and
		one routing rule set, but you can add more of
		each. Rule set objects only exist as child objects of
		a firewall.</para></listitem>
	</itemizedlist>

      <para>All objects in Firewall Builder have some characteristics
      in common.</para>
      <para>All objects have a <guilabel>Name</guilabel> field and
      a <guilabel>Comment</guilabel> field. The Name field can contain
      white spaces and can be arbitrarily long (though shorter names
      work better in the GUI). The Comment field can contain any text
      of any length.</para>

   <sect1 id="addressable-objects">
    <title>Addressable Objects</title>
    <para>In this section we examine object types that represent
    addresses or groups of addresses.</para>

    <sect2>
      <title>Common Properties of Addressable Objects</title>
      <para>Objects that contain IP address fields provide validity
      checking for the address when the object is saved. Invalid IP
      addresses produce an error.</para>
    </sect2>

    <sect2 id="firewall-object">
      <title>The Firewall Object</title>
	<para>A firewall object represents a real firewall device in
	your network. This firewall object will have interface and IP
	address objects that mirror the real interfaces and IP
	addresses of the actual device. In addition, the firewall
	object is where you create the access policy rule sets, NAT
	rule sets, and routing rule sets that you assign to your
	firewall device.</para>

	<para>By default, a firewall has one Policy rule set, one NAT
	rule set, and one routing rule set. However, you can create
	more than one rule set of each type for a firewall. On the
	other hand, you don't have to populate all the rule sets. You
	can, for example, create a Policy ruleset and leave the NAT
	and Routing rule sets
	empty. <xref linkend="policies-and-rules" /> explains more
	about policies and rule sets.</para>

	<para>To speed up the creation of a firewall object, Firewall
	Builder has a wizard that walks you through creating the
	object. The wizard has three options for creating a firewall
	object: </para>

            <para><itemizedlist spacing="compact">
              <listitem>
                <para>From a template: Firewall Builder comes with
                several pre-defined templates. You can use these to
                create a firewall that is close to your configuration,
                then modify it to fit your needs. This method is shown
                in <xref linkend="gettingstarted" />.</para>
		</listitem>
              <listitem>
                <para>Manually: You can provide interface IP address,
                subnet mask, gateway, and other parameters
                manually. You can add this information when you create
                the firewall, or you can add it
                later. <xref linkend="creating_firewall_manually" />
                (below) describes this process.</para>
	      </listitem>
              <listitem>
                <para>Via SNMP: Firewall builder uses SNMP queries to
                learn about the network. <xref linkend="firewall-snmp"
                /> describes this process.</para>
	      </listitem>
	    </itemizedlist></para>

      <sect3 id="creating_firewall_manually">
        <title>Creating a Firewall Object Manually</title>

        <para>To start the firewall object creation wizard,
        right-click the <guibutton>Firewalls</guibutton> folder in the
        User tree and select <guimenuitem>New
        Firewall</guimenuitem>.</para>

	<para>The first page of this wizard is displayed.</para>
        <figure float="1" id="creating-firewall1-2">
          <title>First Page of the Wizard</title>
              <graphic scale="60" fileref="creating_firewall1.png" />
        </figure>

        <para>Give the firewall object a name. Usually, this name will
        be the same name as the device, but it doesn't have to be if
        you're assigning interfaces manually. (If you will use SNMP or
        DNS to populate the interfaces, then the name must be the same
        as the device name.) Then specify the firewall software and
        device OS.</para>

	<para>Leave the <guilabel>Use pre-configured template firewall
	objects</guilabel> checkbox unchecked.</para>

	<para>Click <guibutton>Next</guibutton>.</para>

        <figure float="1" id="creating-firewall_manual1">
          <title>Choose Configure Interfaces Manually</title>
              <graphic scale="60" fileref="creating_firewall_manual1.png" />
        </figure>

	<para>Select <guibutton>Configure interfaces
	manually</guibutton> and
	click <guibutton>Next</guibutton>.</para>

        <figure float="1" id="creating-firewall_manual2">
          <title>Adding Interfaces to the new Firewall Object</title>
              <graphic scale="60" fileref="creating_firewall_manual2.png" />
        </figure>

        <para>Use this screen to add firewall interfaces. Populate the
        following fields for an interface, then
        click <guibutton>Add</guibutton> to add the interface. Then,
        populate the fields again for the next interface. If you make
        a mistake, click on the interface in the list, make your
        changes, then click <guibutton>Update</guibutton>.</para>

            <para><itemizedlist spacing="compact">
              <listitem>
                <para><guilabel>Interface type</guilabel>: Indicate
                the type of interface. <xref linkend="host-interface"
                /> explains the interface types in more
                detail. Briefly, though, a <guilabel>Regular
                interface</guilabel> has a static IP addresses,
                a <guilabel>Dynamic address</guilabel> interface has a
                dynamic address provided by something like DHCP,
                an <guilabel>Unnumbered interface</guilabel> never has
                an IP address (a PPPoE connection, for example), and
                a <guilabel>Bridge port</guilabel> is an interface
                that is bridged in the firewall.</para>
		</listitem>
              <listitem>
                <para><guilabel>Name</guilabel>: The name of the
                interface object in Firewall Builder must match
                exactly the name of the interface of the firewall
                machine it represents. This will be something like
                "eth0", "eth1", "en0", "br0", and so on.</para>
	      </listitem>
              <listitem>
                <para><guilabel>Label</guilabel>: On most OS's this
                field is not used and serves the purpose of a
                descriptive label.  The label is mandatory for Cisco
                PIX though, where it must reflect the network
                topology. Firewall Builder GUI uses the label, if it
                is not blank, to label interfaces in the tree. One of
                the suggested uses for this field is to mark
                interfaces to reflect the network topology ('outside',
                'inside') or interface purpose ('web frontend' or
                'backup subnet').</para>
	      </listitem>
              <listitem>
                <para><guilabel>Address</guilabel>: If the interface
                has a static IP address, specify it here. (In Firewall
                Builder version 3.X, this must be an IPv4 address. If
                you need it to be an IPv6 address, create the
                interface without an IP address, then add the IPv6
                address after you have created the firewall
                object.)</para>
	      </listitem>
              <listitem>
                <para><guilabel>Netmask</guilabel>: Use either a
                traditional netmask (255.255.255.0) or slash notation
                (24, without the actual slash) to specify the
                interface netmask.</para>
	      </listitem>
              <listitem>
                <para><guilabel>MAC</guilabel>: If you like, you can
                also specify the interface physical address. The MAC
                address is not necessary, but it can be used to combat
                spoofing. If the feature is turned on and available,
                the firewall will only accept packets from the given
                IP address if the MAC address also matches the one
                specified. <xref linkend="using-mac-address" /> has
                more information.</para>
	      </listitem>
	    </itemizedlist></para>

	<para>Once all the interfaces are configured,
        click <guibutton>Finish</guibutton> to create the new firewall
        object.</para>

        <note>
          <para>You can always add, modify and delete interfaces later
          using controls provided in the main window.</para>
        </note>
      </sect3>

      <sect3 id="firewall-snmp">
        <title>Creating a Firewall Object using SNMP Discovery</title>
	  <para>If your firewall runs an SNMP daemon, you can save
	  yourself some time by using SNMP discovery to automatically
	  create interfaces of the new firewall object.</para>

        <figure float="1" id="new_firewall_snmp1">
          <title>SNMP 'read' community string</title>
              <graphic scale="70" fileref="new_firewall_wizard_4.png" />
        </figure>

	  <para>Start by checking the <guilabel>Use SNMP to discover
	  interfaces of the firewall</guilabel> checkbox on the second
	  page of the wizard and enter your SNMP 'read'
	  community. Then click <guibutton>Discover interfaces using
	  SNMP</guibutton>.</para>

        <figure float="1" id="new_firewall_snmp2">
          <title>Discovering interfaces via SNMP</title>
              <graphic scale="70" fileref="new_firewall_wizard_5.png" />
        </figure>

	  <para>Firewall Builder runs a series of SNMP queries to the
	  firewall to read the list of interfaces and their
	  addresses. Both IPv4 and IPv6 address can be imported. For
	  IPv6 the firewall must support IP-MIB RFC4293. Once the
	  discovery process finishes,
	  click <guibutton>Next</guibutton>.</para>

        <figure float="1" id="new_firewall_snmp3">
          <title>Discovering interfaces via SNMP</title>
              <graphic scale="70" fileref="new_firewall_wizard_6.png" />
        </figure>

	  <para>The next page of the wizard offers an opportunity to
	  review the discovered interfaces and make adjustments if
	  necessary. To change something, highlight an interface, edit
	  its parameters in the dialog, then
	  click <guibutton>Update</guibutton>. Finally, when the
	  process is done click <guibutton>Finish</guibutton>. The
	  program creates the new firewall object in the tree and adds
	  all configured interfaces and their addresses.</para>
      </sect3>

      <sect3>
        <title>Editing a Firewall Object</title>

        <para>The Firewall Object represents the firewall machine and
        is the most complex object in Firewall Builder. It has three
        sets of controls that you can modify, not including the policy
        rule sets. All these controls become available when you
        double-click the firewall object in the tree.</para>

        <figure float="1" id="edit_firewall_base_controls">
          <title>Firewall Controls</title>
              <graphic scale="60" fileref="edit_firewall_base_controls.png" />
        </figure>

	<sect4>
	  <title>Basic Firewall Controls</title>
	  <para>These controls let you specify the basic settings of
	  the firewall, such as the name and firewall platform.</para>
        <para><itemizedlist spacing="compact">
            <listitem>
              <para><guilabel>Name</guilabel>: Specify/change the name
              of the firewall object.</para>
            </listitem>
            <listitem>
              <para><guilabel>Platform</guilabel>: Specify/change the
              firewall software.</para>
            </listitem>
            <listitem>
              <para><guilabel>Version</guilabel>: Specify/change the
              version number of the firewall software. In most cases,
              you can leave this set to <guilabel>any</guilabel>. In
              general, setting the version to "any" means the compiler
              will only support options available in all supported
              versions of the software. If you need a feature that is
              only supported by a particular version, then specify
              that version.</para>
            </listitem>
            <listitem>
              <para><guilabel>Host OS</guilabel>: Specify/change the
              host operating system of the firewall device.</para>
            </listitem>
            <listitem>
              <para><guilabel>Inactive firewall</guilabel>: Check this
              box to make the firewall object inactive. The firewall
              name will change to a regular font (instead of bold) to
              indicate that it is inactive, and the firewall will not
              be available for compiling or installation. Essentially,
              this is a way to "comment out" the firewall object
              without deleting it.</para>
            </listitem>
            <listitem>
              <para><guibutton>Host OS Settings</guibutton>: Opens the
              Advanced Settings dialog for the indicated Host
              OS. Click <guibutton>Help</guibutton> in the dialog for
              assistance with dialog options. See
              <xref linkend="host-os-settings-dialog" /> for a screen
              shot.</para>
            </listitem>
            <listitem>
              <para><guibutton>Firewall Settings</guibutton>: Opens
              the Advanced Settings dialog for the platform/firewall
              software. Click <guibutton>Help</guibutton> in the
              dialog for assistance with dialog options. See
              <xref linkend="firewall-settings-dialog" /> for a screen
              shot..</para>
            </listitem>
	    </itemizedlist></para>
	</sect4>

	<sect4 id="host-os-settings-dialog">
	  <title>Host OS Settings Dialog</title>

        <para>For explanations of the various controls, click
        the <guilabel>Help</guilabel> button in the dialog.</para>

        <figure float="1" id="edit_firewall_howtos_options">
          <title>Firewall Host OS Settings dialog (Linux)</title>
              <graphic scale="70" fileref="edit_firewall_howtos_options.png" />
        </figure>

	</sect4>
	<sect4 id="firewall-settings-dialog">
	  <title>Firewall Settings dialog</title>

	<para>For explanations of the various controls, click
	the <guilabel>Help</guilabel> button in the dialog.</para>

        <figure float="1" id="edit_firewall_firewallsettings_compiler">
          <title>Firewall Settings dialog (iptables)</title>
              <graphic scale="60" fileref="edit_firewall_firewallsettings_compiler.png" />
        </figure>

	</sect4>

	<sect4 id="rule-set-objects">
	  <title>Editing Rule Set Objects</title>

	    <para>Firewalls can have one or more of the of the
	    following types of rule sets: access policy, NAT, and
	    Routing. A firewall has, by default, one access policy
	    rule set, one NAT rule set, and one routing rule
	    set. However, you can add additional rule sets if you
	    like.</para>

	    <para>Rule sets are child objects of the a firewall
	    object. They cannot stand alone.</para>

	    <para>As objects, rule sets have parameters. In Firewall
	    Builder, rule sets have the following parameters:</para>

      <itemizedlist>
	<listitem><para><guilabel>Name</guilabel>: The name of the
	rule set. If you only have one of each type of rule set, you
	can leave this at its default.
	</para></listitem>
	<listitem><para><guilabel>Rule Set family</guilabel>: This
	pull-down menu lets you specify whether policy compiler should
	treat the rule set as an IPv4 rule set, an IPv6 rule set, or a
	combined rule set. If set to IPv4, then only IPv4 rules will
	be processed and IPv6 rules will be ignored. The opposite is
	true if you specify an IPv6 rule set. If you
	select <guimenuitem>This is combined IPv4 and IPv6 rule
	set</guimenuitem>, then the compiler will process both types
	of rules and place them into the appropriate places in the
	install script.
	</para></listitem>
	<listitem><para><guilabel>filter+mangle table</guilabel>
	or <guilabel>mangle table</guilabel>: These radio buttons let
	you specify whether the rules will apply to the iptables
	filter table <emphasis>and</emphasis> mangle table, or just
	the mangle table. (These radio buttons only appear for access
	policy rule sets, and only for iptables.) Under most
	circumstances, the compiler places each rule into the correct
	table (filter or mangle) automatically. However some
	combinations of service objects and actions are ambiguous and
	can be used in both filter and mangle tables. In cases like
	these, you can clarify things for the compiler by creating a
	separate Policy ruleset that will be translated only into the
	mangle table.
	</para></listitem>
	<listitem><para><guilabel>Top ruleset</guilabel>: One of your
	rule sets must be the "top" rule set. The top ruleset is the
	one used by the firewall. Other rule sets of that type are
	used only if you branch to them using branching logic in the
	top rule set. (If you don't use branching, then only the rule
	set tagged as "top" is used.)
	</para></listitem>
	<listitem><para><guilabel>Comment</guilabel>: A free-form
	comment field.
	</para></listitem>
      </itemizedlist>

	    <figure float="1" id="rule-set-options1">
	      <title>Rule set options</title>
              <graphic scale="70" fileref="rule-set-options1.png" />
	    </figure>
	</sect4>
      </sect3>
    </sect2>

    <sect2 id="host-interface">
      <title>Interface Object</title>

      <figure float="1" id="host-interface1">
        <title>Interface Object</title>
            <graphic scale="70" fileref="host_example_1.png" />
      </figure>

      <para>Interface objects belong to firewall or host
      objects. Interface objects cannot exist alone.</para>

      <para>The dialog for the interface object that belongs to the
      firewall or host provides controls for the parameters described
      here. Controls that are only valid for the firewall, and not
      host objects, are marked as such.</para>

      <figure float="1" id="interface1">
        <title>Interface Object</title>
            <graphic scale="70" fileref="interface-1.png" />
      </figure>

      <itemizedlist>
	<listitem><para><guilabel>Name</guilabel>: The name of the
	interface object in Firewall Builder must match exactly the
	name of the interface of the firewall machine it
	represents. This will be something like "eth0", "eth1", "en0",
	"br0", and so on.
	</para></listitem>
	<listitem><para><guilabel>Label</guilabel>: On most OS's this
	field is not used and serves the purpose of a descriptive
	label. Firewall Builder GUI uses a label, if it is not blank,
	to show interfaces in the tree. One of the suggested uses for
	this field is to mark interfaces to reflect the network
	topology ('outside', 'inside') or the purpose ('web frontend'
	or 'backup subnet'). The label is mandatory for Cisco PIX
	though, where it must reflect the network topology.
	</para></listitem>
	<listitem><para><guilabel>Management interface</guilabel>:
	When a firewall has several network interfaces, one of them
	can be marked as the "management interface". The management
	interface is used for all communication between Firewall
	Builder and the firewall. For example, the built-in policy
	installer uses the address of the management interface to
	connect to the firewall via SSH when it copies a generated
	script or configuration file. (firewall object only)
	</para></listitem>
	<listitem><para><guilabel>External interface
	(insecure)</guilabel>: Marks an interface that connects to the
	Internet, or to an area that is outside the network protected
	by the firewall.  (firewall object only)
	</para></listitem>
	<listitem><para><guilabel>Unprotected interface</guilabel>:
	Marks interface to which Firewall Builder should not assign
	any access lists or firewall rules. Unprotected interfaces are
	recognized by policy compilers for Cisco IOS access lists and
	PF. Compiler for IOS ACL just skips unprotected interfaces and
	does not assign any ACL. The compiler for PF generates a "set
	skip on" clause for unprotected interfaces.  (firewall object
	only)
	</para></listitem>
	<listitem><para><guilabel>Regular Interface</guilabel>: Use
	this option if the interface has an IP address assigned to it
	manually (static IP address).
	</para></listitem>
	<listitem><para><guilabel>Address is assigned
	dynamically</guilabel>: Use this option if the interface has a
	dynamic address (obtained by means of DHCP or PPP or another
	protocol). In this case an address is unknown at the moment
	when Firewall Builder generates the Firewall policy. Some
	firewalls allow for using the interface name in the policy
	instead of its IP address; the firewall engine then picks an
	address either when the policy is activated or even at
	run-time. Some other firewalls support special syntax for
	rules that are supposed to match packets headed to or from the
	firewall machine. Examples of these two cases are OpenBSD PF
	and Netfilter. PF rules can be constructed using interface
	names; PF automatically uses the current interface address
	when it loads rules into the memory. Netfilter supports
	special "chains" called "INPUT" and "OUPUT" that are
	guaranteed to inspect only packets headed for the firewall
	machine ("INPUT") or originated on it ("OUTPUT"). Both methods
	allow Firewall Builder to build correct firewall policy rules
	that affect the interface with a dynamic IP address, however
	the interface must be marked as such for the policy compiler
	to use proper technique depending on the target firewall
	platform. In cases where the rule has to use actual IP address
	of the interface (example: anti-spoofing rules), compiler
	emulates this feature by adding shell script fragment to
	determine the address at the time when firewall script is
	executed and then uses the address in rules. Such emulation is
	only possible on platforms where firewall configuration is in
	the form of the shell script, most notably this is iptables
	script on Linux.
	</para></listitem>
	<listitem><para><guilabel>Unnumbered interface</guilabel>: Use
	this option if the interface can never have an IP address,
	such as the Ethernet interface used to run PPPoE communication
	on some ADSL connections or a tunnel endpoint
	interface. Although an unnumbered interface does not have an
	address, firewall policy rules or access lists can be
	associated with it.
	</para></listitem>
	<listitem><para><guilabel>Bridge port</guilabel>: This option
	is used for a port of a bridged firewall. The compilers skip
	bridge ports when they pick interfaces to attach policy and
	NAT rules to. For target firewall platforms that support
	bridging and require special configuration parameters to match
	bridged packets, compilers use this attribute to generate a
	proper configuration. For example, in case of iptables, the
	compiler uses <emphasis>-m physdev --physdev-in</emphasis>
	or <emphasis>-m physdev --physdev-out</emphasis> for bridge
	port interfaces. (firewall object only)
	</para></listitem>
	<listitem><para><guilabel>Security level</guilabel>: Depending
	on the firewall platform, the security level is
	either <emphasis>External/Internal</emphasis> or a numeric
	value between 0 and 100, with 0 being least secure and 100
	being most secure. This field in the GUI dialog automatically
	shows controls appropriate to the current firewall. Not all
	firewall support the concept of a security zone. (firewall
	object only)
	</para></listitem>
	<listitem><para><guilabel>Network zone</guilabel>: Used only
        with Cisco PIX (ASA). The Network zone drop-down list shows
        all network objects and groups of addresses and networks
        present in the tree. Choose one of them to tell the compiler
        which networks and blocks of addresses can be reached through
        this interface. Usually the external interface (the one that
        connects your firewall to the Internet) has the Network Zone
        set to <emphasis>Any</emphasis>. It is also recommended that
        you create a group of objects to represent Network Zones for
        all other interfaces on the firewall. The compiler uses this
        information to decide which interface each ACL rule should be
        associated with based on the addresses used in the destination
        of the rule. (firewall object only)
	</para></listitem> 
      </itemizedlist>

    <sect3 id="security-levels-and-network-zones">
      <title>More about Security Levels and Network Zones</title>

	<para>Consider the network layout as in
        <xref linkend="network-zones" />. </para>

        <figure float="1" id="network-zones">
          <title>Choosing Network Zones</title>
              <graphic scale="100" fileref="fwbuilder-using-netzone1.jpg" />
        </figure>

	<para>Here the firewall has three interfaces: 'outside',
        'dmz', and 'inside'. Behind the firewall there is a router
        which in turn is connected to three subnets: 'subnet A',
        'subnet B', and 'subnet C'. Subnet A is shared between the
        router and the firewall (each device has an interface on this
        subnet). Let's suppose we have created Network objects for
        each subnet and called them 'subnet DMZ', 'subnet A', 'subnet
        B' and 'subnet C' (remember, spaces are allowed in object
        names). For this setup, network zones should be configured as
        follows:</para>

        <para><informaltable frame="none">
            <tgroup cols="2">
              <colspec align="center" colwidth="64pt" />

              <colspec align="center" colwidth="150pt" />

              <thead>
                <row>
                  <entry>Interface</entry>

                  <entry>Network Zone</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><guilabel>outside</guilabel></entry>

                  <entry><emphasis>ANY</emphasis></entry>
                </row>

                <row>
                  <entry><guilabel>dmz</guilabel></entry>

                  <entry><emphasis>subnet DMZ</emphasis></entry>
                </row>

                <row>
                  <entry><guilabel>inside</guilabel></entry>

                  <entry><emphasis>subnet A,</emphasis> <emphasis>subnet
                  B,</emphasis> <emphasis>subnet C</emphasis></entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable></para>

        <para>Since the network zone for
        the <emphasis>'inside'</emphasis> interface consists of
        multiple objects, you must create a group so that you can use
        this group as a Network Zone object.</para>

        <para><xref linkend="platform-specific-interface-parameters"
        /> explains the differences in the way firewall platforms
        interpret values in the Security Level and Network Zone
        parameters of the firewall interfaces.</para>

        <table id="platform-specific-interface-parameters" pgwide="0" tabstyle='reg_table'>
          <title>Platform-specific interface parameters</title>

          <tgroup cols="3">
            <thead>
              <row>
                <entry><para>Firewall Platform</para></entry>

                <entry><para>Security Level Values</para></entry>

                <entry><para>Network Zone</para></entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><para>iptables</para></entry>

                <entry><para>two values: 'External' or
                'Internal'</para></entry>

                <entry><para>N/A</para></entry>
              </row>

              <row>
                <entry><para>ipfilter</para></entry>

                <entry><para>two values: 'External' or
                'Internal'</para></entry>

                <entry><para>N/A</para></entry>
              </row>

              <row>
                <entry><para>pf</para></entry>

                <entry><para>two values: 'External' or
                'Internal'</para></entry>

                <entry><para>N/A</para></entry>
              </row>

              <row>
                <entry><para>Cisco PIX</para></entry>

                <entry><para>numeric, 0 - 100</para></entry>

                <entry><para>a reference to a group or network
                object</para></entry>
              </row>
            </tbody>
          </tgroup>
        </table>

	<para>Note that the "external" interface option may be
	deprecated in the future versions of the program.</para>

	<para>In PIX, access lists must always be attached to
	interfaces. The policy compiler for PIX uses information about
	the network zones of interfaces to decide which interface a
	rule should be associated with if its "Interface" column does
	not specify one (is left set to "All"). Instead of placing
	this rule in access lists attached to all interfaces, it
	compares addresses in the Source and Destination of the rule
	with network zones of interfaces and only uses interfaces that
	match. This helps generate a PIX configuration that is more
	compact.</para>
    </sect3>
    
    <sect3>
      <title>Using Interface Object in Rules</title>

      <para>Policy rules in Firewall Builder have a rule element
      called <guilabel>Interface</guilabel>. You can drag-and-drop, or
      copy/paste interface object into this column of a rule to make
      the firewall match not only the source and destination address
      and service, but also the interface of the firewall through
      which packets enter or exit. The direction of the packet is
      defined in column <guilabel>Direction</guilabel>. Consider the
      following example:</para>

      <figure float="1" id="rules_with_interface_1">
        <title>Rule using an Interface object</title>
            <graphic scale="70" fileref="rules_with_interface_1.png" />
      </figure>

      <para>Rule #0 is "anti-spoofing" rule which relies on the
      ability to define interface and direction. It matches packets
      with source addresses equal to the addresses of the firewall's
      interfaces or internal network, but that are coming in from
      outside, which is determined by comparing the interface through
      which packets enter the firewall. Packets with "internal"
      addresses cannot normally come from outside, and if they do,
      they must be spoofed and should be dropped. This is what this
      rule does: it drops and logs these packets. Rule #1 permits
      connections originating from the internal network going out, but
      it makes sure these packets enter the firewall through its
      internal interface.</para>

      <para>These two rules generate the following iptables
      script:</para>
      <screen>
# 
# Rule 0 (eth0)
# 
$IPTABLES -N In_RULE_0
$IPTABLES -A FORWARD  -i eth0  -s 192.0.2.1  -j In_RULE_0 
$IPTABLES -A FORWARD  -i eth0  -s 172.16.22.1  -j In_RULE_0 
$IPTABLES -A FORWARD  -i eth0  -s 192.168.2.1  -j In_RULE_0 
$IPTABLES -A FORWARD  -i eth0  -s 172.16.22.0/24  -j In_RULE_0 
$IPTABLES -A In_RULE_0  -j LOG  --log-level info --log-prefix "RULE 0 -- DENY "
$IPTABLES -A In_RULE_0  -j DROP 
# 
# Rule 1 (eth1)
# 
$IPTABLES -A FORWARD  -i eth1  -s 172.16.22.0/24  -m state --state NEW  -j ACCEPT 
      </screen>

    <para> Here all iptables commands have an "-i eth0" or "-i eth1"
    clause, which makes iptables compare the interface and
    direction.</para>

     <para>Here is what we get if we compile the same rules for
     PF:</para>

      <screen>
# Tables: (1)
table &lt;tbl.r9999.d&gt; { 192.0.2.1 , 172.16.22.1 , 192.168.2.1 } 

# 
# Rule  0 (eth0)
# 
block in   log  quick on en0 inet  from &lt;tbl.r9999.d&gt;  to any
block in   log  quick on en0 inet  from 172.16.22.0/24  to any
# 
# Rule  1 (eth1)
# 
pass in   quick on en1 inet  from 172.16.22.0/24  to any keep state
# 
      </screen>

      <para> For PF, the compiler generated a "block in log quick on
      eth0" clause to make the rule match interface and
      direction.</para>

      <para>In the case of Cisco IOS access lists, defining an
      interface in the rule makes the compiler place code generated
      for this rule into the ACL attached to the given interface. The
      compiler for IOS ACL always generates both inbound and outbound
      access lists for each interface, but if the rule specifies both
      interface and direction ("Inbound" or "Outbound"), the generated
      configuration goes only into the corresponding access list. Here
      is the output produced for the rules shown above for Cisco IOS
      ACL:</para>

      <screen>
ip access-list extended inside_in
! Rule  1 (eth1)
! 
  permit ip 172.16.22.0 0.0.0.255 any  
exit

ip access-list extended outside_in
! Rule  0 (eth0)
! 
  deny   ip host 192.0.2.1 any  log 
  deny   ip host 192.168.2.1 any  log 
  deny   ip 172.16.22.0 0.0.0.255 any  log 
exit

interface FastEthernet1
  ip access-group inside_in in
exit
interface FastEthernet0
  ip access-group outside_in in
exit
      </screen>

      <para>So far, the examples in this section have demonstrated how
      to use Interface objects to associate policy rules with
      interfaces so as to match packets crossing certain interface. An
      interface object can be used in the "source" and "destination"
      of rules just like any other addressable object. In this case,
      Firewall Builder replaces the interface object with the set of
      its addresses, picking only those addresses that match the
      address family (IPv4 or IPv6 or both) assigned to the rule
      set.</para>

      <para>For example, we start with a firewall configuration where
      interface eth1 has two IP addresses, one IPv4 and another is
      IPv6. Note that this could be a host object as well because
      interfaces can belong either to a Firewall or a Host
      object.</para>

      <figure float="1" id="interface-2">
        <title>Interface object with both address families</title>
            <graphic scale="70" fileref="interface-2.png" />
      </figure>

      <para>Interface eth1 has IPv4 address 172.16.22.1 and IPv6
      address fe80::21d:9ff:fe8b:8e94. It is used in a simple policy
      rule as follows:</para>

      <figure float="1" id="interface-rule-1">
        <title>Interface object in a rule</title>
            <graphic scale="70" fileref="interface-rule-1.png" />
      </figure>

      <para>This policy rule set is configured as a mixed IPv4+IPv6
      rule set. For iptables, the compiler generates the following
      code:</para>

      <screen>
# ================ IPv4
# Rule 0 (global)
# 
$IPTABLES -A INPUT -p tcp -m tcp  -d 172.16.22.1  --dport 22  -m state \
 --state NEW  -j ACCEPT 

# ================ IPv6

# Rule 1 (global)
# 
$IP6TABLES -A INPUT -p tcp -m tcp  -d fe80::21d:9ff:fe8b:8e94  --dport 22 \
 -m state --state NEW  -j ACCEPT
      </screen>

      <para>For PF we get the following:</para>

      <screen>
# Rule  0 (global)
# 
# 
pass in   quick inet proto tcp  from any  to 172.16.22.1 port 22 keep state
pass out  quick inet proto tcp  from any  to 172.16.22.1 port 22 keep state

# Rule  0 (global)
# 
# 
pass in   quick inet6 proto tcp  from any  to fe80::21d:9ff:fe8b:8e94 port 22 \
keep state
pass out  quick inet6 proto tcp  from any  to fe80::21d:9ff:fe8b:8e94 port 22 \
keep state
      </screen>

      <para>Since the interface has two addresses, one IPv4 and
      another IPv6, the compiler generates commands in both the IPv4
      and IPv6 sections of the script, but it uses only the
      appropriate address in each. Other than that, the interface
      object behaves just like a set of addresses when used in the
      source or destination element of a rule. It can also be used in
      NAT rules. Here is an example:</para>

      <figure float="1" id="interface-nat-rule-1">
        <title>IPv4 Address object assigned to an interface</title>
            <graphic scale="70" fileref="interface-nat-rule-1.png" />
      </figure>
    
      <para>This generates the following code for iptables:</para>

      <screen>
# Rule 0 (NAT)
# 
$IPTABLES -t nat -A POSTROUTING -o eth0  -s 172.16.22.0/24 -j SNAT \
--to-source 192.0.2.1 
# 
# Rule 1 (NAT)
# 
$IPTABLES -t nat -A PREROUTING  -p tcp -m tcp   -d 192.0.2.1 --dport 80 \
-j DNAT --to-destination 172.16.22.100 
       </screen>

		<para>And for PF:</para>
	<screen>
# Rule  0 (NAT)
# 
nat on eth0 proto {tcp udp icmp} from 172.16.22.0/24 to any -> 192.0.2.1 
# 
# Rule  1 (NAT)
# 
rdr on eth0 proto tcp from any to 192.0.2.1 port 80 -> 172.16.22.100 port 80 
        </screen>
    </sect3>

    <sect3>
      <title>Using Interface Object with Dynamic Address in Rules</title>

      <para>The examples above demonstrated what happens when an
      interface with one or several IP addresses is used in policy and
      NAT rules. Let's look at the case when an interface has an
      address assigned dynamically. This means the address is unknown
      to the Firewall Builder policy compiler when it generates the
      configuration script. The compiler uses features of the target
      firewall to work around this. Here is the configuration of the
      interface object eth0. The radio-button <guilabel>Address is
      assigned dynamically</guilabel> is selected.</para>

      <figure float="1" id="interface-3">
        <title>Interface with dynamic address</title>
            <graphic scale="60" fileref="interface-3.png" />
      </figure>

	<para>The following policy rule uses interface eth0  in destination:</para>

      <figure float="1" id="interface-rule-3">
        <title>Interface with dynamic address in a rule</title>
            <graphic scale="70" fileref="interface-rule-3.png" />
      </figure>

      <para> Here is what we get for iptables:</para>

      <screen>
getaddr eth0  i_eth0
getaddr6 eth0  i_eth0_v6

# ================ IPv4

# Rule 0 (global)
# 
test -n "$i_eth0" &amp;&amp; $IPTABLES -A INPUT -p tcp -m tcp  -d $i_eth0  --dport 22 \
  -m state --state NEW  -j ACCEPT 

# ================ IPv6

# Rule 0 (global)
# 
test -n "$i_eth0_v6" &amp;&amp; $IP6TABLES -A INPUT -p tcp -m tcp -d $i_eth0_v6  \
 --dport 22  -m state --state NEW  -j ACCEPT 
        </screen>

	<para>Shell functions "getaddr" and "getaddr6" are defined
	earlier in the script. The generated script determines IPv4
	and IPv6 addresses of interface eth0 at the time of execution
	and then uses the values in iptables commands. If the
	interface does not have an address, the corresponding variable
	gets an empty string for its value and the iptables command
	using it is skipped.</para>

	<para>PF allows for using interface name in rules and gets its
	current IP address automatically. Here is what is generated
	for PF:</para>

	<screen>
# Rule  0 (global)
# 
pass in   quick inet proto tcp  from any  to (en0) port 22 keep state
pass out  quick inet proto tcp  from any  to (en0) port 22 keep state

# Rule  0 (global)
# 
pass in   quick inet6 proto tcp  from any  to (en0) port 22 keep state 
pass out  quick inet6 proto tcp  from any  to (en0) port 22 keep state
         </screen>    

	<para>We still get two separate parts for IPv4 and IPv6
	because the rule set is configured as IPv4+IPv6 mix, but in
	both cases compiler just used the interface name because its
	actual IP address is dynamic and was unknown at the time the
	configuration was generated.</para>

    </sect3>
    
    <sect3>
      <title>Using Interface Object in Rules of Bridging iptables Firewall</title>

      <para>In case of the "normal" iptables firewall, Firewall
      Builder adds an "-i eth0" or "-o eth0" parameter to the
      generated iptables command to make it match interface and
      direction. If radio button <guilabel>"Bridge port"</guilabel> is
      turned on in the interface object, the compiler uses a different
      option to make iptables match packets crossing bridge
      ports. Here is the interface "eth1" which is configured as a
      bridge port:</para>

      <figure float="1" id="bridge_interface_dialog_1">
        <title>Bridge interface</title>
            <graphic scale="60" fileref="bridge_interface_dialog_1.png" />
      </figure>

      <para>Consider the following rule in the policy of the firewall
      this interface belongs to:</para>

      <figure float="1" id="rules_with_interface_2">
        <title>Bridge interface in rule</title>
            <graphic scale="70" fileref="rules_with_interface_2.png" />
      </figure>

      <para> This rule matches interface "eth1" and generates the
      following iptables command:</para>

      <screen>
$IPTABLES -A FORWARD  -m physdev --physdev-in eth1  -s 172.16.22.0/24 \
 -d 172.16.22.255  -m state --state NEW  -j ACCEPT 
      </screen>

      <para>Since the interface is now a bridge port, the compiler
      uses "-m physdev --physdev-in eth1" to match it.</para>

    </sect3>
  </sect2>

    <sect2 id="address-object">
      <title>IPv4 Address Object</title>

      <para>The regular address object describes single a IPv4
      address. It can be a child of an interface object, in which case
      it represents an IP address and netmask of the interface, or it
      can be used as a standalone object. In the latter case it does
      not have a netmask and is located in the Objects/Addresses
      branch of the objects tree.</para>

      <sect3>
	<title>IPv4 Address Object When Used as an Address of an Interface</title>

	  <para>In this case the object is a "child" or "leaf" under
	  the an interface object, either on a Host or a Firewall
	  object. To create this kind of an Address, right-click on
	  the interface object to bring up the context menu.</para>

      <figure float="1" id="ipv4-address1">
        <title>IPv4 Address object assigned to an interface</title>
            <graphic scale="50" fileref="ipv4_1.png" />
      </figure>
      <para>Its dialog provides the following entry fields:</para>

      <para><itemizedlist spacing="compact">
          <listitem>
            <para>Name</para>

            <para>This is the name of the object. Use a descriptive
            name because when the address object is used in the
            firewall policy, it is labeled with this name. It may be
            hard to tell one address from another if their names are
            similar.</para>
          </listitem>

          <listitem>
            <para>Address</para>

            <para>This is an IP address. The GUI widget provides
            syntax control for the values entered in the field. (This
            syntax control activates when you save the object.)</para>

            <note>
              <para>A typical error is to interpret this object as an address
              of the subnet to which the interface of the host or firewall
              belongs. This object represents an address of the interface, not
              a network address. (So, 192.168.1.1, not 192.168.1.0)</para>
            </note>
          </listitem>

          <listitem>
            <para>Netmask</para>

            <para>This is a netmask assigned to the interface. You can
            enter the netmask using the traditional method
            (255.255.255.0) or using network bit length notation
            ("24"). Bit length notation is converted to a traditional
            netmask by Firewall Builder.</para>
          </listitem>

          <listitem>
            <para>DNS Lookup</para>

            <para>If the host object has the same name as the actual
            machine, then clicking this button generates a DNS query
            that populates the interface IP address and subnet. Only
            the parent host or firewall object's name is used for the
            DNS query; the name of the interface is ignored and can be
            anything.</para>
          </listitem>

          <listitem>
            <para>Comment</para>

            <para>This is free-form text field for a comment.</para>
          </listitem>
        </itemizedlist></para>

	<para>Here we use our IPv4 address in a rule (remember, it belongs to the interface):</para>

      <figure float="1" id="ipv4-address2">
        <title>IPv4 Address object assigned to an interface and used in a rule</title>
            <graphic scale="70" fileref="ipv4_1_rule_1.png" />
      </figure>

	<para>Firewall Builder's iptables compiler, for example,
	generates the following command from this rule:</para>

	<screen>$IPTABLES -A INPUT -p tcp -m tcp  -d 172.16.22.1  --dport 22  -m state \
	--state NEW  -j ACCEPT</screen>

	<para>Note how even though the Address object has a netmask,
	the generated command matches the address as a host address,
	not as a subnet. This is because the netmask is used only to
	describe the subnet for the interface, not to describe the
	subnet. When this address object is used in a rule, it is
	understood that the intention is to match the address of the
	interface it belongs to rather than any address on the
	subnet. Use the Network object if you need to match a whole
	subnet.</para>

	<para>This iptables rule was placed in the INPUT chain because
	the object in the "Destination" was an address of an interface
	of the firewall. While processing the policy for the iptables
	target firewall platform, Firewall Builder compares addresses
	in the source and destination of a rule to the addresses of
	all interfaces of the firewall to find rules that control
	access to and from the firewall. Firewall Builder places these
	rules into INPUT or OUTPUT chains. This is only necessary for
	iptables.</para>

      </sect3>
      <sect3>
	<title>IPv4 Address Object When Used as a Stand-alone Object</title>

	  <para>In this case the object is located in
	  the <guimenuitem>Objects / Addresses</guimenuitem> part of
	  the objects tree and does not have a netmask entry field. To
	  create this kind of an Address, use the <guimenu>New
	  Object</guimenu> menu to select <guimenuitem>New
	  Address</guimenuitem> or use the right-click menu associated
	  with the Addresses folder in the tree.</para>

      <figure float="1" id="ipv4-address3">
        <title>Stand-alone IPv4 Address object</title>
            <graphic scale="50" fileref="ipv4_2.png" />
      </figure>

	<para>Dialog
	fields <guilabel>Name</guilabel>, <guilabel>Address</guilabel>
	and <guilabel>Comment</guilabel> have the same purpose and
	properties as an Address object assigned to an Interface
	object.</para>

	<para>The DNS Lookup button can be used to automatically
	populate the address field using a DNS query. The program runs
	DNS query for the "A" record with the name of the Address
	object. The object name does not have to match any DNS record
	if you never plan to use this feature. DNS query function is
	just a convenience, but to use it, the name of the object must
	match a DNS record.</para>

      </sect3>
    </sect2>

    <sect2 id="ipv6-address-object">
      <title>IPv6 Address Object</title>

	<para>The IPv6 address object is similar to the IPv4 address
	object. Like IPv4 address objects, it can be used both as a
	child of an interface object or as a stand-alone
	object.</para>

      <sect3>
	<title>IPv6 Address Object When Used as an Address of an Interface</title>

      <figure float="1" id="ipv6-address1">
        <title>IPv6 Address Object assigned to an Interface object</title>
            <graphic scale="60" fileref="ipv6_1.png" />
      </figure>

      <para>If it is used to describe an IPv6 address of an interface,
      it has a netmask represented as bit length. Unlike with IPv4
      address object, an IPv6 netmask is never represented as a
      colon-separated string of octets.</para>
      </sect3>

      <sect3>
	<title>IPv6 Address Object When Used as Stand-alone Object</title>

      <figure float="1" id="ipv6-address2">
        <title>Stand-alone IPv6 Address Object</title>
            <graphic scale="60" fileref="ipv6_2.png" />
      </figure>

      <para>In this case this object is located in
      the <guimenuitem>Objects / Addresses</guimenuitem> part of the
      objects tree (the same place where stand-alone IPv4 addresses
      are located) and does not have a netmask entry field. To create
      this kind of an Address, use the <guimenu>New Object</guimenu>
      menu item <guimenuitem>New Address IPv6</guimenuitem> or the
      right-click menu associated with the Addresses folder in the
      tree.</para>

      <para>Policy compilers treat IPv6 addresses in policy rules
      according to the same algorithms as those for IPv4 rules. For
      example, just like with IPv4, the compiler for iptables checks
      if an address matches an address of any interface of the
      firewall to determine if the rule should be placed in the INPUT
      or OUTPUT chain.</para>

      <para>Consider the rule shown in the screenshot below where we
      use two IPv6 address objects. One object belongs to the
      interface inside of the firewall while another is the IPv6
      address of the project's web site.</para>

      <figure float="1" id="ipv6-address3">
        <title>IPv6 Address objects in a rule</title>
            <graphic scale="70" fileref="ipv6_1_rule_1.png" />
      </figure>

      <para>For iptables, Firewall Builder generates the following commands from this rule:</para>

      <screen>
$IP6TABLES -A INPUT -p tcp -m tcp  -d fe80::21d:9ff:fe8b:8e94  --dport 80  \
-m state --state NEW  -j ACCEPT 
$IP6TABLES -A FORWARD -p tcp -m tcp  -d 2001:470:1f0e:162::2  --dport 80  \
-m state --state NEW  -j ACCEPT
      </screen>

      <para>The rule that matches the address described
      by <emphasis>object guardian-2:eth1:ipv6</emphasis> went to the
      INPUT chain because compiler detected that this rule matches
      packets that are headed for the firewall itself, which iptables
      inspects in the INPUT chain. The rule that matches the address
      described by the object <emphasis>ipv6.fwbuilder.org</emphasis>
      went to the FORWARD chain because these packets go through the
      firewall.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Physical Address Object</title>

      <figure float="1" id="physAddress1">
        <title>The Physical Address Object</title>

            <graphic scale="60" fileref="physaddress1.png" />

      </figure>

      <para>The Physical Address object describes the hardware, or
      media, address of an interface. Currently only Ethernet MAC
      addresses are supported, but support for other kinds of physical
      addresses may be added in the future.</para>

      <para>The Physical Address object can only be a child of an
      interface; it cannot exist as a stand-alone object. To create
      this kind of address object, right-click on an Interface object
      in the tree, then select <guimenuitem>Add MAC
      Address</guimenuitem>. Only one Physical Address object is
      allowed per interface; the program enforces this restriction. If
      you create a Firewall or Host object using SNMP discovery, all
      interfaces will be automatically populated with their MAC
      addresses.</para>

      <para><itemizedlist spacing="compact">
          <listitem>
            <para>Name</para>

            <para>This is the name of the object. The field is
            populated automatically with a host:interface:addressType
            descriptive name when the object is created, but you can
            change it immediately or later. If you change the name,
            use something descriptive because when the address object
            is used in the firewall policy, it is labeled with this
            name. It may be hard to tell one address from another if
            their names are similar. </para>
          </listitem>

          <listitem>
            <para>Address</para>

            <para>This is a string representation of the physical or media
            address. For many types of media, this will be in a binary
            representation. For example, an Ethernet address would be
            represented as a string of 6 octets.</para>
          </listitem>

          <listitem>
            <para>Comment</para>

            <para>This is free-form text field for a comment.</para>
          </listitem>
        </itemizedlist></para>

      <sect3 id="using-mac-address">
        <title>Using The Physical Address Object in Policy Rules</title>

        <para>Only a few firewall platforms really support physical
        address filtering. Currently, Netfilter/iptables is the only
        firewall platform supported by Firewall Builder that can do
        physical address filtering.</para>

        <para>As described in <xref linkend="multiple-addresses" />,
        if an Interface object that has multiple child address objects
        is used in a rule element (either
        <emphasis>Source</emphasis> or <emphasis>Destination</emphasis>), then
        the policy compiler tries to generate a rule using all of them. <xref
        linkend="multiple-addresses" /> explains that the compiler actually does
        this by generating multiple rules using each address in turn. This
        roughly corresponds to using the logical operation "OR" on the IP
        addresses: if our interface has two addresses,
        <emphasis>Address1</emphasis> and <emphasis>Address2</emphasis>, then
        the generated rule would match if the address in the packet is either
        <emphasis>Address1</emphasis>
        OR <emphasis>Address2</emphasis>. The case of a Physical
        Address is different though. If the Interface has a physical
        address, then the compiler builds a rule that has to match an
        IP address <emphasis>and</emphasis> the MAC address. The
        reason is to combat IP spoofing.</para>

        <para>Suppose we have a very important host on the network. We
        create a Host object, then add an interface to it. The
        interface should have both Address and Physical Address
        objects as shown in
        <xref linkend="host-with-addr-and-physaddr" />. The two child
        objects are visible in the tree under the Interface
        "eth0". </para>

        <figure float="1" id="host-with-addr-and-physaddr">
          <title>The Host object with Address and Physical Address</title>
              <graphic scale="60" fileref="using-physaddress-1.png" />
        </figure>

	<note><para>Note how <guilabel>MAC matching</guilabel> is
	checked in the Host object dialog. This makes the compiler use
	the MAC addresses of the interfaces of this
	host.</para></note>

        <para>Because this is a very important host, we would like to
        be sure that packets whose source IP is that of this host are
        really coming from it and are not spoofed. The best way to
        achieve this goal is to use strong authentication, for example
        with IPSEC protocol. Using IPSEC is outside the scope of this
        document though; our goal right now is to show that inspecting
        the MAC address of the packet can improve security. </para>

        <para>Both a real packet originated from this host and a
        spoofed packet have a source IP address of the interface of
        this host, but the source MAC address is going to be different
        if spoofing is going on. We can use this to catch and drop
        spoofed packets. Here are three possible ways to build
        security policy in this situation: </para>

        <para><itemizedlist>
            <listitem>
              <para>Using only Address object in the rule element. This means
              the firewall inspects only IP address and ignores the MAC
              address of the packets.</para>

              <figure float="1" id="only-addr">
                <title>Policy rule using only Address object</title>
		  <graphic scale="70" fileref="using-physaddress-4.png" />
              </figure>

	    <para> Firewall Builder generates the following simple iptables command for this rule:</para>
<screen>
$IPTABLES -A FORWARD  -s 10.3.14.44  -m state --state NEW  -j ACCEPT 
</screen>                
            </listitem>

            <listitem>
              <para>Using only Physical Address object. A rule built this way
              permits all kinds of traffic coming from the trusted host even
              if its IP address changes.</para>

              <figure float="1" id="only-phaddr">
                <title>Policy rule using only Physical Address object</title>
		  <graphic scale="70" fileref="using-physaddress-5.png" />
              </figure>

	      <para> For this rule, the following iptables command is generated:</para>
	      <screen>
$IPTABLES -A FORWARD  -m mac --mac-source 00:1D:09:8B:8E:94 -m state --state NEW \
-j ACCEPT 
              </screen>
            </listitem>

            <listitem>
              <para>Using Host or Interface object. This way we end up with a
              rule that matches on a <emphasis>combination</emphasis> of the
              IP address and MAC address. This may be used as a sophisticated
              anti-spoofing rule.</para>

              <figure float="1" id="using-host">
                <title>Policy rule using Host object</title>
		  <graphic scale="70" fileref="using-physaddress-6.png" />
              </figure>

              <figure float="1" id="using-interface">
                <title>Policy rule using Interface object</title>
		  <graphic scale="70" fileref="using-physaddress-3.png" />
              </figure>

	      <para> For this rule, the following iptables command is generated:</para>
	      <screen>
$IPTABLES -A FORWARD  -m mac --mac-source 00:1D:09:8B:8E:94 -s 10.3.14.44  -m state \
--state NEW  -j ACCEPT 
              </screen>
            </listitem>
          </itemizedlist></para>

        <para>Using Address and Physical Address objects in a rule is
        not the same as using the Host or Interface object to which
        these Address and Physical Address belong. Here is what
        happens if we put objects representing IP address and MAC
        address in the rule:</para>

        <figure float="1" id="addr-and-phaddr">
          <title>Policy rule using Address and Physical Address
          objects</title>
              <graphic scale="70" fileref="using-physaddress-7.png" />
        </figure>

	<para> For this rule, the following iptables commands are generated:</para>
	<screen>
$IPTABLES -A FORWARD  -s 10.3.14.44  -m state --state NEW  -j ACCEPT 
$IPTABLES -A FORWARD  -m mac --mac-source 00:1D:09:8B:8E:94 -m state --state NEW \
-j ACCEPT 
        </screen>  

	<para>As described in <xref linkend="multiple-addresses" />,
        using an multiple objects in the rule element is like bundling
        them together using logical
        operation <emphasis>OR</emphasis>. If we were to put Address
        and Physical Address in the rule like in
        <xref linkend="addr-and-phaddr" />, we would end up with a
        policy matching packets that have the source address
        10.3.14.44 or MAC address 00:1D:09:8B:8E:94, but not
        necessarily both at the same time. Any host that manages to
        pretend to have the IP address 10.3.14.44 would be able to
        send packets through our firewall even if its MAC address is
        different. To achieve our goal and make sure packets with the
        source 10.3.14.44 really belong to our important host, we
        should be checking its IP address and MAC address at the same
        time and let a packet through only if its IP
        address <emphasis>AND</emphasis> MAC address are what we
        expect them to be. That is why Firewall Builder treats
        physical addresses differently and generates firewall code
        that inspects both IP address and physical address.</para>

        <para>Firewall Builder generates firewall code to inspect MAC
        address only for Host objects with the option <guilabel>MAC
        address filtering</guilabel> turned on. If this option is off,
        the Physical Address object will be ignored even if it is
        present in the Host object's Interface. This is because Host
        objects created using the Network Discovery Druid (
        <xref linkend="network-discovery" /> ) are often populated
        with both IP address and MAC address information (available
        through SNMP query), but inspection of MAC addresses is rarely
        needed. Use the <guilabel>MAC address filtering</guilabel>
        option in the Host object to specify that you want the MAC
        address to be verified for the host.</para>

	<note><para>The target firewall imposes certain restrictions
	on rules matching the MAC address. For example, only source
	MAC addresses can be matched. Firewall Builder is aware of
	these restrictions, and the policy compiler will issue an
	error if a Physical Address object is used in a rule that
	would lead to an impossible iptables command.</para></note>
      </sect3>
    </sect2>

    <sect2>
      <title>Host Object</title>

      <para>The Host object in Firewall Builder is designed to
      represent real hosts in the network: workstations, servers, and
      any other network node with an address. Just like real hosts,
      Host objects have interfaces that represent different physical
      connections to the network. </para>

      <para>Most hosts have just a single (visible) interface with a
      single IP address. In that case the actual interface and its
      name do not matter. For most foreign hosts, Firewall Builder
      assigns an arbitrary name, like
      <quote>interface1</quote>, to the host's interface. However, by using the tree-like
      hierarchy of hosts -&gt; interfaces -&gt; addresses, it is possible
      to specify the exact address and/or interface of a host in cases where it does matter.</para>

      <para>As in the Firewall object, interfaces and addresses are
      represented by objects that are organized in a tree. An
      interface can have multiple addresses. An example of a host with
      one interface and multiple addresses is shown in
      <xref linkend="host-in-tree" />. Host <quote>test server</quote>
      is located on the LAN and has three virtual IP addresses that
      all belong to the same interface, <quote>eth0</quote>.</para>

      <para>Note that in Firewall Builder, the host object is an
      abstraction. It does not have to conform to an individual
      host. This host object may in fact represent a web farm that
      accepts connections on three IP addresses, each on a different
      computer.
      </para>

      <figure float="1" id="host-in-tree">
        <title>A Host Object With One Interface And Multiple Virtual
        Addresses</title>
            <graphic scale="70" fileref="host_in_tree.png" />
      </figure>

      <note>
        <para>The host object cannot have any access, NAT or routing
        policy associated with it; only firewall objects can have
        policies.</para>
      </note>

    <sect3>
      <title>Creating a Host Object</title>

      <para>To speed up the process and make it simpler, creating a new host
      object is aided by a wizard that is similar to the one for creating a new Firewall Objects.</para>

      <para>To launch the wizard, select <guimenuitem>New
      Host</guimenuitem> from the <guimenu>New Object</guimenu> menu
      or right-click on <guimenuitem>Hosts</guimenuitem> and select it
      from there.</para>

      <para><xref linkend="firewall-object" /> shows how to use the
      Firewall object wizard. The Host object wizard is the same, with
      the following exceptions:</para>

      <itemizedlist spacing="compact">
          <listitem>
            <para>All methods</para>

            <para>You do not specify the operating system or platform for host objects.</para>
          </listitem>

          <listitem>
            <para>From template</para>

            <para>The Host object templates are different than those
            for Firewall objects. Browse through the list in Firewall
            Builder to see what's available.</para>
          </listitem>

          <listitem>
            <para>Manually</para>

            <para>This method works the same as for the Firewall
            object, though the <guilabel>Add Interfaces</guilabel>
            page is slightly different. You cannot tag an interface as
            a "bridge port" interface. You can, however, indicate it
            is unnumbered or dynamic by selecting the appropriate
            checkbox. If neither checkbox is selected, then the
            interface is assumed to have a static IP address. As with
            the Firewall object wizard, you can only add IPv4
            addresses in this way. If you need to use IPv6 addresses,
            create the host object without IP addresses and add them
            later.</para>
          </listitem>

          <listitem>
            <para>Via SNMP</para>

            <para>This method works the same as for a Firewall
            object. The Host object must have the same name as the
            actual device and the host must respond to SNMP.</para>
          </listitem>
        </itemizedlist>

      <note>
        <para>You can always add, modify and remove interfaces of the new host
        object later using controls provided in the main window and object
        tree view.</para>
      </note>
    </sect3>

    <sect3>
      <title>Editing a Host Object</title>

      <figure float="1" id="host-dialog1">
        <title>Editing The Host Object</title>
            <graphic scale="60" fileref="host_dialog1.png" />
      </figure>

      <para>The Host object dialog allows you to edit the following parameters:</para>

      <para><itemizedlist spacing="compact">
          <listitem>
            <para>Name:</para>

            <para>The Host object name.</para>
          </listitem>

          <listitem>
            <para>MAC matching:</para>

            <para>If this option is activated, the policy compiler
            uses the MAC addresses of all interfaces of this host in
            the firewall rules. Not all firewall platforms support MAC
            address filtering, so this option may have no effect on
            the generated firewall script. This is treated as a
            non-critical situation, and the policy compiler will only
            generate a warning while processing a firewall policy
            where such a host is used. You cannot enter the physical
            (MAC) address in this dialog, however. See
            <xref linkend="using-mac-address" />.</para>
          </listitem>

          <listitem>
            <para>Comment:</para>

            <para>This is a free-form text field which can be used to add
            comments.</para>
          </listitem>
        </itemizedlist></para>
      </sect3>
      
      <sect3>
	<title>Using a Host Object in Rules</title>

	<para>When a Host object is used in a rule, it acts as a group
	of all of the addresses that belong to all of its
	interfaces. The only exception is the loopback interface; the
	compiler skips that address when replacing the Host object
	with its addresses.</para>

	<para>Consider the following Host object. It has interface
	eth0 with two IP addresses and a MAC address, interface
	he-ipv6 with an IPv6 address and a MAC address, interface lo
	(loopback) with its own IP address and interface sit0 (tunnel)
	with no address.</para>

      <figure float="1" id="host_example_1">
        <title>Host with multiple interfaces, some with multiple addresses</title>
            <graphic scale="70" fileref="host_example_1.png" />
      </figure>

      <para>Let's put this host object in a rule as follows:</para>

      <figure float="1" id="host_example_2">
        <title>Host in a rule</title>
            <graphic scale="70" fileref="host_example_2.png" />
      </figure>

      <para>The rule set is configured as "IPv4 only", so even though
      interface he-ipv6 has IPv6 address, Firewall Builder will ignore
      it while generating iptables commands for this rule. Interface
      eth0 has two IPv4 addresses and both will be used. Here are
      iptables commands generated for this rule:</para>

      <screen>
$IPTABLES -A FORWARD -p tcp -m tcp  --dport 22  -m state --state NEW \
-j Cid6066X5981.1 
$IPTABLES -A Cid6066X5981.1  -d 10.3.14.44  -j ACCEPT 
$IPTABLES -A Cid6066X5981.1  -d 10.3.14.55  -j ACCEPT 
$IPTABLES -A Cid6066X5981.1  -d  -j ACCEPT 
      </screen>

      <para>Let's see what we get for the same rule if we configure rule set object as "IPv4+IPv6":</para>

      <figure float="1" id="host_example_3">
        <title>Host in a rule with both IPv4 and IPv6</title>
            <graphic scale="70" fileref="host_example_3.png" />
      </figure>

      <para>Since the rule is now configured to compile for both
      address families, Firewall Builder processes it twice, once for
      each address family. Here is what we get (these are relevant
      fragments of the generated script):</para>

      <screen>
# ================ IPv4

$IPTABLES -A FORWARD -p tcp -m tcp  --dport 22  -m state --state NEW  \
-j Cid6066X5981.1 
$IPTABLES -A Cid6066X5981.1  -d 10.3.14.44  -j ACCEPT 
$IPTABLES -A Cid6066X5981.1  -d 10.3.14.55  -j ACCEPT 
$IPTABLES -A Cid6066X5981.1  -d  -j ACCEPT 

# ================ IPv6

$IP6TABLES -A FORWARD -p tcp -m tcp  --dport 22  -m state --state NEW  \
-j Cid6066X5981.1 
$IP6TABLES -A Cid6066X5981.1  -d fe80::a3:e2c  -j ACCEPT 
     </screen>
      </sect3>

        <sect3 id="multiple-addresses">
      <title>Using Objects With Multiple Addresses in the Policy and NAT
      rules</title>

      <para>Host and Firewall objects have child Interface objects,
      which in turn have child Address and Physical Address
      objects. In fact, an interface object can have more than one
      associated address object. Let's see how this works:</para>

      <figure float="1" id="multiple-addresses-obj1">
        <title>Host object with an interface that has multiple
        addresses</title>
            <graphic scale="70" fileref="multiple-addresses-obj1.png" />
      </figure>

      <figure float="1" id="multiple-addresses1">
        <title>Using objects with multiple addresses in policy
        rules</title>
            <graphic scale="70" fileref="multiple-addresses-rule1.png" />
      </figure>

      <para>Consider example <xref linkend="multiple-addresses-obj1" />, <xref
      linkend="multiple-addresses1" />. Here interface
      <emphasis>eth0</emphasis> of "test
      server" has three IP addresses (named "test
      server:eth0:0" through "test
      server:eth0:2") and interface <emphasis>eth0</emphasis> of
       "dmz host" has only one IP address:
      "dmz host:eth0". Policy rule #9 says that
      "dmz host" can talk to "test
      server" using any protocol. Since "test
      server" has three different addresses, we need to generate
      policy a rule that will match any of them. (Obviously we cannot match all three at
      once, so the compiler uses a logical "OR", not a logical 
      "AND" here.) Basically, rule #9 is equivalent to three separate rules,
      each of them using one address of "test server" in
      turn. These three rules are represented in <xref
      linkend="multiple-addresses2" /> (original rule #9 also shown there, but
      it is disabled.)</para>

      <figure float="1" id="multiple-addresses2">
        <title>Equivalent rules</title>
            <graphic scale="60" fileref="multiple-addresses-rule2.png" />
      </figure>

      <para>Firewall Builder takes care of this situation automatically and
      generates the firewall policy described in <xref
      linkend="multiple-addresses1" /> as if a user had built a policy in the
      GUI using the three rules as shown in <xref
      linkend="multiple-addresses2" />.</para>

      <para>In fact, the algorithm used is even more general. In the
      example <xref linkend="multiple-addresses1" />, host "test
      server" has a single interface with multiple addresses that the 
      compiler used to generate the target firewall code. The policy compiler
      works in a similar way even if the host or firewall object used in the rule
      has multiple interfaces and each interface, in turn, has multiple
      addresses. If a host (or firewall) object is used in the rule, then the
      compiler scans all its interfaces, finds all corresponding addresses, and
      uses them to generate the firewall configuration. If an interface object is
      used in the rule, then the compiler uses all its addresses. And finally,
      if an Address or Physical Address object is used in the rule, then the compiler
      uses only this parameter to generate the firewall configuration.
      In other words, the compiler always traverses the tree, starting from the
      object found in the policy rule, and uses the parameters of all Address and
      Physical Address objects it finds. Since Address and Physical Address
      objects are the leaf nodes in the tree and have no other objects beneath
      them, the compiler uses the parameters of these objects to
      generate the target code.</para>

      <note>
        <para>There is an exception to this algorithm, see <xref
        linkend="using-mac-address" /></para>
      </note>
    </sect3>
    </sect2>

    <sect2>
      <title>IPv4 Network Object</title>

      <figure float="1" id="network-dialog1">
        <title>The Network Object</title>
            <graphic scale="60" fileref="network_dialog1.png" />
      </figure>

      <para>The network object describes an IP network or subnet. Use
      main menu <guimenuitem>Net Object / New Network</guimenuitem>
      item to create objects of this type. The dialog of the Network
      object provides the following entry fields: </para>

      <para><itemizedlist spacing="compact">
          <listitem>
            <para>Name:</para>

            <para>Network object name</para>
          </listitem>

          <listitem>
            <para>Address:</para>

            <para>The IPv4 address of the network.</para>
          </listitem>

          <listitem>
            <para>Netmask:</para>

            <para>The Netmask, in combination with an Address, defines
            the subnet. You can enter either string octet
            representation of the mask or its bit length here, however
            the program always converts it to the octet
            representation. Netmask in the network object is always
            entered in the "natural" way, such as "255.255.255.0",
            even if the object is going to be used to build Cisco IOS
            access lists which require reversed "bit mask"
            presentation instead (e.g "0.0.0.255" for the netmask
            above). Firewall Builder policy compiler takes care of the
            conversion automatically. </para>
          </listitem>

          <listitem>
            <para>Comment:</para>

            <para>This is a free-form text field used for comments</para>
          </listitem>
        </itemizedlist></para>

	<para>Let's use the Network object shown above in a policy rule compiled for different target platforms.</para>

      <figure float="1" id="network_example_1">
        <title>IPv4 Network object used in a rule</title>
            <graphic scale="70" fileref="network_example_1.png" />
      </figure>

	<para> Here is what we get for iptables:</para>
<screen>
$IPTABLES -A FORWARD -p tcp -m tcp  -s 172.16.22.0/24  --dport 80  -m state \
--state NEW  -j ACCEPT 
</screen>

	 <para>Here is the output produced for PF:</para>
<screen>
pass in   quick inet proto tcp  from 172.16.22.0/24  to any port 80 keep state
pass out  quick inet proto tcp  from 172.16.22.0/24  to any port 80 keep state
</screen>          

	  <para>Here is how the output looks like when the rule is
	  compiled into Cisco IOS access-lists (this is one of the
	  generated access lists):</para>

          <screen>
ip access-list extended outside_out
  permit tcp 172.16.22.0 0.0.0.255 any  eq 80 
exit
          </screen>          

	  <para>Here is what we get when the rule is compiled into
	  Cisco ASA (PIX) configuration. Note how the compiler uses
	  netmask 255.255.255.0 for PIX, while for IOS it was
	  converted to 0.0.0.255. Also, interface "inside" was
	  configured with network zone 172.16.0.0/12, which matched
	  network object used in the source element of the
	  rule. Because of that, the compiler put the rule only into
	  the access list attached to interface "inside".</para>

          <screen>
access-list inside_acl_in permit tcp 172.16.22.0 255.255.255.0 any eq 80 
access-group inside_acl_in in interface inside
          </screen>          

    </sect2>

    <sect2>
      <title>IPv6 Network Object</title>

      <figure float="1" id="ipv6-network-dialog1">
        <title>IPv6 Network Object</title>
            <graphic scale="60" fileref="ipv6-network_dialog1.png" />
      </figure>

      <para> The network object describes an IPv6 network or
      subnet. This object is very similar to the IPv4 Network object,
      except you can only enter netmask as a bit length. Use main menu
      "Net Object / New Network IPv6" item to create objects of this
      type.</para>

      <para>Let's see what we get if we use an IPv6 Network object in a policy rule as shown:</para>

      <figure float="1" id="ipv6_network_example_1">
        <title>IPv6 Network object used in a rule</title>
            <graphic scale="70" fileref="ipv6_network_example_1.png" />
      </figure>

      <para> Here is the command generated for iptables:</para>
      <screen>
$IP6TABLES -A FORWARD -p tcp -m tcp  -s 2001:470:1f0e:162::/64  --dport 80  \
-m state --state NEW  -j ACCEPT 
      </screen>

      <para>Here is what we get for PF:</para>
      <screen>
pass in   quick inet6 proto tcp  from 2001:470:1f0e:162::/64  to any port 80 keep state
pass out  quick inet6 proto tcp  from 2001:470:1f0e:162::/64  to any port 80 keep state
      </screen>          

      <para>Here is the output for Cisco IOS access lists (only one ACL is shown):</para>
      <screen>
ipv6 access-list ipv6_outside_out
  permit tcp 2001:470:1f0e:162::/64 any  eq 80 
exit

interface eth0
  ipv6 traffic-filter ipv6_outside_out out
exit
      </screen>             

      <para>There is no IPv6 support for Cisco ASA (PIX) in Firewall Builder at this time.</para>

    </sect2>

    <sect2>
      <title>Address Range Object</title>

      <figure float="1" id="address_range_1">
        <title>The Address Range Object</title>
            <graphic scale="60" fileref="address_range_1.png" />
      </figure>

      <para>The Address Range object describes a continuous range of
      IPv4 addresses. (Arbitrary address ranges are unsupported for
      IPv6.) To create new Address Range object, use main
      menu <guimenuitem>New Object / New Address
      Range</guimenuitem>. Its dialog provides the following entry
      fields:</para>

      <para><itemizedlist spacing="compact">
          <listitem>
            <para>Name:</para>

            <para>The name of the Address Range object</para>
          </listitem>

          <listitem>
            <para>Range start:</para>

            <para>The address of the start of the range</para>
          </listitem>

          <listitem>
            <para>Range end:</para>

            <para>The address of the end of the range</para>
          </listitem>

          <listitem>
            <para>Comment:</para>

            <para>A free-form text field used for comments</para>
          </listitem>
        </itemizedlist></para>

      <para>The Address range is inclusive, that is, both the start and the
      end addresses are included in the range.</para>

      <para> When Address Range object is used in a rule, Firewall
      Builder replaces it with a list of addresses equivalent to the
      specified range. The program tries to generate the most
      economical representation of the range using a combination of
      subnets of different lengths. Consider the Address Range object
      shown above. This Address Range object represents IP addresses
      between 192.168.1.100 and 192.168.1.160 (inclusively). It would
      be wasteful to generate 61 iptables commands to represent this
      range. Instead, the compiler uses a combination of several
      subnets of different lengths and ends up with the
      following:</para>

      <screen>
$IPTABLES -A FORWARD  -s 192.168.1.100/30  -m state --state NEW  -j ACCEPT 
$IPTABLES -A FORWARD  -s 192.168.1.104/29  -m state --state NEW  -j ACCEPT 
$IPTABLES -A FORWARD  -s 192.168.1.112/28  -m state --state NEW  -j ACCEPT 
$IPTABLES -A FORWARD  -s 192.168.1.128/27  -m state --state NEW  -j ACCEPT 
$IPTABLES -A FORWARD  -s 192.168.1.160  -m state --state NEW  -j ACCEPT 
      </screen>        

      <para>Here is how the generated configuration looks for PF (this
      is essentially the same, except it uses tables for
      brevity):</para>
      
      <screen>
table &lt;tbl.r0.s&gt; { 192.168.1.100/30 , 192.168.1.104/29 , 192.168.1.112/28 , \
192.168.1.128/27 , 192.168.1.160 } 

pass in   quick inet  from &lt;tbl.r0.s&gt;  to any keep state
      </screen>

      <para>Just for completeness, let's look at the configuration
      generated for the same rule for Cisco IOS access lists. This is
      really just a fragment of the generate router access list
      configuration because generated ACLs are attached to interfaces
      and, since the rule in the example was not associated with any
      interfaces, it got attached to all of them. Here we show only
      one generated ACL:</para>

      <screen>
ip access-list extended inside_in
! 
! Rule  0 (global)
! 
! 
  permit ip 192.168.1.100 0.0.0.3 any  
  permit ip 192.168.1.104 0.0.0.7 any  
  permit ip 192.168.1.112 0.0.0.15 any  
  permit ip 192.168.1.128 0.0.0.31 any  
  permit ip host 192.168.1.160 any  
exit
      </screen>

    </sect2>



    <sect2>
      <title>Address Tables Object</title>

      <para>Sometimes you need to apply a rule to a set of addresses,
      but you don't know what those addresses will be when you're
      writing the policy. The <guilabel>Address Table</guilabel>
      object can help.</para>

      <figure float="1" id="address-table-dialog1">
        <title>The Address Table Object</title>
            <graphic scale="70" fileref="address_table_2.png" />
      </figure>

      <para>The <guilabel>Address Table</guilabel> object has the following fields:</para>

      <itemizedlist spacing="compact">
          <listitem>
            <para>Name:</para>

            <para>The name of the Address Table object</para>
          </listitem>

          <listitem>
            <para>Compile Time / Run Time:</para>

            <para>Indicate whether you want the file to be loaded with
            the firewall compiler runs (Compile Time) or when the
            firewall runs the firewall script (Run Time). </para>
          </listitem>

          <listitem>
            <para>File name:</para>

            <para>The name of the text file you want to load. (The
            file contains IP addresses or IP address ranges.) The
            filename can have any extension. If you want the file to
            load at run time, you must specify the path and name where
            the file will be on the <emphasis>firewall</emphasis>
            machine, not the client machine.</para>
          </listitem>

          <listitem>
            <para>Browse button:</para>

            <para>Used to populate the file name and path if the file is on the local machine.</para>
          </listitem>

          <listitem>
            <para>Preview button:</para>

            <para>Once the File name field is populated, use this button to view the file.</para>
          </listitem>

          <listitem>
            <para>Comment:</para>

            <para>A free-form text field used for comments</para>
          </listitem>
        </itemizedlist>

	<para>The <guilabel>Compile Time</guilabel> and <guilabel>Run
	Time</guilabel> radio buttons define when the addresses will
	be read from the file: when the firewall script is generated
	by Firewall Builder or when the firewall runs the script. If
	object is configured as <guilabel>Compile Time</guilabel>, the
	Firewall Builder policy compiler opens the file during
	compilation and replaces the <guilabel>Address
	Table</guilabel> object in policy rules with the set of
	addresses from the file. This means the file with addresses
	must be accessible on the machine where the Firewall Builder
	GUI and policy compilers run. If the object is configured
	as <guilabel>Run Time</guilabel>, policy compiler does not try
	to find and open the file but instead generates a firewall
	script that will do this when it is activated. This means the
	file with addresses must be located where it is accessible by
	the firewall, and the object must be configured with the full
	path to it on the firewall.</para>

	<para>Here is an example of the file contents (this is what
	you see if you click "Preview" button in the object
	dialog):</para>

      <figure float="1" id="address-table-textfile">
        <title>Address Table text file</title>
            <graphic scale="70" fileref="address_table_4.png" />
      </figure>

      <para>Note that comments in the file can start with '#' or ';',
      that a comment can follow an address on the same line or take
      the whole line and that lines can start with white space for
      formatting. This example file contains both IPv4 and IPv6
      addresses for illustration purposes.</para>

      <para>Compile-time Address Table objects are supported on all
      target firewall platforms because addresses are read by the
      compiler. The compiler then generates normal configuration lines
      or script commands. Run time Address Table objects require
      special support from the target firewall and therefore supported
      only on some of them. Currently Run Time Address Table objects
      can be used in rules for iptables and PF firewalls.</para>

      <para>Let's look at the firewall script generated by Firewall
      Builder for the iptables and PF when the Address Table object
      used in the policy rule is configured first as "Compile Time"
      and then as "Run Time". The rule is very simple and looks like
      (<xref linkend="address-table-rule" />):</para>

      <figure float="1" id="address-table-rule">
        <title>Rule using an Address Object</title>
            <graphic scale="70" fileref="address_table_3.png" />
      </figure>

      <para>This rule, with the object set to <guilabel>Compile Time</guilabel>, generates the following output:</para>

      <figure float="1" id="address-table-compile-iptables">
        <title>Compile Time, iptables compile output</title>
            <screen>
# Rule 0 (global)
# 
$IPTABLES -A INPUT  -d 192.168.1.1  -j DROP 
$IPTABLES -A FORWARD  -d 192.168.1.2  -j DROP 
$IPTABLES -A FORWARD  -d 192.168.1.3/30  -j DROP 
$IPTABLES -A FORWARD  -d 192.168.2.128/25  -j DROP 
$IPTABLES -A FORWARD  -d 192.168.1.200  -j DROP 
$IPTABLES -A FORWARD  -d 192.168.1.201  -j DROP 
</screen>
      </figure>

      <para>The compiler replaced
      object <guilabel>address_table_1</guilabel> in the Destination
      with addresses it took from the file. Option <guilabel>assume
      firewall is part of any</guilabel> was turned off in the
      firewall object settings, which is why compiler did not generate
      rules in the OUTPUT chain. However one of the addresses in the
      file matched the address of one of the interfaces of the
      firewall (192.168.1.1) and the corresponding rule went into the
      INPUT chain. Other addresses were copied from the file verbatim,
      including netmask specifications. The Policy object of this
      firewall was configured as "IPv4 rule set", because of this the
      compiler dropped the IPv6 addresses it found in the file. If the
      rule set was configured as a mix of IPv4 and IPv6, compiler
      would use IPv4 addresses in IPv4 rules and IPv6 addresses in
      IPv6 rules.</para>

      <figure float="1" id="address-table-compile-pf">
        <title>Compile Time, PF compile output</title>
            <screen>
# Tables: (1)
table  { 192.168.1.1 , 192.168.1.2 , 192.168.1.3/30 , 192.168.2.128/25 , \
192.168.1.200 , 192.168.1.201 }

# Rule  0 (global)
# 
block in   quick inet  from any  to &lt;tbl.r0.d&gt;
block out  quick inet  from any  to &lt;tbl.r0.d&gt;

</screen>
      </figure>

      <para>The output for PF is simple because Firewall Builder can
      use the built-in table facility. All addresses are copied from
      the file verbatim into the table tbl.r0.d.</para>

      <figure float="1" id="address-table-run-iptables">
        <title>Run Time, iptables compile output</title>
            <screen>
# Using 1 address table files
check_file "address_table_1" "/home/vadim/addr-table-1.tbl"

# Rule 0 (global)
# 
grep -Ev '^#|^;|^\s*$' /home/vadim/addr-table-1.tbl | while read L ; do
  set $L; at_address_table_1=$1; $IPTABLES -A FORWARD  -d $at_address_table_1  -j DROP 
done
</screen>
      </figure>

      <para> First, the generated script checks if the file specified
      in the Address Table object exists on the firewall machine. If
      the file is not found, the script aborts execution to avoid
      loading incomplete iptables rules. However, the script cannot
      verify that the file is the one you intended it to be, it just
      assumes that if the file with this name exists it is the right
      one and tries to interpret it as a list of IP addresses, with
      one address per line. Then the script reads the file line by
      line, skipping comments, and assigns IP addresses to the shell
      variable at_address_table_1, which it then uses in the iptables
      command.</para>

      <para>Since the compiler did not see the addresses from the
      file, it could not detect that one of them matched an address of
      the firewall and all iptables commands went to the FORWARD
      chain. The file /home/vadim/addr-table-1.tbl should be located
      on the firewall where the generated iptables script will be
      executed so the script can find it.</para>

      <para>Here is what you get if the option <guilabel>"Assume
      firewall is part of any"</guilabel> is turned on in the firewall
      object settings:</para>

      <figure float="1" id="address-table-run-iptables-assume">
        <title>Run Time, iptables compile output, assume firewall is part of "any"</title>
            <screen>
# Rule 0 (global)
# 
grep -Ev '^#|^;|^\s*$' /home/vadim/addr-table-1.tbl | while read L ; do
  set $L; at_address_table_1=$1; $IPTABLES -A OUTPUT  -d $at_address_table_1  -j DROP 
done
grep -Ev '^#|^;|^\s*$' /home/vadim/addr-table-1.tbl | while read L ; do
  set $L; at_address_table_1=$1; $IPTABLES -A FORWARD  -d $at_address_table_1  -j DROP 
done
</screen>
      </figure>

      <para>The difference is that compiler generated two sets of
      commands, one in chain OUTPUT and another in chain FORWARD. The
      original rule has "any" in source, and if
      option <guilabel>Assume firewall is part of any</guilabel> is
      turned on, the compiler assumes the source of the rule can have
      either an unknown address or the firewall. The former makes it
      generate iptables command in the FORWARD chain and the latter
      makes it generate iptables command in the OUTPUT chain. This
      logic is not specific to the Address Table object type; the
      compiler does this regardless of the type of the object used in
      destination if source is "any" and option <guilabel>Assume
      firewall is part of any</guilabel> is turned on.</para>

      <figure float="1" id="address-table-run-pf">
        <title>Run Time, PF compile output</title>
            <screen>
# Tables: (1)
table  persist file "/home/vadim/addr-table-1.tbl"
# Rule  0 (global)
# 
# 
block in   quick inet  from any  to &lt;address_table_1&gt;
block out  quick inet  from any  to &lt;address_table_1&gt;
</screen>
      </figure>

      <para>PF is even easier in the case of run time address
      tables. Compiler just uses <emphasis>table</emphasis> facility
      with <emphasis>persist</emphasis> and <emphasis>file</emphasis>
      options to direct pfctl to open the file and read its
      contents. In this case the file should follow formatting
      requirements of PF.</para>

      <para>Policy compiler for PF treats Address Table objects with
      empty file name specially. It just generates the line "table
      &lt;table_name&gt;" at the beginning of the .conf file with no
      file specification. This table will not be populated when .conf
      file is loaded and therefore will remain empty, but it can be
      used in the rules.</para>

      <para>Addresses can be added to the table later using external scripts that call pfctl like this:</para>

      <screen>
pfctl -t bad_hosts -T add 192.0.2.1
      </screen>

      <para>Another interesting possibility is to automatically
      populate the table if option "overload" is used in combination
      with other rate limiting options on a rule. Taking an example
      from the man page for pf.conf, here is how it looks:</para>

            <screen>
block quick from &lt;bad_hosts&gt;
pass in on $ext_if proto tcp to $webserver port www keep state \
                   (max-src-conn-rate 100/10, overload &lt;bad_hosts&gt; flush global)
</screen>

      <para>The idea behind these rules is that if some host tries to
      connect to the web server too often &mdash; more often than is
      allowed by max-src-conn-rate 100/10 &mdash; its address will be
      added to the table &lt;bad_hosts&gt; by PF. The next time this
      host tries to connect, the packet coming from it will be denied
      by the blocking rule right away.</para>

      <para>To implement these rules in Firewall Builder, you would
      create an Address Table object with name "bad_hosts" but a blank
      file name, configured to resolve at run time:</para>

      <figure float="1" id="address-table-bad-hosts">
        <title>Address Table Object bad_hosts</title>
            <graphic scale="70" fileref="address_table_5.png" />
      </figure>

      <para>Then, use this Address Table object in the source field of
      a policy rule with action "Deny". This is rule #0 in the
      screenshot below. Another rule, rule #1 in the screenshot, has
      action "Accept" and matches destination against address of the
      web server, protocol http, and has limiting options set up to
      restrict the number of connections and to
      turn <guilabel>overload table</guilabel> on, with the name of
      the overload table "bad_hosts" that matches the name of the
      Address Table object.</para>

      <figure float="1" id="address-table-bad-hosts-rules">
        <title>Address Table Object bad_hosts Rules</title>
            <graphic scale="60" fileref="address_table_6.png" />
      </figure>

      <para>These two rules, as shown on the screen shots, yield the
      following PF configuration that matches the one given in the man
      page:</para>

            <screen>
# Tables: (1)
table &lt;bad_hosts&gt; persist

# Rule  0 (global)
# 
block in   log  quick inet  from &lt;bad_hosts&gt;  to any 
# 
# Rule  1 (global)
# 
pass in   quick inet proto tcp  from any  to 192.168.1.1 port 80 \
   keep state  (  max-src-conn-rate 100/10, overload &lt;bad_hosts&lt; flush global ) 

</screen>

    </sect2>

    <sect2>
      <title>Special case addresses</title>

	<para>Policy compilers treat some addresses in policy rules in
	special ways, depending on the requirements of the target
	firewall platform. For example, the compiler for iptables
	checks if the address found in "Destination" or "Source" of a
	rule matches the address of any interface of the firewall to
	determine if the rule should be placed in INPUT or OUTPUT
	chain. The compiler for PIX uses the command ssh
	&lt;address&gt; &lt;netmask>&gt; inside when it detects such
	an address in the destination of a rule where the service is
	TCP Service object "SSH". There are other special cases as
	well.</para>

      <sect3>
	<title>Broadcast and Multicast Addresses, iptables Firewall</title>

	<para>One important special case is broadcast and multicast
	addresses. It is important to place rules in the correct chain
	in generated iptables script because even though these
	addresses are not equal to those of the firewall's interfaces,
	iptables processes packets with broadcast or multicast
	destination in the INPUT chain. Firewall Builder is aware of
	this and generates the correct iptables commands.</para>

	<para>In order to match broadcast or multicast addresses in
	the rules, we need to create objects to describe them. The
	choice of object type to describe broadcast or multicast
	address depends on whether this is just a single address, a
	range or a block. An Address object is good for defining a
	single address, Address Range is good for sets of consecutive
	addresses and Network object is good for describing a
	block. For example, you can use an Address object with address
	"255.255.255.255" to describe a broadcast. Address Range with
	addresses "224.0.0.5 - 224.0.0.6" would work well to describe
	two multicast groups used by OSPF. A Network object with
	address "224.0.0.0" and netmask "240.0.0.0" can be used to
	describe a whole multicast address block.</para>

	<para>Here are few examples:</para>

      <figure float="1" id="multicast_object_1">
        <title>Multicast object</title>
            <graphic scale="60" fileref="multicast_object_1.png" />
      </figure>

	<para>Object "all multicasts" is part of the Standard Objects
	library that comes with the program. It describes an entire
	address block allocated for multicasts. Consider a simple
	policy rule that permits all multicasts:</para>

      <figure float="1" id="multicast_rule_1">
        <title>Multicast rule</title>
            <graphic scale="70" fileref="multicast_rule_1.png" />
      </figure>

	<para>For iptables, this rule translates into the following script:</para>

        <screen>
$IPTABLES -A INPUT  -d 224.0.0.0/4  -m state --state NEW  -j ACCEPT 
        </screen>        

	 <para>The rule went into the INPUT chain because iptables processes multicast there.</para>

	  <para>Here is another example, this time it involves
	  broadcast addresses. Interface "inside" of the test firewall
	  has address 172.16.22.1 with netmask 255.255.255.0. This
	  defines subnet 172.16.22.0/255.255.255.0 with broadcast
	  address 172.16.22.255. We create an Address object with the
	  name "net-172.16.22 broadcast" and address "172.16.22.255"
	  and use it in the destination field of a policy
	  rule. Another rule in the same example will match broadcast
	  address "255.255.255.255"; an Address Range Object that
	  defines this address is present in the Standard Objects
	  library under the name "broadcast". Here are the
	  rules:</para>

      <figure float="1" id="broadcast_rules_1">
        <title>Broadcast rules</title>
            <graphic scale="70" fileref="broadcast_rules_1.png" />
      </figure>

	  <para> these two rules translate into the following script for iptables:</para>
          <screen>
# Rule 0 (global)
# 
$IPTABLES -A INPUT  -d 255.255.255.255  -m state --state NEW  -j ACCEPT 
# 
# Rule 1 (global)
# 
$IPTABLES -A INPUT  -d 172.16.22.255  -m state --state NEW  -j ACCEPT 
          </screen>

	  <para>Both rules went into INPUT chain as expected.</para>
      </sect3>

      <sect3>
	<title>Broadcast and Multicast Addresses and Bridging iptables Firewall</title>

	<para>Compilers treat broadcast and multicast addresses
	differently if the firewall object is set to be a bridging
	firewall. In this case the checkbox "Bridging firewall" should
	be turned on in the firewall settings dialog and one or more
	interface objects should be marked as "Bridge port":</para>

      <figure float="1" id="bridge-broadcast-multicast">
        <title>Broadcast and Multicast address in a bridging firewall</title>
            <graphic scale="50" fileref="bridge_interface_dialog_1.png" />
      </figure>

	<para>Now the rule that matches the broadcast destination address will be treated differently:</para>

      <figure float="1" id="broadcast_rules_2">
        <title>Broadcast and Multicast address in a rule</title>
            <graphic scale="70" fileref="broadcast_rules_2.png" />
      </figure>

	<para>This produces the following iptables commands:</para>

        <screen>
$IPTABLES -A FORWARD  -d 172.16.22.255  -m state --state NEW  -j ACCEPT 
$IPTABLES -A INPUT  -d 172.16.22.255  -m state --state NEW  -j ACCEPT 
        </screen>        

        <para>
          Rules went into both INPUT and FORWARD chains because the
          bridging firewall passes broadcasts through, but at the same
          time accepts them as packets headed for itself. Since the
          rule did not specify which interface it should look at,
          Firewall Builder assumed that the generated rule should
          inspect packets crossing all interfaces, both bridge ports
          and "normal" ones, and therefore placed the rule in both
          INPUT and FORWARD chains.
        </para>

      </sect3>
    </sect2>

    <sect2>
      <title>DNS Name Objects</title>

      <para>A DNS Name object represents a DNS "A" or "AAAA"
      record. The object resolves into IP address at compile or run
      time. The address (IPv4 or IPv6) the object resolves to depends
      the address family or families of the ruleset it is used
      in. That is, if the object is used in a rule that is part of
      IPv4 rule set, the compiler will try to resolve the object using
      DNS query for the "A" record, but if the object is used in a
      rule that is part of an IPv6 rule set, the compiler will run a
      "AAAA" query. If the rule set where the object is used is a
      mixed type (IPv4+IPv6), the compiler will resolve the same
      object twice using different queries.</para>

      <para>The <guilabel>DNS Name</guilabel> object dialog looks like this:</para>

      <figure float="1" id="dns-name">
        <title>DNS Name Object</title>
            <graphic scale="70" fileref="dns_name_2.png" />
      </figure>

<itemizedlist spacing="compact">
          <listitem>
            <para>Name:</para>

            <para>The name of the DNS Name object</para>
          </listitem>

          <listitem>
            <para>DNS Record:</para>

            <para>The DNS record you want to resolve.</para>
          </listitem>

          <listitem>
            <para>Compile Time / Run Time:</para>

            <para>Indicate whether you want to resolve the IP address
            when you create the firewall script (compile time) or when
            you run the script on the firewall (run time).</para>
          </listitem>

          <listitem>
            <para>Comment:</para>

            <para>A free-form text field used for comments</para>
          </listitem>
        </itemizedlist>

	<para> The <guilabel>DNS Record</guilabel> parameter is the
	name of the A or AAAA record we want to resolve. In this
	example it is the host name of the Firewall Builder project
	web site "www.fwbuilder.org". Note that IPv6 web server for
	the project is accessible as "ipv6.fwbuilder.org" so we are
	going to need second DNS Name object for IPv6
	examples. <guilabel>Compile Time</guilabel> and <guilabel>Run
	Time</guilabel> options have the same meaning as those in the
	Address Table object, that is, compile time DNS Name object is
	converted to the IP address by the policy compiler, while run
	time DNS Name object is not. In the latter case, the compiler
	puts DNS record name into the generated script or
	configuration file and leaves it up to the firewall to resolve
	it when the script is activated.</para>

	<para>Both compile time and run DNS Name objects are supported on all target firewall platforms.</para>

	<para>Let's look at how the simple rule shown in <xref linkend="group-dialog1" /> compiles for iptables and PF, both for compile time and run time DNS Name object.</para>

      <figure float="1" id="dns-name-3">
        <title>Rule using DNS Name object</title>
            <graphic scale="70" fileref="dns_name_3.png" />
      </figure>

      <figure float="1" id="dns-name-compile-iptables">
        <title>DNS Name Compile Time, iptables compile output</title>
            <screen>
# Rule 0 (global)
# 
$IPTABLES -A FORWARD  -d 70.85.175.170  -m state --state NEW  -j ACCEPT  
</screen>
      </figure>

      <para>In this trivial case, the compiler simply resolved
      "www.fwbuilder.org" to an IP address and used it in the iptables
      command. However, if the policy rule was in a ruleset configured
      as an IPv6-only rule set, the rule would not produce any
      iptables command at all because there is no AAAA DNS record with
      name "www.fwbuilder.org". If the rule set was both IPv4+IPv6,
      then the rule would generate iptables command only in the IPv4
      part. The opposite is also true, the DNS Name object with record
      "ipv6.fwbuilder.org" will only produce iptables commands when
      used in IPv6 rule set because there is only AAAA record with
      this name.</para>

      <figure float="1" id="dns-name-compile-pf">
        <title>DNS Name Compile Time, PF compile output</title>
            <screen>
# Rule  0 (global)
# 
pass in   quick inet  from any  to 70.85.175.170 keep state
</screen>
      </figure>

      <para>The same is true in the case of PF: the compiler simply
      resolved the name "www.fwbuilder.org" and put the address in the
      generated pf.conf file. Since this name does not resolve into
      any IPv6 address, IPv6 PF policy would not have any line for
      this rule. DNS record "ipv6.fwbuilder.org" resolves only into an
      IPv6 address, and therefore DNS Name object with this record
      would only produce pf.conf configuration for IPv6 and not for
      IPv4.</para>

      <figure float="1" id="dns-name-run-iptables">
        <title>DNS Name Run Time, iptables compile output</title>
        <screen>
# Rule 0 (global)
# 
$IPTABLES -A FORWARD  -d www.fwbuilder.org -m state --state NEW  -j ACCEPT
        </screen>
      </figure>


      <para>Here the compiler used the line entered in the DNS record
      parameter literally, leaving it up to iptables on the firewall
      machine to resolve this name into an IP address. Using a run
      time DNS Name object in IPv6 policy generates the following
      iptables command:</para>

      <screen>
# Rule 0 (global)
# 
$IP6TABLES -A FORWARD  -d ipv6.fwbuilder.org -m state --state NEW  -j ACCEPT 
      </screen>

      <para>
        $IP6TABLES is the shell variable defined at the beginning of
        the generated script, the value of this variable is the full
        path to the <command>ip6tables</command> command line
        utility. <command>ip6tables</command> will try to resolve
        given name to an IPv6 address since it processes IPv6 iptables
        policy.
      </para>

      <figure float="1" id="dns-name-run-pf">
        <title>DNS Name Run Time, PF compile output</title>
        <screen>
# Rule  0 (global)
#
pass in   quick inet  from any  to www.fwbuilder.org keep state
pass out  quick inet  from any  to www.fwbuilder.org keep state
	</screen>
      </figure>
      
      <para>Run time DNS Name object translates into PF configuration
      lines that also use the name of the DNS record and leave it up
      to PF to actually resolve it to an IP address when the
      configuration is loaded.</para>

    </sect2>

    <sect2>
      <title>A Group of Addressable Objects</title>

      <figure float="1" id="group-dialog1">
        <title>Group of Objects</title>
            <graphic scale="50" fileref="group-view1.png" />
      </figure>

      <para>The group of objects holds references to Hosts, Networks,
      Address Ranges, Firewalls and other groups of addressable
      objects (<xref linkend="group-dialog1" />). Use <guimenuitem>New
      Object / New Object Group</guimenuitem> to create a new
      group. Objects can be added to the group using the following
      methods:</para>

      <para><itemizedlist spacing="compact">
          <listitem>
            <para>Using drag and drop:</para>

            <para>Objects can be dragged from the tree into the group dialog.
            Click, hold down the mouse button, and drag the object to add it to the group.</para>
          </listitem>

          <listitem>
            <para>Using the popup menu:</para>

            <para>You can use the Copy/Paste operations between the tree
            and group dialog. Right-clicking on the object in the tree
            brings a pop-up menu. Choose <guimenuitem>Copy</guimenuitem> in this
            menu, then move the mouse to the group dialog and right-click in the
            icon field. This also brings up a pop-up menu, where you choose
            <guimenuitem>Paste</guimenuitem>. This inserts a reference to the object in the
            group.</para>
          </listitem>

          <listitem>
            <para>Using the <guimenu>Edit</guimenu> main menu:</para>

            <para>Select the object in the tree, select 
            <guimenu>Edit</guimenu>/<guimenuitem>Copy
            Object</guimenuitem> from the menu bar, then click on the
            group dialog, and then
            select <guimenuitem>Edit</guimenuitem>/<guimenuitem>Paste
            Object</guimenuitem> from the menu bar.</para>
          </listitem>
        </itemizedlist></para>
    </sect2>
   </sect1>

  <sect1 id="working-with-services">
    <title>Service Objects</title>

      <para>In Firewall Builder, service objects represent IP, ICMP,
      TCP, and UDP services such as "host unreachable" in ICMP, HTTP
      in TCP, GRE in IP, and DNS in UDP. Firewall Builder provides
      service objects for hundred of well-known and frequently used
      services in ICMP (IP protocol number 1), TCP (IP protocol number
      6), and UDP (IP protocol number 17). </para>

    <sect2>
      <title>IP Service</title>

      <para>    
                The IP service object describes protocols that are not
                ICMP, TCP, or UDP. (ICMP, TCP, and UDP have their own
                service objects.) An IP protocol is defined by the
                8-bit field in the IP packet header. The screenshot
                below represents the ESP object (Encapsulating
                Security Payload, part of the IPSEC protocol family)
                which uses the IP protocol number 50.</para>

        <figure float="1"><title/><graphic scale="50" fileref="ip_service_1.png"/></figure>
      
      <note>
	<para>Protocol numbers are assigned by IANA; one can look up the number for a
      particular protocol at the following URL:
      http://www.iana.org/assignments/protocol-numbers/</para>
      </note>

      <para>Besides the protocol number, the header of the IP packet also has
      a field called "options" which is a variable-length list of optional
      information for the packet. Not all firewalls can examine options, and
      those that can usually have certain limitations as to what options they
      can match against. Firewall Builder tries to provide controls for many
      popular options supported by the most sophisticated firewalls. Not all
      options supported by Firewall Builder are supported by all target
      firewall platforms (<xref linkend="support-for-ip-options" />).</para>

      <table id="support-for-ip-options" tabstyle='reg_table'>
        <title>Support for IP options and fragmentation on various firewall
        platforms</title>

        <tgroup cols="7">
          <colspec align="center" />

          <colspec align="center" colwidth="64pt" />

          <colspec align="center" colwidth="64pt" />

          <colspec align="center" colwidth="64pt" />

          <colspec align="center" />

          <colspec align="center" />

          <colspec align="center" />

          <thead>
            <row>
              <entry>Firewall</entry>

              <entry>lsrr</entry>

              <entry>ssrr</entry>

              <entry>rr</entry>

              <entry>timestamp</entry>

              <entry>all fragments</entry>

              <entry>'short' packets</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>iptables</entry>

              <entry>+</entry>

              <entry>+</entry>

              <entry>+</entry>

              <entry>+</entry>

              <entry>+</entry>

              <entry>-</entry>
            </row>

            <row>
              <entry>ipfilter</entry>

              <entry>-</entry>

              <entry>+</entry>

              <entry>+</entry>

              <entry>+</entry>

              <entry>+</entry>

              <entry>+</entry>
            </row>

            <row>
              <entry>pf</entry>

              <entry>-</entry>

              <entry>-</entry>

              <entry>-</entry>

              <entry>-</entry>

              <entry>+</entry>

              <entry>-</entry>
            </row>

            <row>
              <entry>Cisco PIX</entry>

              <entry>-</entry>

              <entry>-</entry>

              <entry>-</entry>

              <entry>-</entry>

              <entry>-</entry>

              <entry>-</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <informaltable frame="none">
        <tgroup cols="2">
          <colspec align="left" colwidth="150pt" />

          <tbody>
            <row>
              <entry><filename>Source route options: LSRR,
              SSRR</filename></entry>

              <entry>Normally IP routing is dynamic with each router
              making decisions about which next hop router to send the
              packet to. However, another option exists where the
              sender can choose the route. In the case of the Loose
              Source Route, the sender (host) can specify a list of
              routers the packet must traverse, but it may also pass
              through other routers between any two addresses in the
              list. The Strict Source Route works very much the same
              way, except the packet must traverse only through the
              specified addresses. Source routing can potentially be
              used to reach hosts behind the firewall even if these
              hosts use private IP addresses, which normally are not
              reachable over the Internet. </entry>
            </row>

            <row>
              <entry><filename>Record route option: RR</filename></entry>

              <entry>This option causes every router that handles the
              packet on the way to add its IP address to a list in the
              options field. This option is used by the ping utility
              when it is called with the "-R" command line switch; it
              can potentially be exploited to discover the internal
              network addressing and layout behind the
              firewall. Although the risk is low, some firewall
              administrators prefer to block packets with this option
              set. </entry>
            </row>

            <row>
              <entry><filename>Timestamp option:</filename></entry>

              <entry>This option tells routers that handle the packet
              to record their timestamps and sometimes addresses (like
              in the case of the record route option). This option is
              seldom used, but can potentially be exploited to gather
              information about the protected network, so some
              firewall administrators prefer to block packets with
              this option set. </entry>
            </row>

            <row>
              <entry><filename>Fragment options:</filename></entry>

              <entry>IP packets may sometimes become fragmented. This
		happens if the original datagram is larger than what a
		physical network layer can transmit. The IP packet
		header has special fields (called "Flags" and
		"Fragmentation Offset") that detect fragmented packets
		and help reassemble them. Many firewalls can check
		these bits as well. Certain combinations of flags and
		fragmentation offsets can never happen during normal
		operation but were seen to be used by attackers.
		Firewall Builder provides two options for handling the
		most commonly used cases: the "all fragments" option
		matches the second and further fragments, while the
		"short" option is used to match packets that are too
		short to contain even a complete IP header.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>Standard IP Service objects that come with Firewall Builder appear
      in the <guilabel>Standard</guilabel> tree, in the <guimenuitem>Services/IP</guimenuitem>
      branch.</para>

      <para>You can create your own IP Service objects in the <guilabel>User</guilabel> library.</para>


      <figure float="1" id="ip-service-dialog2">
        <title>Creating/Editing an IP Service Object</title>

            <graphic scale="50" fileref="ip_service_dialog2.png" />

      </figure>

      <para>Service objects in the <guilabel>Standard</guilabel> are
      not editable. However, you can copy-and-paste a copy of a
      service object into the <guilabel>User</guilabel> tree and edit
      it there, or you can right-click the <guilabel>IP</guilabel>
      folder in the <guilabel>User</guilabel> tree and
      select <guimenuitem>New IP Service</guimenuitem> to create a
      service object from scratch.</para>

      <para>In either case, the controls are the same.</para>

      <para>The IP Service dialog provides the following controls:</para>

      <para><itemizedlist spacing="compact">
          <listitem>
            <para>Name:</para>

            <para>This is the name of the object</para>
          </listitem>

          <listitem>
            <para>Protocol:</para>

            <para>This is the protocol number.</para>
          </listitem>

          <listitem>
            <para>DiffServ</para>

            <para>You can specify DSCP or TOS using the radio
            buttons. In either case, specify a code (or class) in the
            field. If you do not specify a code or class, Firewall
            Builder ignores the DiffServ type (DSCP or TOS).</para>
          </listitem>

          <listitem>
            <para>Options:</para>

            <para>These flags represent 'Options' flags in the IP
            header:</para>

            <para><simplelist>
                <member>lsrr (loose source route)</member>

                <member>ssrr (strict source route)</member>

                <member>rr (record route)</member>

                <member>timestamp</member>

                <member>all fragments</member>

                <member>short fragments</member>
              </simplelist></para>
          </listitem>

          <listitem>
            <para>Comments:</para>

            <para>This is a free-style text field used for comments.</para>
          </listitem>
        </itemizedlist></para>

      <sect3>
	<title>Using IP service objects in policy rules</title>

          <para>
                Consider the following IP Service objects:
          </para>
  

        <table frame='all'><title></title>
	<tgroup cols="2">
	  <tbody>
                <row>
        <entry>
        <inlinegraphic fileref="ip_service_2.png"/></entry>

        <entry>
        <inlinegraphic fileref="ip_service_5.png"/></entry>
                </row>

                <row>
        <entry>

        <inlinegraphic fileref="ip_service_3.png"/></entry>
                  
        <entry>
        <inlinegraphic fileref="ip_service_4.png"/></entry>
                </row>
	</tbody></tgroup></table>

          <para>
  
                Object <emphasis>EF</emphasis> has DSCP matching turned on, matching
                traffic class <emphasis>EF</emphasis>. Object <emphasis>TOS 0x10</emphasis> matches
                packets with TOS bits set to 0x10 (low delay).
                Object <emphasis>all_fragments</emphasis> has flag "all fragments"
                turned on, and finally object
                <emphasis>lsrr</emphasis> matches "loose source routing"
                option. Here is what we get for iptables when we use
                these objects in policy rules as follows:
              
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="ip_service_rule_1.png"/></figure>

          <para>
  
          </para>
  

  <screen>

# Rule 0 (global)
# 
$IPTABLES -N RULE_0
$IPTABLES -A FORWARD -p all  -f   -j RULE_0 
$IPTABLES -A FORWARD -p all  -m ipv4options  --lsrr  -j RULE_0 
$IPTABLES -A RULE_0  -j LOG  --log-level info --log-prefix "RULE 0 -- DENY "
$IPTABLES -A RULE_0  -j DROP 
# 
# Rule 1 (global)
# 
$IPTABLES -A FORWARD  -o + -p all  -m dscp --dscp-class EF  -m state \
--state NEW  -j ACCEPT 
$IPTABLES -A FORWARD  -o + -p all  -m tos --tos 0x10  -m state --state NEW  \
-j ACCEPT 

              </screen>

          <para>
  
                The compiler for iptables uses module <emphasis>ipv4options</emphasis>
                to match <emphasis>lsrr</emphasis>, command line option <emphasis>-f</emphasis> to
                match all fragments, module <emphasis>tos</emphasis> to match TOS
                and module <emphasis>dscp</emphasis> to match dscp class.
              
          </para>
  

          <para>
  
                When compiled for IPv6, these rules yield the
                following iptables commands:
              
          </para>
  

  <screen>

# Rule 0 (global)
# 
$IP6TABLES -N RULE_0
$IP6TABLES -A FORWARD  -m frag --fragmore  -j RULE_0 
$IP6TABLES -A RULE_0  -j LOG  --log-level info --log-prefix "RULE 0 -- DENY "
$IP6TABLES -A RULE_0  -j DROP 
# 
# Rule 1 (global)
# 
$IP6TABLES -A FORWARD  -o +  -m dscp --dscp-class EF  -m state --state NEW  -j ACCEPT 
$IP6TABLES -A FORWARD  -o +  -m tos --tos 0x10  -m state --state NEW  -j ACCEPT 

              </screen>

          <para>
  
                <emphasis>ip6tables</emphasis> does not have the command line
                flag <emphasis>-f</emphasis>, instead it uses module <emphasis>frag</emphasis> to
                match fragments. Firewall Builder currently does not support
                ip6tables module <emphasis>ipv6header</emphasis>, and source routing
                options do not exist in IPv6, so object "lsrr" cannot
                be used in rules.
              
          </para>
  

          <para>
  
                PF cannot match DSCP bits and source routing options
                but can match TOS. Trying the same IP Service object "tos 0x10"
                in policy rules for PF:
              
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="ip_service_rule_2.png"/></figure>

          <para>
  
          </para>
  

  <screen>

pass out  quick inet  from any  to (eth0)  tos 0x10 keep state

              </screen>

          <para>
  
                Cisco IOS access lists cannot match source route
                options but can match fragments and TOS and DSCP bits.
                Here is what we get if we try to compile the same
                rules using the same IP Service objects for Cisco IOS:
              
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="ip_service_rule_3.png"/></figure>

          <para>
  
          </para>
  

  <screen>

ip access-list extended e1_0_out
! 
! Rule  0 (global)
! 
  deny   ip any  any  log fragments 
! 
! Rule  1 (global)
! 
  permit ip any  any  tos 0x10
  permit ip any  any  dscp EF
exit

              </screen>

      </sect3>
    </sect2>

    <sect2>
      <title>Using ICMP and ICMP6 Service Objects   in Firewall Builder</title>

        <para>
  
                The ICMP Service object is a generalized
                representation of the ICMP protocol. ICMP packets
                are often used to communicate error messages that
                are acted upon by either the IP layer or higher
                layer protocols (TCP or UDP). ICMP can also be used
                as a simple query protocol.
              
  </para>
  

        <para>
  
                Firewall Builder has service objects for both IPv4
                and IPv6. ICMP Service objects for IPv6 are called
                ICMP6 Service. The standard ICMP Service objects
                that come with Firewall Builder appear in
                the <emphasis>Standard Objects</emphasis> library, in
                the <emphasis>Services/ICMP</emphasis> branch. User-defined ICMP
                and ICMP6 service objects will appear in the
                library <emphasis>User</emphasis> in the same <emphasis>Services/ICMP</emphasis>
                branch.
              
  </para>
  

        <para>
  
                Service objects in the Standard are not
                editable. However, you can copy-and-paste a copy of a
                service object into the User tree and edit it there,
                or you can right-click the ICMP folder in the User
                tree and select New ICMP Service to create a service
                object from scratch.
              
  </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="icmp_service_tree.png"/></figure>

        <para>
  
                As a firewall administrator, you need to understand
                the nature and purpose of ICMP in order to properly
                configure the firewall to block unwanted ICMP messages
                while permitting useful ones.
              
  </para>
  

        <para>
  
                ICMP packets have two header fields that distinguish
                particular ICMP messages: the type and code
                fields. There are many different types and classes of
                ICMP messages. See
                http://www.iana.org/assignments/icmp-parameters for
                IPv4 types and classes and
                http://www.iana.org/assignments/icmpv6-parameters
                (http://www.iana.org/assignments/icmpv6-parameters)
                for IPv6 types and classes. 
              
  </para>
  

        <para>
  
                Any combination of the <emphasis>type</emphasis> and <emphasis>code</emphasis>
                values is allowed in the ICMP or ICMP6 Object. For
                example the following two screen shots illustrate
                definitions of ICMP and ICMP6 objects for the
                request packet of well known ping protocol. The type
                codes are different for IPv4 and IPv6 variants,
                although the code is equal to 0 in both:
              
  </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="icmp_service_1.png"/></figure>

        <figure float="1"><title/><graphic scale="50" fileref="icmp6_service_1.png"/></figure>

        <para>
  
                Both ICMP and ICMP6 allow value "any" in type or
                code fields. For example, this can be used to build
                an object to match a family of ICMP messages with
                the same type but any code:
              
  </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="icmp_service_2.png"/></figure>

        <para>
  
                Both IPv4 and IPv6 ICMP Service dialogs provide the
                following controls:
              
  </para>
  

  <itemizedlist>

  <listitem><para>
  Name: This is the name of the object. 
                </para>
  </listitem>
  

                

  <listitem><para>
  ICMP Type and Code:
                  

  <itemizedlist>

  <listitem><para>
  Type: The ICMP message type. This control
                      consists of a numeric selector that lets you
                      specify the message type. To specify "any" type,
                      set the control to any.
                    </para>
  </listitem>
  

                    

  <listitem><para>
  Code: The ICMP message code. This control
                      consists of a numeric selector that lets you
                      specify the message code. To specify "any" code,
                      set the control to any.
                    </para>
  </listitem>
  
                  </itemizedlist></para>
  </listitem>
  

                

  <listitem><para>
  Comment: This is a free-style text field used
                  for comments.
                </para>
  </listitem>
  

              </itemizedlist>

  <sect3>
        <title>Using ICMP and ICMP6 Service Objects in Rules</title>

        <para>
  
                Consider the following rule where we use two ICMP
                objects, one for IPv4 and another for IPv6:
              
  </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="icmp_service_rule_1.png"/></figure>

        <para>
  
                If the rule set this rule belongs to is configured as
                combined IPv4 and IPv6, then policy compiler will pick
                ICMP service that matches address family on each
                separate pass, one for IPv4 and then for IPv6. Here is
                what we get for iptables:
              
	</para>
  

  <screen>
# ================ IPv4

# Rule 0 (global)
# 
$IPTABLES -A FORWARD  -i + -p icmp  -m icmp  --icmp-type 8/0 \
     -m state --state NEW  -j ACCEPT 
 
# ================ IPv6

# Rule 0 (global)
# 
$IP6TABLES -A FORWARD  -i + -p ipv6-icmp  -m icmp6 --icmpv6-type 128/0 \
     -m state --state NEW  -j ACCEPT 

              </screen>

        <para>
  
                Here is generated PF 4.x configuration:
              
	</para>
  

  <screen>

# Rule  0 (global)
# 
pass in   quick inet proto icmp  from any  to any icmp-type 8 code 0

# Rule  0 (global)
# 
pass in   quick inet6 proto icmp6  from any  to any

              </screen>
  </sect3>
    </sect2>

    <sect2 id="tcp-service">
      <title>TCP Service</title>


  

          <para>
  
                  The TCP Service object is a generalization of the
                  TCP protocol, which provides a connection-oriented
                  reliable byte stream service. Many well-known,
                  frequently used application protocols use TCP
                  protocol: FTP (File Transfer Protocol), SMTP (Simple
                  Mail Transfer Protocol), HTTP (Hyper Text Transfer
                  Protocol), and so on. The TCP header contains
                  special fields indicating source and destination port
                  numbers that are used to identify the sending and
                  receiving application. These two values, along with
                  the source and destination IP addresses in the IP
                  header, uniquely identify each connection.
                
          </para>
  

          <para>
  
                  Since port numbers are used to distinguish
                  applications using the data stream provided by the
                  TCP protocol, each application should use a unique
                  port number. To ensure interoperability, these
                  numbers must be assigned by a central authority in a
                  coordinated manner. Internet Assigned Numbers
                  Authority (IANA) does just that. Assigned TCP and
                  UDP port numbers can be looked up at
                  http://www.iana.org/assignments/port-numbers. Most
                  Unix systems also come with a /etc/services file that
                  contains a list of assigned port numbers.
                
          </para>
  

          <para>
  
                  Firewall Builder comes with a collection of
                  predefined TCP Service objects with port numbers
                  already configured. You can simply use these objects
                  in your policy rules, so you do not have to look up
                  port numbers every time you need them. These objects
                  are part of the <emphasis>Standard Objects</emphasis> library and
                  are located in the <emphasis>Services / TCP</emphasis> branch.
                
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="tcp_service_1_1.png"/></figure>

          <para>
  
                  The typical TCP Service object is represented in the
                  following screenshot:
                
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="tcp_service_1.png"/></figure>

          <para>
  
                In Firewall Builder, the TCP Service object is a
                generalization of TCP protocol. The TCP header of a
                packet carries only one fixed value for the source port
                and one fixed value for the destination port. The TCP
                Service object allows a range of values to be used for
                the source and destination ports. This allows a single
                TCP Service object to describe either a family of
                protocols using consecutive port numbers, or a
                protocol that may use variable port numbers or simply
                many protocols that use port numbers from a certain
                range. For example, on Unix systems, TCP sessions
                opened by a privileged process always have their
                source port number assigned from a range below 1024,
                while unprivileged processes use source port numbers
                from a range starting from 1024 and above. The TCP
                Service object with a source port range defined as
                shown in the following screenshot describes all
                privileged TCP sessions.
              
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="tcp_service_2.png"/></figure>

          <para>
  
                Using "0" as both start and end values for a range
                means "any value" for that range. The source port
                range of the "privileged TCP" object starts from 0 and
                ends at 1023 (port ranges are inclusive in Firewall
                Builder), while its destination port range's start and
                end are both set to zero, which means "any destination
                port". This object describes any TCP protocol with a
                source port in range 0-1023 and any destination port.
              
          </para>
  

          <para>
  
                If all you need is to create an object to describe the
                TCP protocol with a particular destination port, just
                use the same port number for both the start and end of
                a destination port range (which effectively creates a
                range that consists of a single value). The example in
                Figure 6-70 shows such a service.
              
          </para>
  

          <para>
  
                The TCP header also contains a collection of one-bit
                fields, or flags, that carry a variety of control
                information. For example, the SYN and ACK flags are
                used for connection establishment and the FIN flag is
                used for connection termination. Certain combinations
                of flags are not allowed during the normal protocol
                operation and may cause unpredicted reactions in some
                systems; because of this, the firewall administrator
                may want to block TCP packets with unwanted
                combination of flags.
              
          </para>
  

          <para>
  
                There are six flags in the TCP header. We just briefly
                mention them here; more information can be found in
                TCP/IP Illustrated, vol 1 by W. Richard Stevens,
                chapter 17.
              
          </para>

      <informaltable frame="none">
        <tgroup cols="2">
          <colspec align="center" colwidth="64pt" />

          <colspec align="left" />

          <tbody>
            <row>
              <entry><filename>U (URG)</filename></entry>

              <entry>The "urgent" pointer is valid</entry>
            </row>

            <row>
              <entry><filename>A (ACK)</filename></entry>

              <entry>The acknowledgment number is valid</entry>
            </row>

            <row>
              <entry><filename>P (PSH)</filename></entry>

              <entry>The receiver should pass this data to the application as
              soon as possible</entry>
            </row>

            <row>
              <entry><filename>R (RST)</filename></entry>

              <entry>Reset the connection</entry>
            </row>

            <row>
              <entry><filename>S (SYN)</filename></entry>

              <entry>Synchronize sequence numbers to initiate a
              connection.</entry>
            </row>

            <row>
              <entry><filename>F (FIN)</filename></entry>

              <entry>The sender is finished sending data.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

          <para>
  
                "Established" is not a TCP flag. Instead,
                checking this box causes the firewall to match any
                packet in an established session. Checking this
                checkbox disables the other TCP flag controls.
              
          </para>
  

          <para>
  
                Firewall Builder supports all six flags, although not
                all target firewall platforms can match all
                combinations of TCP flags or any flags at all. For
                example, iptables, pf, ipfilter and ipfw can match
                flags and their combinations, but Cisco PIX cannot.
              
          </para>
  

          <para>
  
                Usually the firewall cannot only match a combination
                of flags, but can also examine only a given subset of
                TCP flags. Firewall Builder provides two sets of
                checkboxes for TCP flags and flag masks (see
                screenshot below). Checkboxes in the first row control
                TCP flags that we want the firewall to examine and
                checkboxes in the second row tell it whether they
                should be set or cleared. Only flags whose checkboxes
                in the first row are set will be looked at by the
                firewall. (If you check a box in the bottom row while
                leaving the checkbox above it unchecked, the flag will
                be ignored.)
	  </para>

	  <para>
            The object in the screenshot matches a TCP packet with any
            combination of port numbers, the TCP flag SYN set, and all
            other flags cleared. The firewall will examine all TCP
            flags.
              
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="tcp_service_3.png"/></figure>

          <para>
  
                A Combination of flags and a mask can be used in a rule
                that looks for some flags to be set or unset and
                ignores other ones regardless of their state. For
                example, we can create a rule that detects a so called
                "null scan" which is done using TCP packets with all
                flags cleared. For this rule we create a TCP Service
                object "tcp null scan" where all flag masks are set but
                all TCP flags are cleared. This means we examine all
                flags but only match them if they are all cleared. This
                object is represented in the following screenshot:
              
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="tcp_service_4.png"/></figure>

          <para>
  
TCP Service dialog provides the following controls: 
              
          </para>
  

          <para>
  
                
          </para>
  

  <itemizedlist>

  <listitem>        <para>
  Name:  This is the name of the object 
                          </para>
  </listitem>
  

                  

  <listitem>        <para>
  Source port range: These two controls define the
                    start and end of the source port range. They
                    accept values 0 through 65535.
                          </para>
  </listitem>
  

                  

  <listitem>        <para>
  Destination port range: These two controls define
                    the start and end of the destination port
                    range. They accept values 0 through 65535.
                          </para>
  </listitem>
  

                  

  <listitem>        <para>
  TCP Flags: TCP flags and masks, see above. The
                    Established checkbox causes the firewall to match
                    packets in established sessions. Selecting this
                    checkbox disables the other TCP flag controls.
                          </para>
  </listitem>
  

                  

  <listitem>        <para>
  Comments: This is a free-style text field used
                  for comments.
                          </para>
  </listitem>
  
                </itemizedlist>

<sect3>
        <title>Using TCP Service in rules</title>

  


    <sect4>
        <title>Single destination TCP port</title>

          <para>
  
                Let's start with an example of using simple TCP service
                that describes HTTP protocol. Both the beginning and
                the end of the source port range in this service
                object are set to "0" which means the program will
                leave these out when it generates target firewall
                configuration.  The destination port range is defined
                as "80-80" which means the object describes just
                single destination tcp port "80". All flag checkboxes
                are unchecked which means no flag-matching
                configuration will be generated.
              
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="tcp_service_5.png"/></figure>

          <para>
  
                Now we put this object in the "Service" element of a
                rule as shown on the next screenshot. To make this
                trivial example just a little bit more interesting, 
                we configured the policy rule set as "Combined IPv4 and IPv6"
                and put two address objects in destination, one is IPv4
                address and another is IPv6 address.
              
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="tcp_service_rule_1.png"/></figure>

          <para>
  
                This rule compiles into the following for iptables:
              
          </para>
  

  <screen>

# ================ IPv4

# Rule 0 (global)
# 
$IPTABLES -A FORWARD -p tcp -m tcp  -d 70.85.175.170 \
     --dport 80  -m state --state NEW  -j ACCEPT 

# ================ IPv4

# Rule 0 (global)
# 
$IP6TABLES -A FORWARD -p tcp -m tcp  -d 2001:470:1f0e:162::2 \
     --dport 80  -m state --state NEW  -j ACCEPT 
              </screen>

          <para>
  
                And for PF we get the following. Note that PF version
                was set to "any" or "3.x", this is why "keep state"
                was added. "Keep state" is default for PF 4.x and if
                version was configured as "4.x" in this firewall
                object, policy compiler would have dropped "keep
                state" from generated configuration.
              
          </para>
  

  <screen>
# Rule  0 (global)
# 
pass in   quick inet proto tcp  from any  to 70.85.175.170 port 80 keep state
pass out  quick inet proto tcp  from any  to 70.85.175.170 port 80 keep state

# Rule  0 (global)
# 
pass in   quick inet6 proto tcp  from any  to 2001:470:1f0e:162::2 port 80 keep state
pass out  quick inet6 proto tcp  from any  to 2001:470:1f0e:162::2 port 80 keep state

              </screen>
    </sect4>
    <sect4>
        <title>Source port range</title>

          <para>
  
                In the next example we look at the TCP service object
                that defines specific source port range to match
                source ports greater than or equal to 1024:
              
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="tcp_service_6.png"/></figure>

          <para>
  
                Using this object in a rule as follows:
              
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="tcp_service_rule_2.png"/></figure>

          <para>
  
                To make the rule slightly more realistic, we made it
                stateless using its options dialog (double-click in
                the column "Options" of this rule and check checkbox
                "Stateless" in the first tab of the dialog). Let's see
                what the program generates when this rule is compiled
                for iptables:
              
          </para>
  

  <screen>

# Rule 0 (global)
# 
$IPTABLES -A FORWARD  -i + -p tcp -m tcp  --sport 1024:65535  -j ACCEPT 

              </screen>

          <para>
  
                Here is what is generated for PF 3.x:
              
          </para>
  

  <screen>
# Rule  0 (global)
# 
pass in   quick inet proto tcp  from any port &gt;= 1024  to any
              </screen>

          <para>
  
                And for PF 4.x we get "no state" because the rule is
                stateless and state matching is the default in PF 4.x:
              
          </para>
  

  <screen>

pass in   quick inet proto tcp  from any port &gt;= 1024  to any no state

              </screen>

          <para>
  
                Cisco IOS access list statement looks like this:
              
          </para>
  

  <screen>

ip access-list extended e1_1_in
! 
! Rule  0 (global)
! 
  permit tcp any  gt 1024 any  
exit

              </screen>
    </sect4>
    <sect4>
        <title>Established</title>

          <para>
  
                Some of the supported firewalls understand special
                flag "established" intended to match reply packets of
                the TCP session. Stateless systems, such as Cisco IOS
                extended access lists, match combination of tcp flags
                where flag "ACK" is set but flag "SYN" is cleared when
                this keyword is used in the acl rule. Stateful
                firewalls such as iptables or PF offer much better way
                to track and match reply packets because they can
                follow the states a tcp session goes through when it
                is opened, data transferred and finally session is
                closed. Firewall Builder provides an option of using
                flag "established" but supports it only for those
                firewall platforms where there is no better
                alternative. Attempt to use TCP service object with
                this flag set in rules for the firewall that supports
                stateful inspection causes an error.
              
          </para>
  

          <para>
  
                Here is an example of the TCP service object with flag
              "Established" set and source port range "80-80", that
              is, this object describes TCP packets coming from the
              web server operating on the standard port 80 back to the
              client.
              
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="tcp_service_7.png"/></figure>

          <para>
  
                Using this object in a rule:
              
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="tcp_service_rule_3.png"/></figure>

          <para>
  
                Here is the access list generated for Cisco IOS:
              
          </para>
  

  <screen>
ip access-list extended e1_0_in
! 
! Rule  0 (global)
! 
  permit tcp any  eq 80 any  established 
! 
              </screen>

          <para>
  
                Here we have source port specification "eq 80" and
                keyword "established"
              
          </para>
  

          <para>
  
                Attempt to compile this rule for iptables or PF causes an error:
              
          </para>
  

  <screen>

Error (pf): TCPService object with option "established" is not supported 
   by firewall platform "pf". Use stateful rule instead.

              </screen>
	</sect4>
      </sect3>
    </sect2>

    <sect2>
      <title>UDP Service</title>

          <para>
  
                The UDP Service object is a generalization of the UDP
                protocol, which is a connectionless transport layer
                protocol. Many well-known applications use UDP as
                their transport, such as DNS (Domain Name System),
                DHCP (Dynamic Host Configuration Protocol), NTP
                (Network Time Protocol), and SNMP (Simple Network
                Management Protocol)..
              
          </para>
  

          <para>
  
                As in TCP, UDP uses port numbers to distinguish
                applications from one another. The UDP packet header
                carries two port numbers: the source port and the
                destination port. The UDP Service object in Firewall
                Builder allows for a definition of ranges for both the
                source and the destination ports. The meaning of
                values assigned to the start and end of the range is
                the same as in the TCP Service object: ranges are
                inclusive, that is, both start and end ports of the
                range are included. Using "0" for both the start and
                end of the range means "any port". These rules work
                for both the source and destination ranges. The
                following screenshot shows the "dns" UDP Service
                object that represents the Domain Name System protocol
                which uses destination port 53.
              
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="udp_service_1.png"/></figure>

          <para>
  
                Service objects in the Standard are not
                editable. However, you can copy-and-paste a copy of a
                service object into the User tree and edit it there,
                or you can right-click the ICMP folder in the User
                tree and select New ICMP Service to create a service
                object from scratch.
              
          </para>
  

          <para>
  
                The UDP Service dialog provides the following controls: 
              
          </para>
  

          <para>
  
                
          </para>
  

  <itemizedlist>

  <listitem>        <para>
  Name: This is the name of the object 
                          </para>
  </listitem>
  

                  

  <listitem>        <para>
  The Source port range: These two controls define
                    the start and the end of the source port
                    range. They accept values 0 through 65535.
                          </para>
  </listitem>
  

                  

  <listitem>        <para>
  The Destination port range: These two controls
                    define the start and the end of the destination
                    port range. They accept values 0 through 65535.
                          </para>
  </listitem>
  

                  

  <listitem>        <para>
  Comments: This is a free-style text field used for comments. 
                          </para>
  </listitem>
  
                </itemizedlist>

     <sect3>
        <title>Using UDP Service in rules</title>

  

       <sect4>
        <title>Single destination UDP port</title>

          <para>
  
                In this example we'll use the UDP service object
                "domain" shown on screenshot above. The rule looks
                like this:
              
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="udp_service_rule_1.png"/></figure>

          <para>
  
                Here is iptables command generated for this rule:
              
          </para>
  

  <screen>

# Rule 0 (global)
# 
$IPTABLES -A FORWARD  -i + -p udp -m udp  --dport 53  -m state --state NEW  -j ACCEPT 

              </screen>

          <para>
  
                This rule got a <emphasis>"-i +"</emphasis> clause because direction
                was set to <emphasis>Inbound</emphasis> but <emphasis>"Interface"</emphasis>
                column was left empty. To enforce inbound direction
                compiler uses "-i" option but since interface was not
                specified, the rule got attached to all interfaces
                which is defined by the <emphasis>+</emphasis>.
              
          </para>
  

          <para>
  
                Here is generated PF 4.x configuration:
              
          </para>
  

  <screen>

# Rule  0 (global)
# 
pass in   quick inet proto udp  from any  to any port 53

              </screen>

          <para>
  
                In the pf configuration, direction is defined by
                the <emphasis>"in"</emphasis> keyword, and since no interface was
                requested, there is no <emphasis>"on &lt;interface&gt;"</emphasis>.
              
          </para>
  

          <para>
  
                Generated Cisco access list statement is quite trivial:
              
          </para>
  

  <screen>

ip access-list extended fe0_0_in
! 
! Rule  0 (global)
! 
  permit udp any  any  eq 53 
! 
exit
              </screen>

       </sect4>

       <sect4>
        <title>Source port range</title>

          <para>
  
                The following UDP service object defines source port
                range of the ports with values greater than or equal to 1024:
              
          </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="udp_service_2.png"/></figure>

          <para>
  
                Using this object in policy rule yields the following
                code for iptables:
              
          </para>
  

  <screen>
# Rule 0 (global)
# 
$IPTABLES -A FORWARD  -i + -p udp -m udp  --sport 1024:65535  -m state \
--state NEW  -j ACCEPT 

              </screen>

          <para>
  
                And for PF:
              
          </para>
  

  <screen>

# Rule  0 (global)
# 
# 
pass in   quick inet proto udp  from any port &gt;= 1024  to any

              </screen>

          <para>
  
                Cisco access list statement:
              
          </para>
  

  <screen>

ip access-list extended e1_0_in
! 
! Rule  0 (global)
! 
  permit udp any  gt 1024 any  
!
exit
              </screen>
       </sect4>
     </sect3>
    </sect2>

    <sect2 id="user-service">
      <title>User Service</title>

	<para>User Service object matches the owner of the process on
	the firewall that send the packet. It translates to the
	"owner" match in iptables and "user" parameter for PF.</para>

      <figure float="1" id="user-service-dialog">
          <title>User Service Dialog</title>
              <graphic scale="70" fileref="user_service_2.png" />
        </figure>

<itemizedlist spacing="compact">
          <listitem>
            <para>Name:</para>

            <para>This is the name of the object</para>
          </listitem>

          <listitem>
            <para>User id</para>

            <para>The user ID of the user account on the firewall device that the firewall should use to match packets.</para>
          </listitem>

          <listitem>
            <para>Comments:</para>

            <para>This is a free-style text field used for comments.</para>
          </listitem>
        </itemizedlist>

	<para> User Service object has only one parameter besides the
	name and comment: it is user id that the firewall should use
	to match packets.</para>

	<para>The User Service object is only supported for iptables and PF.</para>

	<para>Let's look at how the simple rule shown in <xref linkend="user-service-rule" /> compiles for iptables and PF.</para>
 
      <figure float="1" id="user-service-rule">
          <title>User Service Rule Example</title>
              <graphic scale="70" fileref="user_service_3.png" />
        </figure>

	<para>The firewall can associate a packet with a user only if
	the packet originated on the firewall. Packets that transit
	the firewall have no information about the user who owned the
	process that created these packets and sent them out because
	this process ran on an entirely different computer. For this
	reason, the object in the <guilabel>Source</guilabel> column
	must be the firewall.</para>

       <figure float="1" id="user-service-iptables">
        <title>User Service, iptables compile output</title>
            <screen>
# Rule 0 (global)
# 
$IPTABLES -A OUTPUT -m owner --uid-owner 500  -j DROP 
	</screen>
      </figure>

      <para> The User Service translated into
      the <emphasis>owner</emphasis> match for iptables. See the
      iptables man page for a more detailed explanation of this
      match.</para>

       <figure float="1" id="user-service-pf">
        <title>User Service, PF compile output</title>
            <screen>
# Tables: (1)
table  { en0 , 192.168.1.1 }

# Rule  0 (global)
# 
# 
block out  quick inet  from   to any user 500 
	</screen>
      </figure>

      <para>Here the table <emphasis>tbl.r0.s</emphasis> was created
      to hold IP addresses that belong to the firewall. The rule
      matches source addresses and also the user ID of the owner using
      the "user" clause.</para>

      <para>User Service is actually one of the simplest service
      object types in Firewall Builder, but it provides the facility
      for a basic per-user control on Linux and BSD machines. This
      service object can be used in rules with actions that reroute
      packets ("Route" action) or in the NAT rules, for example to
      redirect web access via proxy.</para>

    </sect2>

    <sect2 id="custom-service">
      <title>Custom Service</title>

        <para>
  
                  The Custom Service object can be used to inject
                  arbitrary code into the generated firewall
                  script. Any combination of options allowed in the
                  target firewall command line language that does not
                  fit into a strict model of standard service object
                  types can be expressed using the Custom Service
                  object. For example, iptables comes with a
                  collection of modules that adds an ability to match
                  complex combinations of packet parameters or header
                  fields that are not supported by a standard
                  code. One of the modules adds the ability to match
                  any string in the packet's payload which can be
                  quite useful to quickly build firewall rule to block
                  some new protocol that uses non-specific combination
                  of ports and other parameters. This ability is
                  sometimes used to write rules to block network
                  trojans or viruses with known signatures.
                
        </para>
  

        <para>
  
                  The following screenshot represents a Custom Service
                  object that uses the capabilities of
                  the <emphasis>string</emphasis> module. Command line options
                  specific for this module are in the "Code String"
                  field.
                
        </para>
  

        <note><para>
                  Note: The code specified in the Custom Service is
                  used literally; no validation is done either by
                  Firewall Builder GUI or the policy compilers.
                      </para></note>
  

        <figure float="1"><title/><graphic scale="60" fileref="custom_service_1.png"/></figure>

        <para>
  
                  The Custom Service dialog provides the following controls: 
                
        </para>
  

  <itemizedlist>

  <listitem><para>
  Name: This is the name of the object. 
                        </para>
  </listitem>
  

                  

  <listitem><para>
  Platform: This is a pull-down menu that shows a
                  list of all firewall platform targets available in
                  Firewall Builder.
                        </para>
  </listitem>
  

                  

  <listitem><para>
  Code String: This is a line of code in the
                  target firewall language. (This is the heart of the
                  Custom Service object.)
                        </para>
  </listitem>
  

                  

  <listitem><para>
  Protocol Name: Use this if you want to restrict
                    the Custom Service Object to a particular
                    protocol: TCP, UDP, or ICMP. Default is "any". For
                    example, if this field is set to "tcp", then
                    policy compiler for iptables generates command
                    with parameter "-p tcp" and then inserts code
                    defined in the "Code String" field of the custom
                    service object.
                        </para>
  </listitem>
  

                  

  <listitem><para>
  Address Family: Specify IPv4 or IPv6. Policy
                  compilers use information about address family to
                  properly use the object while compiling IPv4 or IPv6
                  rule sets.
                        </para>
  </listitem>
  

                  

  <listitem><para>
  Comments: This is a free-style text field used for comments. 
                        </para>
  </listitem>
  
                </itemizedlist>

  <sect3>
        <title>Using Custom Service Object in Rules</title>

        <para>
  
                  The following example uses iptables module
                  "recent". Quoting from the iptables manual, this module
                  "allows you to dynamically create a list of IP
                  addresses and then match against that list in a few
                  different ways". We can use this module to throttle
                  brute-force ssh scanning attacks where an attacker
                  repeatedly connects to the ssh daemon trying to
                  guess login name and password. The full explanation
                  of how to use Custom Service object in combination
                  with <emphasis>swatch</emphasis> script on Linux to stop these
                  attacks can be found in the Firewall Builder
                  Cookbook (<xref linkend="cookbook" />). Here we focus only on the Custom Service
                  object and iptables rules that can be obtained with
                  it.
                
        </para>
  

        <figure float="1"><title/><graphic scale="60" fileref="custom_service_2.png"/></figure>

        <para>
  
                  The code string defined in this object is "--dport
                  22 -m recent --set". This matches port 22 (ssh),
                  activates the module and adds source address of the
                  packet to the default list maintained by the module.
                
        </para>
  

        <para>
  
                  The second Custom Service object also matches port
                  22 and checks if the address is already on the list
                  and was seen during the past 1 minute twice:
                
        </para>
  

        <figure float="1"><title/><graphic scale="60" fileref="custom_service_3.png"/></figure>

        <para>
  
                  Note that our goal is to match protocol ssh (tcp
                  port 22) and at the same time activate iptables
                  module "recent" and add some parameters for it.
                  Both are done by means of a service object in
                  fwbuilder, however placing two service objects in
                  the "Service" field of a rule joins them by OR. That
                  is, if we were to put TCP service object "ssh" and
                  Custom Service object that defines parameter for
                  module "recent" in the "Service" field of the same
                  rule, we would end up with two iptables commands,
                  one matching tcp port 22 and another trying to use
                  module "recent". Since we need to match both in the
                  same rule, we have to add "--dport 22" to the code
                  defined in the Custom Service object.
                
        </para>
  

        <para>
  
                  Now, the rules using these objects:
                
        </para>
  

        <figure float="1"><title/><graphic scale="60" fileref="custom_service_rule_1.png"/></figure>

        <para>
  
                  Here are the iptables commands generated for these two
                  rules:
                
        </para>
  

  <screen>

# Rule 0 (global)
# 
$IPTABLES -N In_RULE_0
$IPTABLES -A INPUT  -i + -p tcp -m tcp  --dport 22 \
      -m recent --rcheck --seconds 60 --hitcount 2  -j In_RULE_0 
$IPTABLES -A In_RULE_0   -j LOG  --log-level info --log-prefix "RULE 0 -- DENY "
$IPTABLES -A In_RULE_0  -j DROP 
# 
# Rule 1 (global)
# 
$IPTABLES -A INPUT  -i + -p tcp -m tcp  --dport 22 -m recent --set \
      -m state --state NEW  -j ACCEPT 
# 

                </screen>

        <para>
  
                  First, we match port 22 and check if we have seen
                  this source address during the past minute at least 2
                  times. If yes, module "recent" returns a match and the
                  packet matches the first iptables rule. Iptables
                  passes control to the rules in chain "In_RULE_0"
                  where the packet is logged and dropped. If the
                  packet does not match the conditions set for the module
                  "recent", it does not match the first iptables rule
                  and will be inspected by the next one (generated for
                  the original rule #1). If this is the opening packet
                  of a new session, it matches state "NEW" and will be
                  permitted. Since module "recent" was also called in
                  this rule, the source address of the packet was
                  added to the internal table of the module "recent"
                  so it can be used in the previous iptables rule.
                
        </para>
  

        <para>
  
                  Custom Service allows you to inject arbitrary
                  strings into the generated firewall configuration in
                  the place where normally port matching
                  occurs. Another feature in Firewall Builder that
                  also allows for insertion of a code in the generated
                  code is Custom Action. The combination of Custom Service
                  with Custom Action provides for a very flexible
                  system where you can compose pretty much any
                  required configuration line if it is not otherwise
                  supported by the standard means. Suppose instead of
                  just dropping ssh scan connections coming to our
                  system we want to slow them down, thus tying up the 
                  attacker's resources. Iptables has a target just for
                  that called TARPIT. Unfortunately this target
                  is specific for iptables and is absent on other
                  firewalls supported by fwbuilder and it did not make
                  sense to introduce a standard action for it. However,
                  Custom Action is the mechanism we can use to
                  generate iptables command with this target. Here is
                  the rule, the action in it was set to "Custom
                  Action". Double-clicking on the action in the rule
                  opens a dialog with its parameters (if any). Custom
                  Action has one parameter, it is a freestyle string
                  where you enter the code you want to appear in the 
                  generated command:
                
        </para>
  

        <figure float="1"><title/><graphic scale="50" fileref="custom_service_rule_2.png"/></figure>

        <para>
  
                  Here is what we now get when we compile this policy
                  for iptables:
                
        </para>
  

  <screen>

# 
# Rule 0 (global)
# 
$IPTABLES -N In_RULE_0
$IPTABLES -A INPUT  -i + -p tcp -m tcp  --dport 22 \
      -m recent --rcheck --seconds 60 --hitcount 2  -j In_RULE_0 
$IPTABLES -A In_RULE_0   -j LOG  --log-level info --log-prefix "RULE 0 -- CUSTOM "
$IPTABLES -A In_RULE_0 -j TARPIT
# 
# Rule 1 (global)
# 
$IPTABLES -A INPUT  -i + -p tcp -m tcp  --dport 22 -m recent --set \
      -m state --state NEW  -j ACCEPT 
# 

                </screen>

        <para>
  
                  Now the first rule ends up sending the packet to the
                  "TARPIT" target rather than to "DROP", which is what we wanted.
                
        </para>
  </sect3>
    </sect2>
  </sect1>

  <sect1 id="time-interval-objects">
    <title>Time Interval Objects</title>

      <para>Time Interval objects allow you to create a rule that only
      matches during certain periods of time, such as on weekend days,
      during work hours, or other periods. Time intervals operate
      based on the time as known <emphasis>by the firewall
      device</emphasis>.</para>

      <figure float="1" id="time-interval2">
          <title>Time Interval dialog</title>
              <graphic scale="60" fileref="time-interval2.png" />
        </figure>

      <para>Time intervals can be certain days of the week (only on
      Mondays, for example), only certain times, and/or only during a
      certain range of dates. You can combine these options to create
      an object that represents, for example, Tuesday afternoons from
      1 to 3 PM during March of 2011.</para>

      <itemizedlist spacing="compact">
        <listitem>
            <para>Name:</para>

            <para>This is the name of the object.</para>
          </listitem>

          <listitem>
            <para>Start date checkbox:</para>

            <para>Indicates that the time interval has a starting
            date. If this is not checked, the <guilabel>Start
            date</guilabel> field is inaccessible and is not included
            in the object.</para>
          </listitem>

          <listitem>
            <para>Start date:</para>

            <para>Indicates the day the time interval will start.</para>
          </listitem>

          <listitem>
            <para>Start time:</para>

            <para>Indicates the beginning of the daily interval. Only
            applies to days after <guilabel>Start date</guilabel> (if
            specified) and before <guilabel>End date</guilabel> (if
            specified) and on indicated days of the week. For example,
            if <guilabel>Sunday</guilabel> is not checked, then the
            time interval does not apply on Sundays.</para>
          </listitem>

          <listitem>
            <para>End date checkbox:</para>

            <para>Indicates that the time interval has an ending
            date. If this is not checked, the <guilabel>End
            date</guilabel> field is inaccessible and is not included
            in the object.</para>
          </listitem>

          <listitem>
            <para>End date:</para>

            <para>Indicates the day the time interval will end.</para>
          </listitem>

          <listitem>
            <para>End time:</para>

            <para>Indicates the end of the daily interval. Only
            applies to days after <guilabel>Start date</guilabel> (if
            specified) and before <guilabel>End date</guilabel> (if
            specified) and on indicated days of the week. For example,
            if <guilabel>Sunday</guilabel> is not checked, then the
            time interval does not apply on Sundays.</para>
          </listitem>

          <listitem>
            <para>Mon, Tue, Wed, Thu, Fri, Sat, Sun</para>

            <para>Indicates on which days of the week the time
            interval should be applicable. For example,
            if <guilabel>Mon</guilabel> is checked
            and <guilabel>Tue</guilabel> is not, then the time
            interval object will apply to Mondays, but not
            Tuesdays.</para>
          </listitem>

          <listitem>
            <para>Comments:</para>

            <para>This is a free-style text field used for comments.</para>
          </listitem>
        </itemizedlist>

	<para>In <xref linkend="time-interval2" />, the object would
	be valid from the beginning of Dec. 19, 2009 and end the
	beginning of Jan. 4, 2010. This would hypothetically
	correspond to a "winter break" at some institution when access
	to some networks would be restricted.</para>

	<para>Another possibility is to limit recreational activities to non-work hours.</para>

      <figure float="1" id="time-interval1">
          <title>Time Interval rule example</title>
              <graphic scale="50" fileref="time-interval1.png" />
        </figure>

      <para>In this rule, the "quake" protocol is allowed from the
      internal network after hours and during weekends. Otherwise, the
      final "deny all" rule in the rule set would prevent it during
      other times (during work hours).</para>
   </sect1>

   <sect1 id="new-library">
    <title>Creating and Using a User-Defined Library of Objects</title>

      <para>The User library that comes with Firewall Builder is all
      you need if you're the only one administering firewalls in your
      enterprise. But, if you have several administrators, each with a
      different workstation, then you may want to create a user
      library that you can distribute. That way, user-defined objects
      only have to be created once, by one person.</para>

      <para>Let's create and distribute a simple user-defined
      library. Start by selection <guimenuitem>New Object/New
      Library</guimenuitem> from the <guimenu>Object</guimenu>
      menu.</para>

      <para>The library pull-down menu switches to <guilabel>New
      Library</guilabel>, which is empty by default, except for the
      standard folders.</para>

      <figure float="1" id="user-defined-library1">
          <title>A new, empty user-defined library</title>
              <graphic scale="70" fileref="user-defined-library1.png" />
        </figure>

      <para>Click on the New Library icon to bring up the library dialog.</para>

      <figure float="1" id="user-defined-library2">
          <title>Library dialog</title>
              <graphic scale="70" fileref="user-defined-library2.png" />
        </figure>

      <para>The Library dialog has three controls: Name, Color, and
      Comments. Enter a new name for the library in the Name
      field. (Here we are calling it ACME Library.) If you want, you
      can also specify a color for the library. This helps you notice
      when you're in that particular library. In this case, we have
      set the color to a shade of blue.</para>

      <figure float="1" id="user-defined-library3">
          <title>ACME library with blue background</title>
              <graphic scale="70" fileref="user-defined-library3.png" />
        </figure>

      <para>Use the normal object creation procedures to create
      objects in the library. Here we have created a Web server object
      with a interface that has a dynamically assigned IP
      address. We've also created a network object for the
      192.168.3.0/24 subnet.</para>

      <figure float="1" id="user-defined-library4">
          <title>Library with user-created objects</title>
              <graphic scale="70" fileref="user-defined-library4.png" />
        </figure>

      <para>Click <guimenuitem>File/Save</guimenuitem> to save the object file.</para>

      <para>To export the library to a file,
      select <guimenuitem>File/Export Library</guimenuitem>. The
      following dialog appears:</para>

      <figure float="1" id="user-defined-library5">
          <title>Export your library</title>
              <graphic scale="70" fileref="user-defined-library5.png" />
        </figure>

      <para>If you want to make the library read-only, leave
      the <guilabel>Make exported libraries read-only</guilabel>
      checked. Otherwise, uncheck it.</para>

      <para>Click <guibutton>OK</guibutton>.</para>

      <para>A file system Save dialog appears. Here you can specify a
      name and location for the file. Be sure the file has
      a <emphasis>.fwl</emphasis> file extension.</para>

      <figure float="1" id="user-defined-library6">
          <title>Save dialog box</title>
              <graphic scale="60" fileref="user-defined-library6.png" />
        </figure>

      <para>You can now move or email the library to someone else.</para>

      <para>To load a library, copy the file to the directory where
      you have Firewall Builder store your object files. Then,
      select <guimenuitem>Import Library</guimenuitem> from the
      Firewall Builder <guimenu>File</guimenu> menu. (You may have to
      restart Firewall Builder to get it to locate the file. Until
      then, the "Import Library" option may be grayed out.)</para>
      
     <para>You can now use this library like any other library. Keep
     in mind that changes to one copy of the user-defined library has
     no effect on other copies. To propagate changes, you have to
     redistribute the library.</para>
   </sect1>

   <sect1 id="find-replace">
    <title>Finding and Replacing Objects</title>

      <para>Imagine you have an access policy that looks something like this:</para>

      <figure float="1" id="find-replace1">
          <title>Policy before the Find/Replace</title>
              <graphic scale="70" fileref="find-replace1.png" />
        </figure>

      <para>Further, imagine that you are reassigning all the IP
      addresses in 192.168.2.0/24 to be in the 192.168.3.0/24 subnet
      and that you need to modify the firewall rules to match.</para>

      <para>One way to handle this is to manually browse through every
      rule in your firewall, removing the .2.0 addresses where you
      find them and replacing them with the equivalent .3.0
      addresses. Or, you could do a Find and Replace.</para>

      <para>Select <guimenuitem>Find Object</guimenuitem> from
      the <guimenu>Object</guimenu> menu to open the Find and Replace
      dialog, shown here:</para>

            <figure float="1" id="find-replace2">
          <title>Find/Replace dialog</title>
              <graphic scale="50" fileref="find-replace2.png" />
        </figure>

            <para>To replace every net-192.168.2.0 object with the
              net-192.168.3.0 object, first create the new network
              object. Then, drag (or Copy/Paste) a net-192.168.2.0
              object into the <guilabel>Find object</guilabel> field
              and the net-192.168.3.0 object into
              the <guilabel>Replace object</guilabel> field. Then, set
              the <guilabel>Scope for search and replace</guilabel>
              pull-down menu to <guimenuitem>policy of the opened
              firewall</guimenuitem>, as shown here:</para>

            <figure float="1" id="find-replace3">
          <title>Objects to find and replace</title>
              <graphic scale="50" fileref="find-replace3.png" />
        </figure>

      <para>Click <guibutton>Replace All</guibutton> to replace all instances.</para>

            <figure float="1" id="find-replace4">
          <title>Policy with objects replaced</title>
              <graphic scale="60" fileref="find-replace4.png" />
        </figure>

      <para>The Find object dialog has a number of controls you can use to constrain your searches:</para>

      <itemizedlist>
        <listitem>
            <para>Object parameter pull-down menu</para>

            <para>Allows you to specify how you search for
            objects. You can search by Name (usable on all objects),
            Address (usable on all addressable objects), TCP/UDP port
            (usable on TCP and UDP objects), Protocol Number (usable
            on IP service objects) and ICMP type (usable on ICMP
            service objects).</para>
          </listitem>

          <listitem>
            <para>Text field</para>

            <para>The text field is populated automatically if you
            drag an object into the Find object field. Otherwise, you
            can type the text in manually.</para>
          </listitem>

          <listitem>
            <para>Use regular expressions</para>

            <para>Checking the <guilabel>Use regular
            expressions</guilabel> checkbox causes the text field to
            be interpreted as a Perl regular expression. You can only
            do searches based on a regular expression. You cannot do
            replaces based on a regular expression.</para>
          </listitem>

          <listitem>
            <para>Search field</para>

            <para>Drag an object into the field to find instances of that object.</para>
          </listitem>

          <listitem>
            <para>Replace field</para>

            <para>Drag an object into the field to use it as the replacement object in a search and replace.</para>
          </listitem>

          <listitem>
            <para>Scope of search and replace</para>

            <para>Allows you to specify whether a search or search and
            replace will cover just the object tree, the tree and the
            policies of all firewalls in the object file, just the
            policies in the object file, or just the current open
            policy.</para>
          </listitem>

          <listitem>
            <para>Buttons</para>

            <para>The <guibutton>Next</guibutton> button finds the
            next instance of the object. It does not do a
            replace. <guibutton>Replace All</guibutton> replaces all
            instances of the object in the given
            scope. <guibutton>Replace</guibutton> replaces the current
            instance. <guibutton>Replace &amp; Find</guibutton>
            replaces the current instance and jumps to the next
            one.</para>
          </listitem>
        </itemizedlist>

   </sect1>
  </chapter>
