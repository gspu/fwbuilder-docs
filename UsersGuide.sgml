<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook V4.1//EN" [
<!entity fwbuilder-url    "http://www.fwbuilder.org/">
<!entity iptables-url     "http://netfilter.filewatcher.org/">
<!entity ipfilter-url     "http://coombs.anu.edu.au/~avalon/">
<!entity gtkmm-url        "http://gtkmm.sourceforge.net/">
<!entity gtkmm-download   "http://www.hvrlab.org/pub/gtkmm/">
<!entity ipt-howto        "http://www.netfilter.org/documentation/HOWTO//NAT-HOWTO.html">
<!entity faq-url  "http://www.fwbuilder.org/pages/Documents/FAQ/FAQ.html">
<!entity inst-url "http://www.fwbuilder.org/pages/Documents/Requirements.html">
]>

<book id="Using">
  <?dbhtml filename="index.html">
  
  <bookinfo>

    <title>Firewall Builder</title>

    <title>Firewall Builder User's Guide</title>

    <affiliation>
      <orgname>NetCitadel LLC</orgname>
    </affiliation>

    <edition>$Revision: 1.15 $  $Date: 2003-04-07 07:42:11 $</edition>

    <copyright>
      <year>2003</year>
      <holder>NetCitadel LLC</holder>
    </copyright>

    <legalnotice>
      <para>The information in this manual is subject to change
      without notice, and should not be construed as a commitment by
      NetCitadel LLC. NetCitadel LLC assumes no responsibility or
      liability for any errors or inaccuracies that may appear in this
      manual.</para>
<!--
      <para>The software described in this manual is furnished under a
      license and may only be used or copied in accordance with the
      terms and conditions of such a license.</para>
-->
    </legalnotice>
    
  </bookinfo>

  <!-- ############################################################### -->
  <chapter id="Introduction">
    <title>Introduction</title>

    <sect1>
      <title>Introducing Firewall Builder</title>

      <para>
        Whether you are an experienced professional, switching from
        Checkpoint Firewall-1 to Cisco PIX or to an Open Source
        firewall, or a hobbyist trying to secure your home network,
        Firewall Builder can help you manage your firewall policy in a
        simpler and more efficient way.
      </para>

      <para>
        With Firewall Builder, you can manage the security policy of your
        firewall efficiently and accurately, without the learning
        curve usually associated with command line interfaces of many
        free and commercial firewalls. You do not have to think of a
        policy in terms of obscure port numbers, firewall interfaces
        and make choices about what interface a certain rule should
        belong to and so on. Instead, you create a set of objects
        describing your firewall, subnets of your network and hosts on
        them, and then implement your firewall policy by dragging objects into
        policy rules. You can also take advantage of a large
        collection of predefined objects describing many standard
        protocols and services.Once a policy is built in the GUI, you
        can compile it and install it on the firewall machine.
      </para>
    </sect1>

    <sect1>
      <title>Overview of Firewall Builder Features</title>

      <para><itemizedlist spacing="compact">
          <listitem>
            <para>Over 100 predefined objects for the most popular and
            widely used protocols and services</para>
          </listitem>

          <listitem>
            <para>Ability to create custom objects describing
            IP,ICMP,TCP,UDP or custom services</para>
          </listitem>

          <listitem>
            <para>Ability to create objects to describe hosts,
            networks and address ranges</para>
          </listitem>

          <listitem>
            <para>Powerful wizards and other tools to help you
            jumpstart your firewall policy, and do it right from the
            first try. Wizards implement standard policies for typical
            network layouts, which can later be extended and edited by
            hand</para>
          </listitem>

          <listitem>
            <para>The Network discovery tool, to automate the creation
            of multiple objects </para>
          </listitem>
          
          <listitem>
            <para>Object oriented approach to the policy management:
            any change made to an object gets immediately reflected in all
            policy rules of all firewalls using that
            object. The configuration for multiple firewalls shares the
            same object database.</para>
          </listitem>

          <listitem>
            <para>The ability to turn a firewall policy into
            a configuration file or a script and then install it on a
            firewall with just a few clicks of a mouse.</para>
          </listitem>

          <listitem>
            <para>Convenient GUI that supports standard Copy/Paste
            operations for both text strings and network objects and
            allows for policy editing using drag and drop</para>
          </listitem>

          <listitem>
            <para>Support for several firewall platforms, including
            Cisco PIX and Open Source firewalls iptables, ipfilter and
            pf.</para>
          </listitem>

          <listitem>
            <para>The ability to print a single object, a firewall
            policy, the whole hierarchy, or export it to the text
            file in either plain text or html format</para>
          </listitem>

        </itemizedlist>
      </para> 

      <figure id="example1" float="1">
        <title>Sample firewall policy</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="scrn2.jpg" format="jpg" align="Left" scale="50">
          </imageobject>
        </mediaobject>
      </figure>

    </sect1>
  </chapter>





  <!-- ############################################################### -->
  <chapter id="Packaging">
    <title>Packaging</title>

      <para>Firewall Builder is an Open Source project. Source code
      for the API library, GUI and policy compilers for iptables,
      ipfilter and pf is available for download from our web site
      http://www.fwbuilder.org/. Firewall Builder for PIX is a
      licensed commercial product available as a binary package.
      </para>

      <para>       
       Installation instructions are available online at the following
       URL : &inst-url . The same document outlines procedures for
       building Firewall Builder from the source code.  Firewall
       Builder can be compiled and works on the following OS and
       distributions:
      </para>

      <para><itemizedlist spacing="compact">
          <listitem><para>Debian </para></listitem>
          <listitem><para>Mandrake Linux 8.2 and 9.0 </para></listitem>
          <listitem><para>RedHat Linux 7.3 and 8.0</para></listitem>
          <listitem><para>SuSE Linux 8.1</para></listitem>
          <listitem><para>FreeBSD 4.7</para></listitem>
          <listitem><para>OpenBSD 3.2</para></listitem>
          <listitem><para>Mac OS X 10.2</para></listitem>
        </itemizedlist></para>

      <para>
       Firewall Builder comes in a several packages:
      </para>

      <para><itemizedlist spacing="compact">
          <listitem>
            <para>Firewall Builder <emphasis>API library</emphasis>: package "libfwbuilder"</para>
          </listitem>

          <listitem>
            <para>Firewall Builder <emphasis>GUI</emphasis>: package "fwbuilder"</para>
          </listitem>

          <listitem>
            <para>Parts of GUI and policy compiler for <emphasis>iptables</emphasis>: package "fwbuilder-ipt"</para>
          </listitem>

          <listitem>
            <para>Parts of GUI and policy compiler for <emphasis>ipfilter</emphasis>: package "fwbuilder-ipf"</para>
          </listitem>

          <listitem>
            <para>Parts of GUI and policy compiler for <emphasis>pf</emphasis>: package "fwbuilder-pf"</para>
          </listitem>

          <listitem>
            <para>Parts of GUI and policy compiler for <emphasis>Cisco PIX</emphasis>: package "fwbuilder-pix"</para>
          </listitem>

        </itemizedlist></para>

      <para>You need to install the API library
       <emphasis>libfwbuilder</emphasis>, the GUI
       <emphasis>fwbuilder</emphasis> and at least one module that
       provides support for the target firewall platform; this could
       be either <emphasis>fwbuilder-ipt</emphasis> or one of the
       others. </para>

      <para>Pre-built binary packages for many OS and distributions
      can be downloaded from our web site at &fwbuilder-url </para>

      <para>
       Typical installation problems are addressed in the document
       "Firewall Builder Frequently Asked Questions (FAQ)" which can
       be found at the following URL: &faq-url
      </para>

  </chapter>

  <!-- ############################################################### -->
  <chapter id="using-gui">
    <title>Firewall Builder GUI</title>


    <!-- *************************************************************** -->
    <sect1>
      <title>The Main Window</title>

      <para>The main window is divided into two parts: the objects
      tree and a dialog area. The object which is currently selected
      in the tree is highlighted in a color and is shown in the dialog
      in the right half of the main window. You can create more than
      one main window using the main menu
      <guimenuitem>"File"</guimenuitem>/<guimenuitem>"New
      Window"</guimenuitem>. All windows are synchronized and work
      with the same object tree. Changes made to the object in one
      window are immediately reflected in all windows where it is
      visible, both in the tree and in the dialog. We recommend using
      the multi-window mode if you work with a firewall with a very
      large policy. In this case opening the policy may take some time
      and switching between the policy view and individual objects can
      slow the work down. Opening the policy in one window and working
      with individual objects in another helps avoid this problem.
      </para>

      <para>Drag and drop and Copy/Paste operations work across
      different windows.</para>

      <para>
      <figure id="main-win1">
          <title>Main window</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="main_win1.jpg" format="jpg" align="Left" scale="50">
            </imageobject>
          </mediaobject>
        </figure>
      </para>

    </sect1>

    <!-- *************************************************************** -->
    <sect1>
      <title>GUI Options</title>

      <para>Certain aspects of the GUI behavior can be changed by the
      user. These are gathered in the dialog called "Options" which
      can be accessed through the main menu
      "<guimenuitem>Edit</guimenuitem>/<guimenuitem>Options</guimenuitem>". The
      GUI Options dialog is represented in <xref linkend="options1">.
      </para>

      <figure id="options1" float="0" pgwide="1">
        <title>GUI Options Dialog</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="options1.jpg" format="jpg" align="Left" scale="50">
          </imageobject>
        </mediaobject>
      </figure>


      <para>
        <itemizedlist spacing="compact">
          <listitem>
            <para><guimenuitem>General/Paths</guimenuitem></para>

            <itemizedlist spacing="compact">
              <listitem>
                <para>Working directory:</para>

                <para>This option tells the program where the data
                file should be stored. Policy compilers also store
                firewall configuration files or scripts they produce
                in the same directory. If this parameter is left
                blank, then the policy compiler will store the
                firewall configuration it generates in the same
                directory the original data file was loaded
                from.</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para><guimenuitem>Network</guimenuitem></para>

            <itemizedlist spacing="compact">
              <listitem>
                <para>SNMP Timeout and Retries</para>

                <para>Here you can configure timeout values and retry
                counters for SNMP queries. These values are used when
                the program runs a SNMP query to collect host
                "sysinfo" data and its interfaces. Note that the Network
                discovery Druid has its own settings for the SNMP
                timeout value and retry counter.</para>
              </listitem>
              <listitem>
                <para>DNS Timeout and Retries</para>

                <para>Here you can configure timeout values and retry
                counters for DNS queries. These values are used when
                the program uses DNS to determine the host's address by
                its name. </para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para><guimenuitem>GUI</guimenuitem></para>

            <itemizedlist spacing="compact">
              <listitem>
                <para>Remember window size at exit</para>

                <para>If this option is checked, the GUI remembers
                the main window size when the program finishes. The
                information is stored in the user's preferences file so
                that when the program is started again next time, it
                opens the window in the same size as before.</para>
              </listitem>

              <listitem>
                <para>Hide navigation bar in object dialog</para>

                <para>The GUI can show the navigation bar on top for the
                object's dialog. The navigation bar shows the current
                position in the tree and familiar buttons that allow
                navigation "up", "down" and "left" in the tree. If this
                option is checked, then the bar will disappear.</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para><guimenuitem>GUI / Object Tooltips</guimenuitem></para>

            <para>Firewall Builder can show the object's properties in
            a quick pop-up window (this feature is often called
            "tooltip") when the user places the mouse cursor over the
            object in a group view or in the firewall policy view,
            where objects are represented by their icons. This is a
            convenient way to quickly check the object's properties
            without having to leave the current dialog and open the
            object's dialog. There are three choices for the tooltip
            feature:
           </para>

            <para>
              <itemizedlist spacing="compact">
                <listitem><para>Off</para></listitem>
                <listitem><para>Show properties in a tooltip pop-up window</para></listitem>
                <listitem><para>Show properties on the main window's status bar</para></listitem>
              </itemizedlist>
            </para>
            
            <para>For the second choice (showing in tooltip window) an
            additional parameter is avaliable; it controls the delay
            before the tooltip window appears ( after the mouse cursor
            is positioned over the object's icon.)</para>
          </listitem>

          <listitem>
            <para><guimenuitem>GUI / Behavior</guimenuitem></para>
            <anchor id="gui-behavior">

            <itemizedlist spacing="compact">
              <listitem>
                <para>Automatically save data in dialogs while
                switching between objects</para>

                <para>The GUI shows a dialog for every opened object
                in the same place (right half of the main
                window). Normally if the user has made some changes to
                the object's data and wants to switch to another
                object without clicking on the
                <guibutton>"Apply"</guibutton> or
                <guibutton>"Undo"</guibutton> button, GUI shows a
                pop-up dialog asking whether data should be saved or
                changes should be ignored. If this option is turned on
                though, the program automatically saves data every
                time the user leaves the dialog with unsaved data to
                open another object.</para>

              </listitem>
            </itemizedlist>

          </listitem>

          <listitem>
            <para><guimenuitem>GUI / Tree View</guimenuitem></para>

            <para>As was mentioned before, objects can be organized
            into different libraries. Usually there are at least two
            libraries: "User" and "Standard". GUI can represent
            objects either in one large tree, or in a separate tree
            for each library.</para>

            <itemizedlist spacing="compact">
              <listitem>
                <para>Show object libraries in separate trees</para>

                <para>If this option is checked, the GUI shows objects
                belonging to different libraries in separate
                trees</para>
              </listitem>

              <listitem>
                <para>Combine all libraries in a single tree</para>

                <para>If this option is checked, the GUI combines all
                objects in one large tree.</para>
              </listitem>

              <listitem>
                <para>Show properties of objects in the tree</para>

                <para>If this option is checked, then GUI shows
                brief summary of object's properties, or one most
                frequently used property, in an additional column in
                the tree view.</para>
              </listitem>
            </itemizedlist>

          </listitem>
        </itemizedlist>
      </para>
    </sect1>
  </chapter>

  <!-- *************************************************************** -->
  <chapter>
    <title>Object Tree</title>

    <sect1>
      <title>The Standard Tree Structure</title>

      <figure id="tree-structure" float="1" pgwide="0">
        <title>Standard Tree Structure</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="tree_structure1.jpg" format="jpg" align="Left" scale="50">
          </imageobject>
        </mediaobject>
      </figure>

      <para>The object tree provides standard places for all object
        types so that they can be arranged in a hierarchy. Types that
        correspond to network objects (hosts, address ranges, networks
        and groups of these) are located in the "Objects" branch,
        types that correspond to all services are in the "Services"
        branch, time intervals are in the "Time" branch, and all
        firewalls are in the "Firewalls" branch. Newly created objects
        are automatically placed in their corresponding position in
        the tree. Each branch of the tree is automatically sorted by
        the object's name.</para>

      <note>
        <para>Future versions of Firewall Builder will support 
          creation of custom branches in the tree and placing of
          objects and groups of objects in any branch.</para>
      </note>

      <para>The program can maintain all the objects in a single tree,
      or divide them into "libraries". The latter case is illustrated
      by <xref linkend="main-win2"> where each library is represented
      by an individual tree; one tree is always called "User" and
      holds user-defined objects. The other tree is called "Standrard"
      and holds a collection of standard objects that come with the
      program. Some of the standard objects are visible on the
      screenshot <xref linkend="main-win2">. Standard objects
      represent over 100 of frequently used protocols and services.
      There may be more libraries in the future. Splitting objects
      tree into "libraries" is just a convenient way to sort objects
      in the tree, you can think of it as a kind of a "view". It only
      affects representation of the data in the GUI; objects are all
      equal in all other senses and you can use object from either
      part of the tree in your policy. You do not need (and can't )
      insert firewall in the "Standard" tree.  </para>

      <figure id="main-win2" float="1">
        <title>Standard Objects</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="main_win2.jpg" format="jpg" align="Left" scale="50">
          </imageobject>
        </mediaobject>
      </figure>
    </sect1>


    <sect1 id="creating-objects">
      <title>Creating Objects</title>

      <para>New objects can be created using the main menu
        <guimenuitem>"Insert"</guimenuitem>. Certain objects can also
        be created via a pop-up menu that can be opened by clicking
        the right mouse button on the object in the tree.</para>

      <figure id="menu-insert" float="1">
        <title>Creating Objects Using Main Menu 'Insert'</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="scrn-menu1.jpg" format="jpg" align="Left" scale="50">
          </imageobject>
        </mediaobject>
      </figure>

      <para>You can create all objects through the main menu
        'Insert' (<xref linkend="menu-insert">). Since some objects
        can be placed in the tree only under certain object types,
        corresponding menu items get enabled only when the right
        object is displayed in the dialog in the main window. For
        example, the interface object can only be placed under the
        host or the firewall, therefore the menu item
        <guimenuitem>"Insert"</guimenuitem>/<guimenuitem>"Interface"</guimenuitem>
        is enabled only if the host or firewall object is opened in
        the main window. Likewise, the menu items
        <guimenuitem>"Address"</guimenuitem> and
        <guimenuitem>"Physical Address"</guimenuitem> are enabled only
        when the interface object is opened.</para>

      <para>Another way to create objects uses the pop-up menu which
        appears if you click the right mouse button on the object
        label in the tree (<xref linkend="popup-menu-insert">).</para>


      <figure id="popup-menu-insert">
        <title>Adding Objects Using Pop-up Menu</title>
        <informaltable frame="none">
          <tgroup cols="2">
            <colspec align="left" colwidth="1*">
            <colspec align="left">
            <tbody>
              <row>
                <entry>
                  <inlinemediaobject>
                    <imageobject>
                      <imagedata fileref="scrn-menu2.jpg" format="jpg" align="Left" scale="50">
                    </imageobject>
                  </inlinemediaobject>
                </entry>

                <entry>
                  <inlinemediaobject>
                    <imageobject>
                      <imagedata fileref="scrn-menu3.jpg" format="jpg" align="Left" scale="50">
                    </imageobject>
                  </inlinemediaobject>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </figure>

      <para>Just like items under the main menu
        <guimenuitem>"Insert"</guimenuitem>, items in the popup menu
        are context-sensitive. In particular, menu items that add
        interfaces appear only when the object opened in the main
        window is either the host or the firewall (<xref
                                                         linkend="popup-menu-insert">). You can add interface objects
        by hand (using the menu item <guimenuitem>"Add
        Interface"</guimenuitem>) or import them via SNMP query (using
        menu item <guimenuitem>"Add Interfaces via
        SNMP"</guimenuitem>)
        </para>

    </sect1>

    <sect1>
      <title>Navigating The Object Tree and Editing Objects</title>

      <para>The object selected in the tree automatically appears in
        the dialog area where it can be reviewed or modified. Objects
        are opened at a single mouse click in the tree. Clicking the
        right button when the mouse cursor is over the object's label
        in the tree brings up the pop-up menu. This menu is
        context-sensitive and provides items for the following
        functions (<xref linkend="popup-menu-insert">):</para>

      <para>
          <itemizedlist spacing="compact">
          <listitem>
            <para>Duplicate:</para>

            <para>This function creates a copy of the current
              object, places it in the tree and opens it in the main
              window. The new object has the generic name "New
              Object", but once you change the name and click
              <guibutton>"Apply"</guibutton>, its name will
              immediately change in the tree.</para>
          </listitem>
          <listitem>
            <para>Copy:</para>

            <para>This copies an object into the clipboard.</para>
          </listitem>
          <listitem>
            <para>Cut:</para>

            <para>This copies an object into the clipboard and
              removes it from the tree.</para>
          </listitem>
          <listitem>
            <para>Paste:</para>

            <para>This creates a new object which is a copy of the
              current content of the clipboard.</para>
          </listitem>
          <listitem>
            <para>Delete:</para>

            <para>This deletes an object without making a copy in
              the clipboard. This is an unreversible operation and the
              program shows a pop-up dialog, asking the user to
              confirm. </para>
          </listitem>
          <listitem>
            <para>Where used:</para>

            <para>This scans the whole tree, including all groups
              and policies of all firewalls, looking for references to
              the current object. In the end the program shows a
              pop-up dialog with icons corresponding to groups and
              firewalls that use current object. Double-clicking on
              the icon opens the corresponding object in the main
              window.</para>
          </listitem>
        </itemizedlist>
        </para>

      <para>The pop-up menu can also have items to add interface and
        address objects, depending on what type of object it is
        called for (<xref linkend="popup-menu-insert">).
        </para>

      <para>In general, GUI has been designed to "look and feel"
        like a typical file browser (e.g. Windows Explorer). It shows
        object groups as a collection of icons, where each icon
        represents an individual object (<xref
                                               linkend="group-view">). The user can navigate between objects
        either using the mouse or keyboard "arrow" keys. The active
        object is highlighted with a different color. The
        douple-clicking on the icon in the group view opens the
        corresponding object. Clicking the right mouse button or spacebar
        on the keyboard opens a pop-up menu, which acts as a shortcut to
        frequently used operations such as "Open Object",
        "Copy","Cut" and "Paste" </para>

      <figure id="group-view" float="1">
        <title>Group View</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="group_view1.jpg" format="jpg" align="Left" scale="50">
          </imageobject>
        </mediaobject>
      </figure>

      <para>Dialogs for objects that can be edited have
        <guibutton>"Apply"</guibutton> and
        <guibutton>"Undo"</guibutton> buttons at the bottom. Initially
        these buttons are inactive, but once the object's parameters
        have been modified in the dialog, or group members have been
        added or removed, both buttons get activated so that the user
        can click <guibutton>"Apply"</guibutton> to save new data or
        <guibutton>"Undo"</guibutton> to reload original values into
        the dialog. If the user tries to switch to another object
        without either saving or reloading data in the current dialog,
        the program shows a pop-up dialog asking the user to take one
        of these actions. There is also an option to make the program
        automatically save modified data when the user switches
        between objects (see <link linkend="gui-behavior">below</link>).
      </para>

    </sect1>
  </chapter>

  <!-- *************************************************************** -->
  <chapter>
    <title>Working With Objects</title>

    <sect1>
      <title>Common Properties</title>

      <para>All objects visible to the user have some common
        editable fields, such as their name and comment. The object
        name can contain white spaces and can be arbitrarily long. The
        comment can contain any text of any length.</para>

      <para>Dialogs for those objects that can have an address use
        the standard GUI widget that visually separates the four
        octets of IP address and provides "on the fly" control for the
        validity of an address.</para>

    </sect1>

    <sect1>
      <title>The Host Object</title>

      <para>The host object in Firewall Builder is designed to
        represent real hosts in the network: workstations, servers,
        and any other network node with an address. Just like real
        hosts, the host object can have interfaces, which in turn have
        addresses. Both interfaces and addresses are represented by
        objects, which are organized into a tree-like hierarchy.
        Interface objects is sitting in the tree directly under the
        host; the address objects are located under their
        interfaces. Just like in real computers, in Firewall Builder
        interface object can have either one or multiple addresses. An
        example of a host with one interface, which has multiple
        addresses is shown in <xref linkend="host-in-tree">. In fact
        host may even have an interface with no addresses at all. We
        will go over the features of interface and address objects
        below. </para>

      <figure id="host-in-tree" float="1">
        <title>A Host Object With One Interface And Multiple Virtual Addresses </title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="host_in_tree.jpg" format="jpg" align="Left" scale="50">
          </imageobject>
        </mediaobject>
      </figure>

      <note>
        <para>The host object can not have any security or Network
          Address Translation policy associated with it; only firewall
          objects can.</para>
      </note>

      <sect2>
        <title>Creating a Host Object</title>

        <figure id="creating-host1" float="1">
          <title>First Page of the Druid</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="creating_host1.jpg" format="jpg" align="Left" scale="50">
            </imageobject>
          </mediaobject>
        </figure>

        <para>To speed up the process and make it simpler, creating
          of a new host object is aided by the Druid which collects
          all data needed for both the host and its interfaces and
          then creates the object. The screenshot (<xref
                                                         linkend="creating-host1">) represents the first page of the
          Druid. First of all you need to enter the host
          name. Generally this name does not have to be the same as
          the real host's name, but if it is, then you can use DNS to
          query for the host's IP address using its name. If the new
          host object has a single interface (this, perhaps, is the
          most common case) then you just need to fill the entry field
          for its address and may be MAC address and click
          <guibutton>"Next"</guibutton>. If the object's name is the
          same as the real host name, then you can use the
          <guibutton>"DNS Lookup"</guibutton> button to get the
          address from DNS. </para>

        <para>In case the new host object should have multiple
          interfaces, you need to check the option at the bottom of the
          dialog and then switch to the next page of the Druid using the
          <guibutton>"Next"</guibutton> button. The next page is
          represented in screenshot <xref linkend="creating-host2">.</para>

        <figure id="creating-host2" float="1">
          <title>Adding Interfaces to the New Host Object</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="creating_host2.jpg" format="jpg" align="Left" scale="50">
            </imageobject>
          </mediaobject>
        </figure>

        <para>Here you can add interfaces to the new host
          object. Enter the interface name, its address and netmask in
          the appropriate fields, and click
          <guibutton>"Add"</guibutton> to add it to the list. The
          <guibutton>"Update"</guibutton> button updates information
          for the interface that is selected in the list, and the
          <guibutton>"Delete"</guibutton> button deletes currently
          selected interface.</para>

        <note>
          <para>You can always add, modify and remove
            interfaces of the new host object later using controls
            provided by the main window and the object tree
            view.</para>
        </note>
      </sect2>

      <sect2>
        <title>Editing a Host Object</title>

        <para>The Host object dialog is split into two tabs: "General"
          (<xref linkend="host-dialog1">) and "Sysinfo" (<xref
                                                               linkend="host-dialog2">). </para>

        <figure id="host-dialog1" float="1">
          <title>Editing The Host Object</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="host_dialog1.jpg" format="jpg" align="Left" scale="50">
            </imageobject>
          </mediaobject>
        </figure>

        <para>The "General" tab provides GUI controls for the following parameters:</para>

        <para>
            <itemizedlist spacing="compact">
            <listitem>
              <para>Name:</para>

              <para>Host object name.</para>
            </listitem>
            <listitem>
              <para>MAC address filtering:</para>

              <para>If this option is activated, the policy compiler
              uses MAC addresses of all interfaces of this host in the
              firewall rules.  Not all firewall platforms support MAC
              address filtering, so this option may have no effect on
              the generated firewall script. This is treated as a
              non-critical situation, and the policy compiler will
              only generate a warning while processing a firewall
              policy where such a host is used. See below <xref
              linkend="using-mac-address">.</para>
            </listitem>
            <listitem>
              <para>SNMP communities:</para>

              <para>The SNMP 'read' community is used if the host
                runs SNMP agent and you pull the host's "sysinfo"
                variables via SNMP query. The SNMP 'write' community
                is currently not used but we may add features using it
                in the future.  SNMP communities usually can not
                contain spaces. If your host does not run SNMP agent,
                or if you do not need to pull the host info using
                SNMP, then SNMP community strings may be left
                blank.</para>

            </listitem>
            <listitem>
              <para>Comment:</para>

              <para>This is a free-form text field which can be used to
              add comments.</para>
            </listitem>
          </itemizedlist>
        </para>

        <figure id="host-dialog2" float="1">
          <title>Host Object System Information</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="host_dialog2.jpg" format="jpg" align="Left" scale="50">
            </imageobject>
          </mediaobject>
        </figure>

        <para>The "Sysinfo" tab holds data retrieved from the host
          via SNMP query. There, you can see the strings that the host
          returned for standard SNMP MIB "Description", "Location" and
          "Contact" variables. These fields are read-only in the
          GUI.</para>

      </sect2>
    </sect1>

    <sect1 id="host-interface">
      <title>The Host's Interface</title>

      <figure id="host-interface1" float="1">
        <title>The Host's Interface</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="host_interface1.jpg" format="jpg" align="Left" scale="50">
          </imageobject>
        </mediaobject>
      </figure>

      <para>The dialog for the interface object that belongs to the
        host has only one tab named "General", which provides controls
        for the following parameters:</para>

      <para>
          <itemizedlist spacing="compact">
          <listitem>
            <para>Name</para>

            <para>This is the name of the object. Usually it should
              be the real interface's name. For example, on Linux this
              could be 'eth0' or 'eth1', on FreeBSD this could be
              'lnc0' or 'fxp0', on Solaris this could be 'hme0', on
              Cisco PIX it could be 'ethernet0' and so on.</para>
          </listitem>
          <listitem>
            <para>Label</para>

            <para>On most OS this field is not used and serves the
              purpose of a descriptive label. Firewall Builder GUI
              uses a label, if it is not blank, to show interfaces in
              the tree. One of the suggested uses for this field is to
              mark interfaces to reflect the network topology
              ('outside', 'inside') or the purpose ('web frontend' or
              'backup subnet'). The label is mandatory for Cisco PIX
              though, where it must reflect the network topology. See
              below for the chapter describing interfaces of the
              firewall </para>
          </listitem>
          <listitem>
            <para>Option "Regular Interface"</para>

            <para>Use this option if the interface has IP address
              assigned to it manually. This is the default.
              </para>
          </listitem>
          <listitem>
            <para>Option "Address is assigned dynamically"</para>

            <para>Use this option if the interface has a dynamic
              address (obtained by means of DHCP or PPP or another
              protocol); in this case an address is unknown at the
              moment when Firewall Builder generates the firewall
              policy. </para>
          </listitem>
          <listitem>
            <para>Option "Unnumbered interface"</para>

            <para>Use this option if interface can never have IP
              address, such as ethernet interface used to run PPPoE
              communication on some ADSL connections or tunnel
              endpoint interface or an interface on a bridging
              firewall. See below <xref linkend="types-of-interfaces">
              for more detailed discussion of these different types of
              interfaces. </para>
          </listitem>
          <listitem>
            <para>Checkbox "This is management interface"</para>

            <para>Sometimes the host has several network interfaces in
              which case one of them can be marked as the 'management
              interface'. The management interface is used for all
              communication between Firewall Builder and the host. In
              the case of a host object this communication is currently
              limited to SNMP query to pull host information (standard
              SNMP MIB variables 'Description', 'Location',
              'Contact'), however in the future we will add
              more.</para>
          </listitem>
          <listitem>
            <para>Physical (MAC) Address</para>

            <para>This field holds the interface's MAC address.</para>
          </listitem>
          <listitem>
            <para>Comment</para>

            <para>This is a free-form text field for a comment.</para>
          </listitem>
        </itemizedlist>
        </para>

      <sect2 id="types-of-interfaces">
        <title>Interface Types</title>

        <para>Firewall Builder recognizes three types of the interface
        depending on its IP address: <emphasis>regular</emphasis>,
        <emphasis>dynamic</emphasis> and
        <emphasis>unnumbered</emphasis>. <emphasis>Regular</emphasis>
        interface has IP address assigned statically, that is the
        address does not change and Firewall Builder can use it in the
        firewall policy rules. It may need to use this address if
        policy rule controls access to or from the firewall itself.</para>

        <para><emphasis>Dynamic</emphasis> interface has its IP
        address assigned to it dynamically by DHCP or PPP protocol. In
        this case the address is not known beforehand and can not be
        used in the policy rules. Some firewalls allow for using
        interface name in the policy instead of its IP address;
        firewall engine then picks its address either when policy is
        activated or even at run-time. Some other firewalls support a
        special syntax for rules that are supposed to match packets
        headed to or from the firewall machine. Examples of these two
        cases are OpenBSD PF and Netfilter. PF rules can be
        constructed using interface names; PF automatically uses
        current interface address when it loads rules into the
        memory. Netfilter supports special "chains" called "INPUT" and
        "OUPUT" that are guaranteed to inspect only packets headed for
        the firewall machine ("INPUT") or originated on it
        ("OUTPUT"). Both methods allow Firewall Builder to build
        correct firewall policy rules that affect interface with
        dynamic IP address, however interface must be marked as such
        for policy compiler to use proper technique depending on the
        target firewall platform.</para>

        <para><emphasis>Unnumbered</emphasis> interface can never have
        IP address. Exapmples of such interfaces include endpoints of
        various tunnels (GRE, PPPoE, somtimes IPSEC), interfaces of a
        bridging firewall and perhaps some other cases. Firewall
        Builder ignores interfaces marked as
        <emphasis>Unnumbered</emphasis> and never includes them in the
        policy rules.</para>

        <para>Interfaces of all three types can have policy rules
        associated with them. This means in the GUI any interface
        object can have "Interface Policy" object situated under it in
        the tree. The main difference is that
        <emphasis>Regular</emphasis> interface can always be used in
        the rule elements <emphasis>Source</emphasis> and
        <emphasis>Destination</emphasis>, <emphasis>Dynamic</emphasis>
        interface can be used there only on some firewall platforms,
        and <emphasis>Unnumbered</emphasis> interface can never be
        used in these policy rule elements.  For example, on netfilter
        there is no difference between <emphasis>Dynamic</emphasis>
        and <emphasis>Unnumbered</emphasis> interface: neither one can
        be used in the policy rule elements because its address is
        unknown. In OpnBSD PF, on the other hand,
        <emphasis>Dynamic</emphasis> interface can be used in rules
        because PF can automatically use its current address.</para>

        <note>
          <para>We plan to overcome this limitation in the future
          versions and implement mechanism to emulate behavior similar
          to that of OpenBSD PF on netfilter.</para>
        </note>
      </sect2>

    </sect1>

    <sect1 id="address-object">
      <title>The Address Object</title>

      <figure id="address1" float="1">
        <title>The Address Object</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="address1.jpg" format="jpg" align="Left" scale="50">
          </imageobject>
        </mediaobject>
      </figure>

      <para>The address object describes the IP address of the
        interface; its dialog provides the following entry
        fields:</para>

      <para>
          <itemizedlist spacing="compact">
          <listitem>
            <para>Name</para>

            <para>This is the name of the object.  It is recommended
            that you use some descriptive name because when the
            address object is used in the firewall policy, it is
            labeled with this name. It may be hard to tell one address
            from another if their names are similar. </para>
          </listitem>
          <listitem>
            <para>Address</para>

            <para>This is an IP address. The GUI widget visually
              separates octets and provides syntax control for the
              values entered in the octet fields.</para>

            <note>
              <para>A typical error is to interpret this object as an
              address of the subnet to which interface of the host or
              firewall belongs. This object represents an address of
              interface, not a network address.  </para>
            </note>
          </listitem>
          <listitem>
            <para>Netmask</para>

            <para>This is a netmask assigned to the interface.</para>
          </listitem>
          <listitem>
            <para>Comment</para>

            <para>This is free-form text field for a comment.</para>
          </listitem>
        </itemizedlist>
        </para>

      <note>
        <para>Currently Firewall Builder does not support IPv6
        addresses, although support for IPv6 will be added in the
        future.</para>
      </note>
    </sect1>

    <sect1>
      <title>The Physical Address Object</title>

      <figure id="physAddress1" float="1">
        <title>The Physical Address Object</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="physaddress1.jpg" format="jpg" align="Left" scale="50">
          </imageobject>
        </mediaobject>
      </figure>

      <para>the Physical Address object describes hardware or media
      address, that is the interface's address at the protocol layer
      immediately `below' the network layer in the protocol stack. For
      example for Ethernet this would be its MAC address.</para>

      <para>
          <itemizedlist spacing="compact">
          <listitem>
            <para>Name</para>

            <para>This is the name of the object. It is recommended
            that you use some descriptive name because when the
            address object is used in the firewall policy, it is
            labeled with this name. It may be hard to tell one address
            from another if their names are similar. </para>

          </listitem>
          <listitem>
            <para>Address</para>

            <para>This is a string representation of the physical or
            media address.  For many types of media, this will be in a
            binary representation.  For example, an ethernet address
            would be represented as a string of 6 octets.</para>
          </listitem>
          <listitem>
            <para>Comment</para>

            <para>This is free-form text field for a comment.</para>
          </listitem>
        </itemizedlist>
        </para>

      <sect2 id="using-mac-address">
        <title>Using Physical Address Object in the Policy</title>

        <para>Only few firewall platforms really support physical
        address filtering. Currently netfilter is only firewall
        platform that can do it and is supported by Firewall
        Builder.</para>

        <para>As described in <xref linkend="multiple-addresses">, if
        the Interface object that has multiple Address and Physical
        Address child objects is used in the policy or NAT rule
        element (either <emphasis>Source</emphasis> or
        <emphasis>Destination</emphasis>), then policy compiler tries
        to generate a rule using all of them. <xref
        linkend="multiple-addresses"> explains that compiler actually
        does this by generating multiple rules using each address in
        turn. This roughly corresponds to using logical operation "OR"
        on these addresses: if our interface had two addresses
        <emphasis>Address1</emphasis> and
        <emphasis>Address2</emphasis>, then generated rule would match
        if address in the packet is either
        <emphasis>Address1</emphasis> OR
        <emphasis>Address2</emphasis>.  The case of Physical Address
        is different though. If Interface has physical address, then
        compiler tries to build a set of rules that matches on
        combination of each IP address and its MAC address. The reason
        for this change is as follows:</para>

        <para>Suppose we have a very important host on the network. We
        create a Host object, then add interface to it. Interface
        should have both Address and Physical Address objects as shown
        on <xref linkend="host-with-addr-and-physaddr"></para>


        <figure id="host-with-addr-and-physaddr" float="1">
          <title>the Host object with Address and Physical Address</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="using-physaddress-1.jpg" format="jpg" align="Left" scale="50">
            </imageobject>
          </mediaobject>
        </figure>

        <para>Because this is very important host, we would like to be
        sure that packets whose source IP is that of this host are
        really coming from it and are not spoofed. The best way to
        achieve this goal is to use strong authentication, for example
        with IPSEC protocol. Using IPSEC is outside the scope of this
        document though; our goal right now is to show that inspecting
        MAC address of the packet can improve security.</para>

        <para>The packet originated from this host always has source
        IP address of its interface, but source MAC address is going
        to be different if spoofing is going on. There may be three
        possible ways to build security policy in this situation: </para>

        <para>
          <itemizedlist>
            <listitem><para>Using only Address object in the rule
            element. This means the firewall inspects only IP address
            and ignores MAC address of the packets. </para>

              <figure id="only-addr" float="1">
                <title>Policy rule using only Address object</title>
                <mediaobject>
                  <imageobject>
                    <imagedata fileref="using-physaddress-4.jpg" format="jpg" align="Left" scale="50">
                  </imageobject>
                </mediaobject>
              </figure>

            </listitem>
            <listitem><para>Using only Physical Address object. Rule
            built this way permits all kinds of traffic coming from
            the trusted host regardless of its IP address.</para>

              <figure id="only-phaddr" float="1">
                <title>Policy rule using only Physical Address object</title>
                <mediaobject>
                  <imageobject>
                    <imagedata fileref="using-physaddress-5.jpg" format="jpg" align="Left" scale="50">
                  </imageobject>
                </mediaobject>
              </figure>

            </listitem>

            <listitem><para>Using Host or Interface object. This way
            we end up with a rule that matches on a
            <emphasis>combination</emphasis> of IP address and MAC
            address. This may be used as a sophisticated anti-spoofing
            rule.</para>

              <figure id="using-host" float="1">
                <title>Policy rule using Host object</title>
                <mediaobject>
                  <imageobject>
                    <imagedata fileref="using-physaddress-6.jpg" format="jpg" align="Left" scale="50">
                  </imageobject>
                </mediaobject>
              </figure>

              <figure id="using-interface" float="1">
                <title>Policy rule using Interface object</title>
                <mediaobject>
                  <imageobject>
                    <imagedata fileref="using-physaddress-3.jpg" format="jpg" align="Left" scale="50">
                  </imageobject>
                </mediaobject>
              </figure>

            </listitem>
          </itemizedlist>
       </para>

        <para>Using Address and Physical Address objects in a rule is
        not the same as using Host or Interface object to which these
        Address and Physical Address belong. As described in <xref
        linkend="multiple-addresses">, using object with multiple
        addresses or multiple objects in the rule element is like
        bundling them together using logical operation
        <emphasis>OR</emphasis>. If we were to put Address and
        Physical Address in the rule like in <xref
        linkend="addr-and-phaddr">, we would end up with policy
        matching packets that have source address 10.1.1.1 or MAC
        address 00:08:C7:29:D1:AC but not necessarily both at the same
        time. Any host that manages to pretend to have IP address
        10.1.1.1 would be able to send packets through our firewall
        even if its MAC address is different. To achieve our goal and
        make sure packets with source IP 10.1.1.1 really belong to our
        important host, we should be checking its IP address and MAC
        address at the same time and let packet through only if its IP
        address <emphasis>AND</emphasis> MAC address are what we
        expect them to be. That is why Firewall Builder treats
        physical addresses differently and generates firewall code
        that inspects both IP address and physical address.</para>

        <figure id="addr-and-phaddr" float="1">
          <title>Policy rule using Address and Physical Address objects</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="using-physaddress-7.jpg" format="jpg" align="Left" scale="50">
            </imageobject>
          </mediaobject>
        </figure>

        <para>Firewall Builder generates firewall code to inspect MAC
        address only for Host objects with option "MAC address
        filtering" turned on. Even if the Host object has interfaces
        with both Address and Physical Address child objects, but this
        option is off, Physical Address objects will be ignored. This
        is because Host objects created using Network Discovery Druid
        ( <xref linkend="network-discovery"> )
        are often populated with both IP address and MAC address
        information which is available through SNMP query, but
        inspection of MAC addresses is rarely needed. Administrator
        can use option "MAC address filtering" in the Host object to
        specify what Hosts he wants MAC addresses to be checked for.
        </para>

      </sect2>
    </sect1>

    <sect1>
      <title>The Network Object</title>

      <figure id="network-dialog1" float="1">
        <title>The Network Object</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="network_dialog1.jpg" format="jpg" align="Left" scale="50">
          </imageobject>
        </mediaobject>
      </figure>

      <para>The network object describes the IP network or a subnet; its
        dialog provides the following entry fields:</para>

      <para>
          <itemizedlist spacing="compact">
          <listitem>
            <para>Name:</para>

            <para>Network object name</para>
          </listitem>
          <listitem>
            <para>'DNS Lookup' button:</para>

            <para>Clicking on this button runs a DNS query for an "A"
              RR using the name entered in the "Name" field </para>
          </listitem>
          <listitem>
            <para>Address:</para>

            <para>This is an address of the network</para>
          </listitem>
          <listitem>
            <para>Netmask:</para>

            <para>The netmask, in combination with an Address, defines
              the subnet.</para>
          </listitem>
          <listitem>
            <para>Comment:</para>

            <para>This is a free-form text field used for comments</para>
          </listitem>
        </itemizedlist>
        </para>
    </sect1>

    <sect1>
      <title>The Address Range Object</title>

      <figure id="address-range-dialog1" float="1">
        <title>The Address Range Object</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="address_range_dialog1.jpg" format="jpg" align="Left" scale="50">
          </imageobject>
        </mediaobject>
      </figure>

      <para>the Address Range object describes a continuous range of IP
        addresses; its dialog provides the following entry fields:</para>

      <para>
          <itemizedlist spacing="compact">
          <listitem>
            <para>Name:</para>

            <para>The name of the Address Range object</para>
          </listitem>
          <listitem>
            <para>Range start:</para>

            <para>The address of the start of the range</para>
          </listitem>
          <listitem>
            <para>Range end:</para>

            <para>The address of the end of the range</para>
          </listitem>
          <listitem>
            <para>Comment:</para>

            <para>A free-form text field used for comments</para>
          </listitem>
        </itemizedlist>
        </para>

      <para>The Address range is inclusive, that is both the start
        and the end addresses are included in the range.</para>
    </sect1>

    <sect1>
      <title>Group of Objects</title>

      <figure id="group-dialog1" float="1">
        <title>Group of Objects</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="group_dialog1.jpg" format="jpg" align="Left" scale="50">
          </imageobject>
        </mediaobject>
      </figure>

      <para>The group of objects holds references to Hosts, Networks,
        Address Ranges, Firewalls and other groups of objects (<xref
                                                                     linkend="group-dialog1">). Objects can be added to the group
        using the following methods:
        </para>

      <para>
          <itemizedlist spacing="compact">
          <listitem>
            <para>Using drag and drop:</para>

            <para>Objects can be dragged from the tree into the
              group dialog. The tree switches to the object in a
              single click, however pointing a mouse cursor at the
              object and then pressing the button does not switch, but
              rather allows to start a drag and drop operation. </para>
          </listitem>
          <listitem>
            <para>Using the popup menu:</para>

            <para>You can use the "Copy"/"Paste" operations between the
              tree and group dialog. Right mouse clicking on the object
              in the tree brings a pop-up menu. Choose the "Copy" or
              "Cut" item in this menu, then switch to the group dialog and
              right mouse click in the icon field. This also brings
              up a pop-up menu, where you choose  "Paste" item. This inserts
              a reference to the object in the group.</para>
          </listitem>
          <listitem>
            <para>Using the main menu "Edit":</para>

            <para>Just like in the case of a pop-up menu, select the
              object in the tree, use the main menu
              <guimenuitem>"Edit"</guimenuitem>/<guimenuitem>"Copy
              Object"</guimenuitem>, then switch to the group dialog
              and use the main menu
              <guimenuitem>"Edit"</guimenuitem>/<guimenuitem>"Paste
              Object"</guimenuitem>
              </para>
          </listitem>
        </itemizedlist>
        </para>
    </sect1>

    <sect1>
      <title>Firewall Object</title>

      <sect2 id="creating_firewall">
        <title>Creating a Firewall Object</title>

        <para>Similar for the creating of a Host Object; creating a
          new Firewall Object is aided by the Druid. The first page of
          this Druid is represented on a screenshot ( <xref
                                                            linkend="creating-firewall1"> ). First of all you need to
          specify the name for new firewall; then click
          <guibutton>"Next"</guibutton>. This brings you to the next
          page of the Druid (<xref
                                   linkend="creating-firewall2">).</para>

        <figure id="creating-firewall1" float="1">
          <title>First Page of the Druid</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="creating_firewall1.jpg" format="jpg" align="Left" scale="50">
            </imageobject>
          </mediaobject>
        </figure>

        <figure id="creating-firewall2" float="1">
          <title>Adding Interfaces to the new Firewall Object</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="creating_firewall2.jpg" format="jpg" align="Left" scale="50">
            </imageobject>
          </mediaobject>
        </figure>

        <para>This page is similar to that of the new Host object
          druid page where you add interfaces. You enter the name,
          address and netmask of the interface in appropriate fields,
          then click <guibutton>"Add"</guibutton>. The
          <guibutton>"Update"</guibutton> button updates parameters of
          the currently selected interface and the
          <guibutton>"Delete"</guibutton> button deletes it. Once all
          the interfaces are configured, click on
          <guibutton>"Next"</guibutton> to create a new firewall
          object.</para>

        <note>
          <para>You can always add, modify and delete
            interfaces later using controls provided by the main
            window and the object tree view.</para>
        </note>

      </sect2>
      <sect2>
        <title>Editing a Firewall Object</title>

        <figure id="firewall-dialog-general" float="1">
          <title>Firewall Object, tab 'General'</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="firewall_dialog_general.jpg" format="jpg" align="Left" scale="50">
            </imageobject>
          </mediaobject>
        </figure>

        <para>The Firewall Object represents the firewall machine
          and is the most complex object in Firewall Builder. Its
          dialog has the following tabs: 'General', 'Sysinfo',
          'Compile/Install', 'Firewall' and 'Network'</para>

        <para>The <emphasis>General</emphasis> tab provides the
          following controls:</para>

        <para>
            <itemizedlist spacing="compact">
            <listitem>
              <para>Name:</para>

              <para>This is the name of the object</para>
            </listitem>
            <listitem>
              <para>Host OS:</para>

              <para>Modules that provide support for target OS and
                firewall platforms are distributed separately from the
                GUI and can be installed in various combinations. This
                pull-down menu provides a choice of the host OS and is
                dynamically updated depending on the combination of
                installed modules. </para>
            </listitem>
            <listitem>
              <para>Firewall platform:</para>

              <para>Like the "Host OS" menu, this pull-down menu
                provides a choice of the target firewall platform and
                is dynamically updated depending on a combination of
                installed modules.</para>
            </listitem>
            <listitem>
              <para>SNMP Communities:</para>

              <para>The SNMP "read" community is used to pull
                "sysinfo" MIB variables from the firewall machine,
                provided it runs a SNMP agent. It is also used if you
                want to automatically create interfaces for the
                firewall using SNMP query. The SNMP "write" community
                is not used at this time.</para>
            </listitem>
            <listitem>
              <para>Comment:</para>

              <para>This is a free-form text field used for
                comments</para>
            </listitem>
          </itemizedlist>
          </para>

        <figure id="firewall-dialog-sysinfo" float="1">
          <title>Firewall Object, tab 'Sysinfo'</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="firewall_dialog_sysinfo.jpg" format="jpg" align="Left" scale="50">
            </imageobject>
          </mediaobject>
        </figure>

        <para>This tab holds the following fields:</para>

        <para>
           <itemizedlist spacing="compact">
            <listitem><para>Description:</para></listitem>
            <listitem><para>Location:</para></listitem>
            <listitem><para>Contact:</para></listitem>
          </itemizedlist>
          </para>

        <para>These fields present values of corresponding MIB
          variables.</para>

        <figure id="firewall-dialog-compile" float="1">
          <title>Firewall Object, tab 'Compile/Install'</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="firewall_dialog_compile.jpg" format="jpg" align="Left" scale="50">
            </imageobject>
          </mediaobject>
        </figure>

        <para>This tab holds the following fields:</para>

        <para>
            <itemizedlist spacing="compact">
            <listitem>
              <para>Compiler:</para>

              <para>The full directory path and file name for the
                policy compiler program that the GUI invokes when you
                use the main menu item
                <guimenuitem>"Rules"</guimenuitem>/<guimenuitem>"Compile"</guimenuitem>. If
                this field is left blank, then the GUI calls the
                default policy compiler program which is preconfigured
                for the firewall platform chosen in the 'General'
                tab. Use this field if you use a non-standard policy
                compiler, or if you use a wrapper script which calls a
                policy compiler.</para>
            </listitem>
            <listitem>
              <para>Command line parameters for compiler:</para>

              <para>This is where you can specify command line
                parameters for the policy compiler. Here is the list
                of command line options supported by all policy
                compilers:
                </para>

              <para>
                <itemizedlist>
                  <listitem>
                    <para><emphasis>"-f":</emphasis> specifies the
                    data file name to be used by compiler;</para>
                  </listitem>
                  <listitem>
                    <para><emphasis>"-d":</emphasis> specifies the
                    working directory where data the file is located
                    and where produced firewall script should be
                    placed;</para>
                  </listitem>
                  <listitem>
                    <para><emphasis>"-v":</emphasis> turn on verbose
                    diagnostics print during compile;</para>
                  </listitem>
                </itemizedlist>
              </para>
              
              <para>
                Normally the GUI automatically supplies "-f" and "-d"
                options when it calls policy compiler.  See the man
                page for the corresponding policy compiler for the
                complete set of supported command line options.
              </para>

            </listitem>
            <listitem>
              <para>Installer: install script</para>

              <para>In the future there will be two ways to install
                and activate a policy on the firewall machine: using
                install script or fwbd daemon. The daemon is not
                supported yet, so the install script is the only
                method available at this time. The GUI calls the
                install script when you use the main menu
                <guimenuitem>"Rules"</guimenuitem>/<guimenuitem>"Install"</guimenuitem>
                item.</para>
            </listitem>
            <listitem>
              <para>Istaller: fwbd daemon:</para>

              <para><emphasis>Not supported</emphasis></para>
            </listitem>
            <listitem>
              <para>Policy install script:</para>

              <para>The full directory path and file name for the
                install script.</para>
            </listitem>
            <listitem>
              <para>Command line parameters for the script:</para>

              <para>This is where you specify command line
                parameters for the install script. The GUI expects
                install script to accept the same command line
                parameters as all policy compilers (see above) and
                automatically supplies "-f" and "-d" options.  You can
                add more parameters in this entry field if your script
                supports them.</para>
            </listitem>
            <listitem>
              <para>Options for fwbd:</para> 

              <para>Since the current version of Firewall Builder
                does not come with fwbd and does not support it yet,
                these options are reserved for future use.</para>
            </listitem>
          </itemizedlist>
          </para>

        <para>Tabs <emphasis>'Firewall'</emphasis> and
          <emphasis>'Network'</emphasis> provide fields specific to
          the chosen firewall platform and host OS configurations. 
        </para>
      </sect2>

    </sect1>

<!-- ===================================== Configuring Target FW ================= -->
    <sect1>
      <title>Configuring Target Firewall Software </title>

      <para>Firewall object's dialog tab 'Firewall' provides a set of
      controls to adjust behavior of the policy compiler and
      underlying firewall software. This dialog tab changes when user
      changes setting in the 'Firewall Platform' option in the 
      'General' tab.</para>

<!-- ===================================== Generic =============================== -->
      <sect2>
        <title>Generic Parameters</title>

        <para>These are compilation-time modes and algorithms that are
        common for all target firewall platforms.</para>

        <sect3 id="rule-shadowing">
          <title>Rule Shadowing</title>

          <para>Rule shadowing happens when certain rule is a superset
          of a subsequent rule and any packets potentially matched by
          the subsequent rule have already been matched by the prior
          rule. For example, if rule #1 uses network object for source
          and rule #2 uses host object located on that network for
          source, rule #1 'shadows' rule #2 because any packet matched
          by #1 will never be matched by #2. This may be important if,
          say, rule #1 permits and #2 denies access to the same
          destination. If rule #1 'shadows' rule #2, then rule #2 will
          never fire. This situation is most often an error; the
          compiler can detect it and abort processing of the policy
          with appropriate error message.</para>
        </sect3>

        <sect3 id="duplicate-rules">
          <title>Find and eliminate duplicate rules</title>

          <para>Policy compiler can detect and eliminate rules that
          lead to identical code in the target firewall
          configuration.</para>
        </sect3>
        <sect3 id="empty-groups">
          <title>Empty Groups</title>

          <para>This option is specifically designed to help to use
          the following trick. It is sometimes necessary to control
          access to an often changing group fo hosts or networks. In
          order to avoind having to make changes to the policy rules,
          these hosts or networks should be put in a group object
          which is then used in the policy rule. You can then add and
          remove hosts to this group and regenerate the policy. This
          simple technique works just fine until you get a rule where
          this group is a sole object in the rule element (source or
          destination) and by some reason this group has become empty
          because you had to remove all objects from it. Policy
          compiler should be careful not to treat an empty group as
          'any' because that would be something exactly opposite to
          the intended meaning of the rule. </para>

          <para>If this option is off, compiler treats empty group
          which is used as a sole object in the rule element as an
          error and aborts processing firewall policy with appropriate
          error message.</para>

          <para>If this option is on, compiler tries to remove all
          empty groups from the rule element. If after the last one
          has been removed the rule element becomes empty (that is,
          'any'), compiler automatically disables this rule and
          continues.</para>
        </sect3>

        <sect3 id="fw-is-part-of-any">
          <title>Assume firewall is part of <emphasis>'any'</emphasis></title>

          <para>On some firewall platforms there is a difference in
          the configuration command used to control access through the
          firewall versus command that control access to the firewall
          itself. For example, in iptables packets headed for the
          firewall machine should be inspected in the INPUT chain,
          while packets going through the firewall are inspected in
          the FORWARD chain. If this option is ON, compiler generates
          code for both FORWARD and INPUT chains if it sees
          <emphasis>'any'</emphasis> in the destination of the policy
          rule. In other words, it assumes that firewall is part of
          <emphasis>'any'</emphasis> and packet may either go to or through the
          firewall. If this option is off, compiler only generates
          code for the FORWARD chain. Compiler treats <emphasis>'any'</emphasis> in the
          source of the rule in a similar way, generating code either
          for OUTPUT and FORWARD, or only FORWARD chain.</para>

          <para>Another example of this is PIX, where one should use
          special commands to control access to the firewall on
          protocols <emphasis>telnet</emphasis>,
          <emphasis>ssh</emphasis> and
          <emphasis>icmp</emphasis>.</para>
        </sect3>

        <sect3 id="log-level">
          <title>Log Level</title>

          <para>This option usually refers to the syslog log level and
          is used with firewalls support logging via syslog
          protocol. Here is the list of the standard log levels:
          'debug', 'info', 'notice', 'warning', 'error', 'crit',
          'alert' </para>
        </sect3>

        <sect3 id="log-facility">
          <title>Log facility</title>

          <para>This option usually refers to the syslog facility
          parameter and is used with firewalls that support logging
          via syslog protocol. The facility is one of the following
          keywords: auth, priv, cron, daemon, kern, lpr, mail, mark,
          news, syslog, user, uucp and local0 through local7. </para>
        </sect3>

        <sect3 id="log-prefix">
          <title>Custom Logging Prefixes</title>

          <para>Custom string that shows up in the log together with
          information logged for each rule that has 'logging' option
          activated. Firewall Builder supports the following macros in
          the log prefix that are expanded at the compile time:</para>

          <para>
            <informaltable frame="none" pgwide="0">
              <tgroup cols="2" align="char" charoff="0.5in" char=" ">
                <colspec colwidth="0.5in">
                <colspec colwidth="3.5in">
                <tbody>
                  <row>
                    <entry>%N</entry>
                    <entry> rule number in the GUI.</entry>
                  </row>

                  <row>
                    <entry>%A</entry>
                    <entry> rule action</entry>
                  </row>

                  <row>
                    <entry>%I</entry>
                    <entry> interface the rule is associated
                        with</entry>
                  </row>

                  <row>
                    <entry>%C</entry>
                    <entry> (iptables only) iptables
                    chain this rule generated code for.</entry>
                  </row>

                </tbody>
              </tgroup>
            </informaltable>
          </para>
        </sect3>

        <sect3 id="virt-addr-for-nat">
          <title>Create Virtual Addresses for NAT Rules</title>

          <para>Compiler can generate commands to add virtual address
          to one of the interfaces of the firewall machine if this
          option is turned on. This is needed if a NAT rule uses IP
          address that does not belong to any interface of the
          firewall.  Firewall either needs static 'published' ARP
          entry for this address, or it should be added to one of the
          interfaces as an 'alias' or virtual address. </para>

          <para>Policy compiler adds code to add 'alias' address to
          interface on top of the firewall activation
          script. Depending on the OS the firewall is running on, it
          may use <filename>ifconfig</filename> (FreeBSD, OpenBSD,
          Solaris) or <filename>ip</filename> (Linux) to do
          that.</para>

          <para>The activation script also adds virtual addresses to
          interfaces of the firewall if such addresses are configured
          in the firewall object in the GUI but are missing on the
          real firewall.</para>
        </sect3>

        <sect3 id="action-on-reject">
          <title>Default setting for rules using 'Reject' action</title>

          <para>When rule with action 'Reject' matches the packet, it
          not only blocks it, but also sends a message back to sender
          to notify them that their original packet has been denied
          access. The firewall can send back several types of ICMP
          'unreachable' messages or TCP RST packet, depending on the
          setting of this option and service object used in the
          rule.</para>
        </sect3>

        <sect3 id="script-debug">
          <title>Turn on debugging in the generated script</title>

          <para>This option makes generated firewall script print all
          commands when it is executed. Depending on the format of the
          target firewall configuration, policy compiler choses
          appropriate command line option or a configuration flag to
          indicate debugging. For example, configuration for iptables
          is just a shell script. In this case compiler adds
          <parameter>"-x"</parameter> to the shell command
          line. For PF compiler generates two files: an activation
          script and <filename>"pf.conf"</filename>
          file. In this case compiler not only adds
          <parameter>"-x"</parameter> to the shell command
          line but also passes <parameter>"-v"</parameter>
          to the utility <filename>pfctl</filename> which
          activates firewall confguration. </para>
        </sect3>
      </sect2>

<!-- ===================================== IPTABLES ============================== -->
      <sect2>
        <title>iptables</title>

        <figure id="fw-iptables" float="1">
          <title>Firewall Object, tab 'Firewall' for iptables</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="fw-iptables.png" format="png" align="Left" scale="50">
            </imageobject>
          </mediaobject>
        </figure>

        <para>
          <table frame="topbot" pgwide="0">
            <title>General</title>
            <tgroup cols="2" align="char" charoff="0.5in" char=" ">
              <colspec colwidth="2in" colsep="1">
              <colspec colwidth="4in">
              <thead>
                <row rowsep="1">
                  <entry>GUI control</entry>
                  <entry>Description</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry><guimenuitem>Version:</guimenuitem></entry>
                  <entry>Version of iptables used on the firewall machine.</entry>
                </row>
              </tbody>
            </tgroup>
          </table>
        </para>

        <para>
          <table frame="topbot" pgwide="0">
            <title>Global Logging Parameters</title>
            <tgroup cols="2" align="char" charoff="0.5in" char=" ">
              <colspec colwidth="2in" colsep="1">
              <colspec colwidth="4in">
              <thead>
                <row rowsep="1">
                  <entry>GUI control</entry>
                  <entry>Description</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry><guimenuitem>Use LOG</guimenuitem></entry>
                  <entry>Use standard target LOG for logging (as opposed to using ULOG)</entry>
                </row>
                <row>
                  <entry><guimenuitem>log TCP seq. numbers</guimenuitem></entry>
                  <entry>Log TCP sequence numbers.</entry>
                </row>
                <row>
                  <entry><guimenuitem>log TCP options</guimenuitem></entry>
                  <entry>Log options from the TCP packet header. </entry>
                </row>
                <row>
                  <entry><guimenuitem>log IP options</guimenuitem></entry>
                  <entry>Log options from the IP packet header. </entry>
                </row>
                <row>
                  <entry><guimenuitem>Use numeric syslog levels</guimenuitem></entry>
                  <entry>Use numeric setting for &quot;--log-level&quot;. This
                    option was introduced as a workaround for a bug in
                    iptables 1.2.3 which could not interpret properly
                    standard symbolic syslog level (priority) names
                    'debug', 'info', 'notice', 'warning', 'error',
                    'crit', 'alert' </entry>
                </row>
                <row>
                  <entry><guimenuitem>Log level</guimenuitem></entry>
                  <entry> See <xref linkend="log-level"> </entry>
                </row>
                <row>
                  <entry><guimenuitem>Use ULOG</guimenuitem></entry>
                  <entry>Use ULOG target for more advanced packet
                    logging mechanism. The ULOG target is only
                    available if corresponding patch is applied to
                    iptables. See <ulink url="http://www.gnumonks.org/projects/ulogd">http://www.gnumonks.org/projects/ulogd</ulink>
                    </entry>
                </row>
                <row>
                  <entry><guimenuitem>cprange</guimenuitem></entry>
                  <entry>Number of bytes to be copied to userspace. A
                    value of 0 always copies the entire packet,
                    regardless of its size. Default is 0</entry>
                </row>
                <row>
                  <entry><guimenuitem>queue thrershold</guimenuitem></entry>
                  <entry>Sets the amount of packets batched together
                    in one multipart netlink message.</entry>
                </row>
                <row>
                  <entry><guimenuitem>Netlink Group</guimenuitem></entry>
                  <entry>This specifies the netlink group (1-32) to
                    which the packet is sent.  Default value is
                    1.</entry>
                </row>
                <row>
                  <entry><guimenuitem>Log Prefix</guimenuitem></entry>
                  <entry> See <xref linkend="log-prefix"></entry>
                </row>
                <row>
                  <entry><guimenuitem>Log all dropped packets</guimenuitem></entry>
                  <entry>This option makes firewall log all packets
                    it drops, including those that do not match any
                    entry in the state table and some others. This
                    option can only be used if corresponding patch has
                    been applied to iptables running on the
                    firewall. Patch is called 'dropped-table' and is
                    part of patch-o-matic.</entry>
                </row>
                <row>
                  <entry><guimenuitem>Logging limit:</guimenuitem></entry>
                  <entry>This option allows to set a limit on the
                    number of log entries that the firewall records
                    per unit of time. This could be useful on high
                    traffic firewalls, where writing too much to the
                    log can overload disk subsystem.</entry>
                </row>
                <row>
                  <entry><guimenuitem>Turn logging ON on all rules</guimenuitem></entry>
                  <entry>This option overrides logging option in each
                    rule to make the firewall act as if logging was
                    turned on on each rule. This is useful for the
                    policy debugging.</entry>
                </row>
              </tbody>
            </tgroup>
          </table>
        </para>

        <para>
          <table frame="topbot" pgwide="0">
            <title>Options</title>
            <tgroup cols="2" align="char" charoff="0.5in" char=" ">
              <colspec colwidth="2in" colsep="1">
              <colspec colwidth="4in">
              <thead>
                <row rowsep="1">
                  <entry>GUI control</entry>
                  <entry>Description</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>Default action on 'Reject'</entry>
                  <entry> See <xref linkend="action-on-reject"></entry>
                </row>
                <row>
                  <entry><guimenuitem>Turn off optimization in
                    compiler</guimenuitem></entry>
                  <entry>This option turns off some optimization
                    algorithms in the policy compiler.</entry>
                </row>
                <row>
                  <entry><guimenuitem>Load modules</guimenuitem></entry>
                  <entry>Compiler generates code to load iptables
                    kernel modules before activating policy
                    rules.</entry>
                </row>
                <row>
                  <entry><guimenuitem>Verify interfaces before
                    loading firewall policy</guimenuitem></entry>
                  <entry>Compiler generates code to check if
                    interfaces configured in the firewall object exist
                    in the real firewall machine. This check is
                    executed before policy rules are loaded. If the
                    check fails, firewall policy won't be modified.
                    </entry>
                </row>
                <row>
                  <entry><guimenuitem>Assume firewall object is part
                    of 'any'</guimenuitem></entry>
                  <entry> See <xref linkend="fw-is-part-of-any"></entry>
                </row>
                <row>
                  <entry><guimenuitem>Clamp MSS to
                    MTU</guimenuitem></entry>
                  <entry>This option allows you to examine and alter
                    the MSS value of TCP SYN packets, to control the
                    maximum size for that connection. This option can
                    only be used if corresponding patch from
                    patch-o-matic is applied to iptables running on
                    the firewall.</entry>
                </row>
                <row>
                  <entry><guimenuitem>Accept TCP sessions opened
                    prior to firewall restart</guimenuitem></entry>
                  <entry>If this option is ON, firewall will accept
                    TCP sessions opened before firewall software has
                    been activated. These sessions are special because
                    firewall never saw their initiation phase. If this
                    option is on, the firewall creates an entry in
                    the state table when it sees a packet that
                    apparently belongs to the unknown TCP session.
                    </entry>
                </row>
                <row>
                  <entry><guimenuitem>Accept ESTABLISHED and RELATED
                    packets before the first rule</guimenuitem></entry>

                  <entry> This option generates implicit rule to
                  accept ESTABLISHED and RELATED packets before the
                  very first rule specified in the GUI. This helps to
                  reduce the size of the policy script generated by
                  policy compiler. ESTABLISHED packets are basically
                  reply packets coming back from the server to the
                  client. Iptables keeps state information about each
                  TCP session opened through the firewall and thus can
                  detect and permit this kind of packets
                  automatically. RELATED packets belong to another
                  stream somehow associated with initial stream opened
                  through the firewall. FTP protocol is a good example
                  of this situation.  FTP uses TCP sessions: command
                  channel and data channel. You do not need to add
                  special rule for the data channel to your policy
                  because iptables 'understands' when it needs to
                  permit packets that belong to the data channel that
                  has been created per request sent via known command
                  channel.  This option is ON by default.  If by some
                  reason you do not want to have an implicit rule to
                  permit these types of packets on top of all rules
                  defined in the GUI, you should uncheck this
                  option. Remember that in this case you need to add a
                  rule to permit these types of packets yourself. You
                  can use Custom Service object 'ESTABLISHED' in this
                  rule. This service object can be found in the
                  'Standard' object tree.  </entry>
                </row>
                <row>
                  <entry><guimenuitem>Bridging firewall</guimenuitem></entry>
                  <entry>This option changes algorithms used by the
                    policy compiler and makes it generate script for a
                    bridging firewall. Bridging firewall treats
                    broadcast packets differently, never uses INPUT
                    and OUTPUT chains and has some other
                    differences.</entry>
                </row>
                <row>
                  <entry><guimenuitem>Detect rule shadowing in
                    policy</guimenuitem></entry>
                  <entry> See <xref linkend="rule-shadowing"></entry>
                </row>
                <row>
                  <entry><guimenuitem>Ignore empty groups in
                    rules</guimenuitem></entry>
                  <entry> See <xref linkend="empty-groups"></entry>
                </row>
                <row>
                  <entry><guimenuitem>Turn on debug output in
                    iptables script</guimenuitem></entry>
                  <entry> See <xref linkend="script-debug"></entry>
                </row>
                <row>
                  <entry><guimenuitem>Create virtual addresses for
                    NAT rules</guimenuitem></entry>
                  <entry> See <xref linkend="virt-addr-for-nat"></entry>
                </row>
              </tbody>
            </tgroup>
          </table>

        </para>


      </sect2>

<!-- ===================================== IPF ================================== -->
      <sect2>
        <title>ipfilter</title>

        <figure id="fw-ipf" float="1">
          <title>Firewall Object, tab 'Firewall' for ipfilter</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="fw-ipf.png" format="png" align="Left" scale="50">
            </imageobject>
          </mediaobject>
        </figure>

        <para>
          <table frame="topbot" pgwide="0">
            <title>General</title>
            <tgroup cols="2" align="char" charoff="0.5in" char=" ">
              <colspec colwidth="2in" colsep="1">
              <colspec colwidth="4in">
              <thead>
                <row rowsep="1">
                  <entry>GUI control</entry>
                  <entry>Description</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry><guimenuitem>Version</guimenuitem></entry>
                  <entry>OS version the firewall is running on</entry>
                </row>
              </tbody>
            </tgroup>
          </table>
        </para>

        <para>
          <table frame="topbot" pgwide="0">
            <title>Options</title>
            <tgroup cols="2" align="char" charoff="0.5in" char=" ">
              <colspec colwidth="2in" colsep="1">
              <colspec colwidth="4in">
              <thead>
                <row rowsep="1">
                  <entry>GUI control</entry>
                  <entry>Description</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry><guimenuitem>Generate both 'in' and 'out'
                    rules</guimenuitem></entry>
                  <entry>There are two ways compiler can generate
                    code for rules in the Global Policy: it can either
                    create two pf rules for one rule in the GUI to
                    control both incoming and outgoing packets, or it
                    can create only one pf rule for incoming packets
                    and always permit all outgoing packets. If this
                    option is ON, the compiler creates rules for
                    incoming and outgoing packets. This way you get
                    more control over the data flows crossing your
                    firewall, but the configuration is going to be
                    larger. This option is common for compilers for
                    <emphasis>ipfilter</emphasis> and <emphasis>pf</emphasis>
                    </entry>
                </row>
                <row>
                  <entry><guimenuitem>Pass all outgoing</guimenuitem></entry>
                  <entry>See above. If this option is ON, the
                    compiler puts implicit rule to permit all outgoing
                    packets on the top of the policy and then creates
                    rules only for incoming packets. This way you get
                    smaller confguration but have little control over
                    outgoing sessions.  This option is common for
                    compilers for <emphasis>ipfilter</emphasis> and
                    <emphasis>pf</emphasis></entry>
                </row>
                <row>
                  <entry><guimenuitem>Find and eliminate duplicate rules</guimenuitem></entry>
                  <entry> See <xref linkend="duplicate-rules"></entry>
                </row>
                <row>
                  <entry><guimenuitem>Detect rule shadowing in policy</guimenuitem></entry>
                  <entry> See <xref linkend="rule-shadowing"></entry>
                </row>
                <row>
                  <entry><guimenuitem>Ignore empty groups in rules</guimenuitem></entry>
                  <entry> See <xref linkend="empty-groups"></entry>
                </row>
                <row>
                  <entry><guimenuitem>Turn on debug output in the
                    script</guimenuitem></entry>
                  <entry> See <xref linkend="script-debug"></entry>
                </row>
                <row>
                  <entry><guimenuitem>Create virtual addresses for
                    NAT rules</guimenuitem></entry>
                  <entry> See <xref linkend="virt-addr-for-nat"></entry>
                </row>
                <row>
                  <entry><guimenuitem>Directory where firewall
                    configuration files should be
                    installed</guimenuitem></entry>
                  <entry>This parameter tells firewall initialization
                    script produced by the compiler where firewall
                    configuration file is going to be located.</entry>
                </row>
              </tbody>
            </tgroup>
          </table>
        </para>

        <para>
          <table frame="topbot" pgwide="0">
            <title>Options for action 'Reject'</title>
            <tgroup cols="2" align="char" charoff="0.5in" char=" ">
              <colspec colwidth="2in" colsep="1">
              <colspec colwidth="4in">
              <thead>
                <row rowsep="1">
                  <entry>GUI control</entry>
                  <entry>Description</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry><guimenuitem>Default action on
                    'Reject'</guimenuitem></entry>
                  <entry> See <xref linkend="action-on-reject"></entry>
                </row>
                <row>
                  <entry><guimenuitem>Masquerade returned icmp as
                    being from original packet's
                    destination</guimenuitem></entry>
                  <entry>The firewall will construct icmp
                    'unreachable' packet using source IP of the
                    original packet's destination. This helps to hide
                    the firewall which sits in between the sender and
                    their original destination. If this option is OFF,
                    the icmp 'unreachable' packet has source address
                    of the firewall.
                    </entry>
                </row>
              </tbody>
            </tgroup>
          </table>
        </para>
        

        <para>
          <table frame="topbot" pgwide="0">
            <title>Logging</title>
            <tgroup cols="2" align="char" charoff="0.5in" char=" ">
              <colspec colwidth="2in" colsep="1">
              <colspec colwidth="4in">
              <thead>
                <row rowsep="1">
                  <entry>GUI control</entry>
                  <entry>Description</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry><guimenuitem>Log facility</guimenuitem></entry>
                  <entry> See <xref linkend="log-facility"></entry>
                </row>
                <row>
                  <entry><guimenuitem>Log level</guimenuitem></entry>
                  <entry> See <xref linkend="log-level"> </entry>
                </row>
                <row>
                  <entry><guimenuitem>Block if can not log</guimenuitem></entry>
                  <entry> if for some reason the firewall is unable
                    to log the packet (such as the log reader being
                    too slow) then the rule should be interpreted as
                    if the action was block for this packet.</entry>
                </row>
                <row>
                  <entry><guimenuitem>Log packet body</guimenuitem></entry>
                  <entry> Logs not only packet's header, but also its
                    payload data. </entry>
                </row>
              </tbody>
            </tgroup>
          </table>

        </para>


        <para><guimenuitem>Protocol Helpers: </guimenuitem> IP Filter
        comes with a few, simple, proxies built into the code that is
        loaded into the kernel to allow secondary channels to be
        opened without forcing the packets through a user program. See
        documentation for ipfilter and FAQ for additional
        information.</para>
        
      </sect2>

<!-- ===================================== PF ================================== -->
      <sect2>
        <title>pf</title>

        <figure id="fw-pf" float="1">
          <title>Firewall Object, tab 'Firewall' for pf</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="fw-pf.png" format="png" align="Left" scale="50">
            </imageobject>
          </mediaobject>
        </figure>

        <para>
          <table frame="topbot" pgwide="0">
            <title>General</title>
            <tgroup cols="2" align="char" charoff="0.5in" char=" ">
              <colspec colwidth="2in" colsep="1">
              <colspec colwidth="4in">
              <thead>
                <row>
                  <entry>GUI control</entry>
                  <entry>Description</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry><guimenuitem>Version</guimenuitem></entry>
                  <entry>OS version the firewall is running on</entry>
                </row>
              </tbody>
            </tgroup>
          </table>
        </para>

        <para>
          <table frame="topbot" pgwide="0">
            <title>Options</title>
            <tgroup cols="2" align="char" charoff="0.5in" char=" ">
              <colspec colwidth="2in" colsep="1">
              <colspec colwidth="4in">
              <thead>
                <row>
                  <entry>GUI control</entry>
                  <entry>Description</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry><guimenuitem>Generate both 'in' and 'out' rules</guimenuitem></entry>
                  <entry>There are two ways compiler can generate
                    code for rules in the Global Policy: it can either
                    create two pf rules for one rule in the GUI to
                    control both incoming and outgoing packets, or it
                    can create only one pf rule for incoming packets
                    and always permit all outgoing packets. If this
                    option is ON, the compiler creates rules for
                    incoming and outgoing packets. This way you get
                    more control over the data flows crossing your
                    firewall, but the configuration is going to be
                    larger. This option is common for compilers for
                    <emphasis>ipfilter</emphasis> and <emphasis>pf</emphasis>
                    </entry>
                </row>
                <row>
                  <entry><guimenuitem>Pass all outgoing</guimenuitem></entry>
                  <entry>See above. If this option is ON, the
                    compiler puts implicit rule to permit all outgoing
                    packets on the top of the policy and then creates
                    rules only for incoming packets. This way you get
                    smaller confguration but have little control over
                    outgoing sessions.  This option is common for
                    compilers for <emphasis>ipfilter</emphasis> and
                    <emphasis>pf</emphasis></entry>
                </row>
                <row>
                  <entry><guimenuitem>Run all packets through
                    defragmentation filter</guimenuitem></entry>
                  <entry>This is also called packet
                    normalization. Packet normalization is invoked via
                    the scrub directive.  Normalization is used to
                    sanitize packet content in such a way that there
                    are no ambiguities in packet interpretation on the
                    receiving side. The normalizer does IP fragment
                    reassembly to prevent attacks that confuse
                    intrusion detection systems by sending overlapping
                    IP fragments. See more details in the man page
                    <filename>pf.conf(5)</filename></entry>
                </row>
                <row>
                  <entry><guimenuitem>Modulate state for all stateful
                    rules</guimenuitem></entry>
                  <entry>By applying a &quot;modulate state&quot; rule to a TCP
                    connection, pf will create a high quality random
                    sequence number for each connection endpoint.  The
                    &quot;modulate state&quot; directive implicitly keeps state
                    on the rule and is only applicable to TCP
                    connections. See more details in the man page 
                    <filename>pf.conf(5)</filename></entry>
                </row>
                <row>
                  <entry><guimenuitem>Detect rule shadowing in policy</guimenuitem></entry>
                  <entry> See <xref linkend="rule-shadowing"></entry>
                </row>
                <row>
                  <entry><guimenuitem>Ignore empty groups in rules</guimenuitem></entry>
                  <entry> See <xref linkend="empty-groups"></entry>
                </row>
              </tbody>
            </tgroup>
          </table>

        </para>

        <para>
          <table frame="topbot" pgwide="0">
            <title>Global Logging Parameters</title>
            <tgroup cols="2" align="char" charoff="0.5in" char=" ">
              <colspec colwidth="2in" colsep="1">
              <colspec colwidth="4in">
              <thead>
                <row>
                  <entry>GUI control</entry>
                  <entry>Description</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry><guimenuitem>Log Prefix</guimenuitem></entry>
                  <entry> See <xref linkend="log-prefix"></entry>
                </row>
              </tbody>
            </tgroup>
          </table>
        </para>

        <para>
          <table frame="topbot" pgwide="0">
            <title>Script Options</title>
            <tgroup cols="2" align="char" charoff="0.5in" char=" ">
              <colspec colwidth="2in" colsep="1">
              <colspec colwidth="4in">
              <thead>
                <row>
                  <entry>GUI control</entry>
                  <entry>Description</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry><guimenuitem>Turn on debug output in the
                    script</guimenuitem></entry>
                  <entry> See <xref linkend="script-debug"></entry>
                </row>
                <row>
                  <entry><guimenuitem>Create virtual addresses for
                    NAT rules</guimenuitem></entry>
                  <entry> See <xref linkend="virt-addr-for-nat"></entry>
                </row>
                <row>
                  <entry><guimenuitem>Directory where firewall
                    configuration files should be
                    installed</guimenuitem></entry>
                  <entry>This parameter tells firewall initialization
                    script produced by the compiler where firewall
                    configuration file is going to be located.</entry>
                </row>
              </tbody>
            </tgroup>
          </table>
        </para>

      </sect2>

      <!-- ===================================== PIX ================================= -->
      <sect2>
        <title>PIX</title>

        <figure id="fw-pix" float="1">
          <title>Firewall Object, tab 'Firewall' for PIX</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="fw-pix.png" format="png" align="Left" scale="50">
            </imageobject>
          </mediaobject>
        </figure>

        <para>
        <table frame="topbot" pgwide="0">
            <title>General</title>
            <tgroup cols="2" align="char" charoff="0.5in" char=" ">
              <colspec colwidth="2in" colsep="1">
              <colspec colwidth="4in">
              <thead>
                <row>
                  <entry>GUI control</entry>
                  <entry>Description</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry><guimenuitem>Version</guimenuitem></entry>
                  <entry>Version of the software PIX firewall is running.</entry>
                </row>
                <row>
                  <entry><guimenuitem>Prolog script</guimenuitem></entry>
                  <entry>this is a list of any PIX configuration commands
              that will be included on top of generated configuration
              file. No syntax or other checks are done on commands in
              this list.</entry>
                </row>
                <row>
                  <entry><guimenuitem>Epilog script</guimenuitem></entry>
                  <entry>this is a list of any PIX configuration commands
              that will be appended at the end of generated
              configuration file. No syntax or other checks are done
              on commands in this list</entry>
                </row>
              </tbody>
            </tgroup>
          </table>
        </para>

        <para>
          <table frame="topbot" pgwide="0">
            <title>Policy compiler options</title>
            <tgroup cols="2" align="char" charoff="0.5in" char=" ">
              <colspec colwidth="2in" colsep="1">
              <colspec colwidth="4in">
              <thead>
                <row>
                  <entry>GUI control</entry>
                  <entry>Description</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry><guimenuitem>Assume firewall is part of 'any'</guimenuitem></entry>
                  <entry> See <xref linkend="fw-is-part-of-any"></entry>
                </row>
                <row>
                  <entry><guimenuitem>Replace NAT'ed objects with
                    their translations in policy rules
                    </guimenuitem></entry>
                  <entry>PIX inspects packet with access lists before
                    it performs address translation. Many other
                    firewall platforms do it the other way
                    around. This option turns on emulation of the
                    firewall that does NAT first.
                    </entry>
                </row>
                <row>
                  <entry><guimenuitem>Emulate outbound ACLs</guimenuitem></entry>
                  <entry>Normally PIX does not support outbound
                    access lists.This option turns on an emulation of
                    outbound ACLs</entry>
                </row>
                <row>
                  <entry><guimenuitem>Generate 'clear' commands</guimenuitem></entry>
                  <entry>If this option is ON, compiler generates
                    <emphasis>'clear'</emphasis> commands to reset any pre-existing
                    access lists, object-group, nat, global, static,
                    telnet, ssh and other commands.</entry>
                </row>
                <row>
                  <entry><guimenuitem>Optimize 'default nat' rules</guimenuitem></entry>
                  <entry>This option simplifies nat rules if object
                    in Original Source is the same as the Network zone
                    of one of the interfaces. Network zone of the
                    interfaces defines all networks that are located
                    &quot;behind&quot; this interface. This means that packets
                    entering the interface may have source address
                    only belonging to the Network zone of this
                    interface. Since policy compiler can correctly
                    assign nat rule to the interface using information
                    about its Network Zone, explicit specification of
                    the source address can be omitted.
                    </entry>
                </row>
                <row>
                  <entry><guimenuitem>Ignore empty groups in rules</guimenuitem></entry>
                  <entry> See <xref linkend="empty-groups"></entry>
                </row>
              </tbody>
            </tgroup>
          </table>

            </para>

        <para>

          <table frame="topbot" pgwide="0">
            <title>Script formatting</title>
            <tgroup cols="2" align="char" charoff="0.5in" char=" ">
              <colspec colwidth="2in" colsep="1">
              <colspec colwidth="4in">
              <thead>
                <row>
                  <entry>GUI control</entry>
                  <entry>Description</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry><guimenuitem>Comment the code</guimenuitem></entry>
                  <entry>If this option is activated, compiler adds
                    comments to the configuration file</entry>
                </row>
                <row>
                  <entry><guimenuitem>Group similar commands
                    together</guimenuitem></entry>
                  <entry>If this option is activated, compiler groups
                    similar commands next to each other, just like PIX
                    device does it in the output of &quot;show config&quot;
                    command. Otherwise commands are grouped logically:
                    first go all object-group commands, then all
                    access-lists, then all nat, global and static
                    commands. Commands access-list, nat, global and
                    static are grouped by the rules they were
                    generated for, as they appear in the GUI. If one
                    rule requires several access-list commands
                    assigned to different interfaces, these commands
                    are grouped together. Command &quot;show conf&quot; groups
                    access-list commands by their interface.</entry>
                </row>
              </tbody>
            </tgroup>
          </table>

            </para>

        <para>

          <table frame="topbot" pgwide="0">
            <title>Verification of policy rules</title>
            <tgroup cols="2" align="char" charoff="0.5in" char=" ">
              <colspec colwidth="2in" colsep="1">
              <colspec colwidth="4in">
              <thead>
                <row>
                  <entry>GUI control</entry>
                  <entry>Description</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry><guimenuitem>Detect rule shadowing in the
                    policy</guimenuitem></entry>
                  <entry> See <xref linkend="rule-shadowing"></entry>
                </row>
              </tbody>
            </tgroup>
          </table>

            </para>

        <para>

          <table frame="topbot" pgwide="0">
            <title>Verification of NAT rules</title>
            <tgroup cols="2" align="char" charoff="0.5in" char=" ">
              <colspec colwidth="2in" colsep="1">
              <colspec colwidth="4in">
              <thead>
                <row>
                  <entry>GUI control</entry>
                  <entry>Description</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry><guimenuitem>Check for duplicate nat rules </guimenuitem></entry>
                  <entry>If this option is activated, compiler checks
                    generated configuration for duplicate <emphasis>'nat'</emphasis>
                    commands
                    </entry>
                </row>
                <row>
                  <entry><guimenuitem>Check for overlapping global pools </guimenuitem></entry>
                  <entry>If this option is activated, compiler checks
                    generated configuration for overlapping
                    <emphasis>'global'</emphasis> address pools
                    </entry>
                </row>
                <row>
                  <entry><guimenuitem>Check for overlapping statics</guimenuitem></entry>
                  <entry>If this option is activated, compiler checks
                    generated configuration for <emphasis>'static'</emphasis>
                    commands that use overlapping address
                    ranges.</entry>
                </row>
                <row>
                  <entry><guimenuitem>Check for overlapping global
                    pools and statics</guimenuitem></entry>
                  <entry>If this option is activated, compiler checks
                    generated configuration for <emphasis>'global'</emphasis> and
                    'static commands using overlapping address
                    ranges.</entry>
                </row>
              </tbody>
            </tgroup>
          </table>

            </para>


<!-- ===================================== PIX Advanced ========================= -->
        <sect3>
          <title>'Advanced' firewall setting dialog for PIX</title>

          <para>Clicking button <guimenuitem>'Advanced'</guimenuitem>
          in the 'Firewall' tab of the PIX firewall object brings up a
          new dialog. This dialog helps configure protocol timeouts,
          <emphasis>'fixup'</emphasis> commands, logging and some
          other general configuration option.</para>

          <para>
            <figure id="pix-fw-adv-timeout" float="1">
              <title>Configuring protocol timeouts.</title>
              <mediaobject>
                <imageobject>
                  <imagedata fileref="fw-pix-adv-timeouts.png" 
                             format="png" align="Left" scale="50">
                </imageobject>
              </mediaobject>
            </figure>
          </para>

          <para>Parameters set in this dialog are mapped directly to
          the <emphasis>'timeout'</emphasis> command in the PIX
          configuration which sets timeout values for various
          protocols supported by PIX. Clicking button
          <guimenuitem>'Set all to defaults'</guimenuitem> resets all
          timeout parameters to their default values.</para>

          <para>
            <figure id="pix-fw-adv-fixups" float="1">
              <title>Configuring protocol helpers ('fixup' commands).</title>
              <mediaobject>
                <imageobject>
                  <imagedata fileref="fw-pix-adv-fixups.png" 
                             format="png" align="Left" scale="50">
                </imageobject>
              </mediaobject>
            </figure>
          </para>

          <para>Parameters set in this dialog are mapped to the
          <emphasis>'fixup'</emphasis> commands in the PIX
          configuration. Button <guimenuitem>'Add'</guimenuitem> adds
          new parameter of the type chosen in the drop-down menu to
          the left. Clicking button <emphasis>'Delete'</emphasis>
          deletes corresponding parameter. Clicking button
          <emphasis>'Set all to defaults'</emphasis> returns all
          settings to their default values. </para>

          <para>
            <figure id="pix-fw-adv-logging" float="1">
              <title>Configuring logging parameters.</title>
              <mediaobject>
                <imageobject>
                  <imagedata fileref="fw-pix-adv-logging.png" 
                             format="png" align="Left" scale="50">
                </imageobject>
              </mediaobject>
            </figure>
          </para>

          <para>This dialog helps configure logging parameters for the
          PIX firewall:</para>

          <para>
            <table frame="topbot" pgwide="0">
              <title>Syslog</title>
              <tgroup cols="2" align="char" charoff="0.5in" char=" ">
                <colspec colwidth="2in" colsep="1">
                <colspec colwidth="4in">
                <thead>
                  <row>
                    <entry>GUI control</entry>
                    <entry>Description</entry>
                  </row>
                </thead>
                <tbody>
                  <row>
                    <entry><guimenuitem>Syslog host</guimenuitem></entry>
                    <entry>This is an address of the syslog host the
                      firewall will send all logging to.</entry>
                  </row>
                  <row>
                    <entry><guimenuitem>syslog message queue size</guimenuitem></entry>
                    <entry>The size of internal logging queue, in messages.</entry>
                  </row>
                  <row>
                    <entry><guimenuitem>Facility</guimenuitem></entry>
                    <entry> Syslog facility, See <xref linkend="log-facility"></entry>
                  </row>
                  <row>
                    <entry><guimenuitem>Level</guimenuitem></entry>
                    <entry> Syslog level, See <xref linkend="log-level"></entry>
                  </row>
                </tbody>
              </tgroup>
            </table>

          </para>

          <para>
            <table frame="topbot" pgwide="0">
              <title>Other logging destinations, levels and parameters</title>
              <tgroup cols="2" align="char" charoff="0.5in" char=" ">
                <colspec colwidth="2in" colsep="1">
                <colspec colwidth="4in">
                <thead>
                  <row>
                    <entry>GUI control</entry>
                    <entry>Description</entry>
                  </row>
                </thead>
                <tbody>
                  <row>
                    <entry><guimenuitem>Internal buffer</guimenuitem></entry>
                    <entry>Send syslog messages to an internal buffer
                      that can be viewed with the show logging
                      command. The level pull-down menu allows to set
                      a minimal logging level of messages that are
                      going to be recorded.</entry>
                  </row>
                  <row>
                    <entry><guimenuitem>Console</guimenuitem></entry>
                    <entry> Specify that syslog messages appear on
                      the PIX Firewall console as each message
                      occurs. You can limit the types of messages that
                      appear on the console with level.</entry>
                  </row>
                  <row>
                    <entry>Logging timestamps</entry>
                    <entry>Specify that syslog messages sent to the
                    syslog server should have a time stamp value on
                    each message. </entry>
                  </row>
                </tbody>
              </tgroup>
            </table>

          </para>

          <para>
            <figure id="pix-fw-adv-options" float="1">
              <title>Configuring other parameters.</title>
              <mediaobject>
                <imageobject>
                  <imagedata fileref="fw-pix-adv-options.png" 
                             format="png" align="Left" scale="50">
                </imageobject>
              </mediaobject>
            </figure>
          </para>

          <para>This dialog helps configure some global parameters for
          the PIX firewall. See PIX documentation for detailed
          explanation of each command.</para>


          <table frame="topbot" pgwide="0">
            <title>Global parameters controlled through the 'Advanced' firewall dialog</title>

            <tgroup cols="2" align="char" charoff="0.5in" char=" ">
              <colspec colwidth="4in" colsep="1">
              <colspec colwidth="2in">
              <thead>
                <row>
                  <entry>GUI control</entry>
                  <entry>PIX command</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>Actively reset inbound TCP connections with RST</entry>
                  <entry><emphasis>service resetinbound</emphasis></entry>
                </row>
                <row>
                  <entry>Actively reset inbound TCP connections with RST on outside interface</entry>
                  <entry><emphasis>service resetoutside</emphasis></entry>
                </row>
                <row>
                  <entry>Force each TCP connection to linger in a shortened TIME_WAIT</entry>
                  <entry><emphasis>sysopt connection timewait</emphasis></entry>
                </row>
                <row>
                  <entry>Enable the IP Frag Guard feature</entry>
                  <entry><emphasis>sysopt security fragguard</emphasis></entry>
                </row>
                <row>
                  <entry>Enable TCP resource control for AAA Authentication proxy</entry>
                  <entry><emphasis>floodguard enable</emphasis></entry>
                </row>
                <row>
                  <entry>Specify that when an incoming packet
              does a route lookup, the incoming interface is used to
              determine which interface the packet should go to, and
              which is the next hop. </entry>
                  <entry><emphasis>sysopt route dnat</emphasis></entry>
                </row>
                <row>
                  <entry>Disable inbound embedded DNS A record fixups</entry>
                  <entry><emphasis>sysopt nodnsalias inbound</emphasis></entry>
                </row>
                <row>
                  <entry>Disable outbound DNS A record replies</entry>
                  <entry><emphasis>sysopt nodnsalias outbound</emphasis></entry>
                </row>
              </tbody>
            </tgroup>
          </table>


        </sect3>
      </sect2>

    </sect1>


      <!-- ===================================== OS ================================= -->
    <sect1>
      <title>Configuring Host OS </title>
      <!-- one of (CALLOUTLIST GLOSSLIST ITEMIZEDLIST ORDEREDLIST SEGMENTEDLIST SIMPLELIST VARIABLELIST CAUTION IMPORTANT NOTE TIP WARNING LITERALLAYOUT PROGRAMLISTING PROGRAMLISTINGCO SCREEN SCREENCO SCREENSHOT SYNOPSIS CMDSYNOPSIS FUNCSYNOPSIS CLASSSYNOPSIS FIELDSYNOPSIS CONSTRUCTORSYNOPSIS DESTRUCTORSYNOPSIS METHODSYNOPSIS FORMALPARA PARA SIMPARA ADDRESS BLOCKQUOTE GRAPHIC GRAPHICCO MEDIAOBJECT MEDIAOBJECTCO INFORMALEQUATION INFORMALEXAMPLE INFORMALFIGURE INFORMALTABLE EQUATION EXAMPLE FIGURE TABLE MSGSET PROCEDURE SIDEBAR QANDASET ANCHOR BRIDGEHEAD REMARK HIGHLIGHTS ABSTRACT AUTHORBLURB EPIGRAPH INDEXTERM REFENTRY SECT2 SIMPLESECT) -->

      <para>Firewall object's dialog tab 'Network' provides set of
      controls to manipulate network settings and some kernel
      parameters for the host OS firewall machine is running on.</para>

      <sect2>
        <title>FreeBSD</title>
        <!-- one of (CALLOUTLIST GLOSSLIST ITEMIZEDLIST ORDEREDLIST SEGMENTEDLIST SIMPLELIST VARIABLELIST CAUTION IMPORTANT NOTE TIP WARNING LITERALLAYOUT PROGRAMLISTING PROGRAMLISTINGCO SCREEN SCREENCO SCREENSHOT SYNOPSIS CMDSYNOPSIS FUNCSYNOPSIS CLASSSYNOPSIS FIELDSYNOPSIS CONSTRUCTORSYNOPSIS DESTRUCTORSYNOPSIS METHODSYNOPSIS FORMALPARA PARA SIMPARA ADDRESS BLOCKQUOTE GRAPHIC GRAPHICCO MEDIAOBJECT MEDIAOBJECTCO INFORMALEQUATION INFORMALEXAMPLE INFORMALFIGURE INFORMALTABLE EQUATION EXAMPLE FIGURE TABLE MSGSET PROCEDURE SIDEBAR QANDASET ANCHOR BRIDGEHEAD REMARK HIGHLIGHTS ABSTRACT AUTHORBLURB EPIGRAPH INDEXTERM REFENTRY SECT3 SIMPLESECT) -->

        <figure id="fw-freebsd" float="1">
          <title>Firewall Object, tab 'Network' for FreeBSD</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="fw-freebsd.png" format="png" align="Left" scale="50">
            </imageobject>
          </mediaobject>
        </figure>

      </sect2>

      <sect2>
        <title>Linux</title>
        <!-- one of (CALLOUTLIST GLOSSLIST ITEMIZEDLIST ORDEREDLIST SEGMENTEDLIST SIMPLELIST VARIABLELIST CAUTION IMPORTANT NOTE TIP WARNING LITERALLAYOUT PROGRAMLISTING PROGRAMLISTINGCO SCREEN SCREENCO SCREENSHOT SYNOPSIS CMDSYNOPSIS FUNCSYNOPSIS CLASSSYNOPSIS FIELDSYNOPSIS CONSTRUCTORSYNOPSIS DESTRUCTORSYNOPSIS METHODSYNOPSIS FORMALPARA PARA SIMPARA ADDRESS BLOCKQUOTE GRAPHIC GRAPHICCO MEDIAOBJECT MEDIAOBJECTCO INFORMALEQUATION INFORMALEXAMPLE INFORMALFIGURE INFORMALTABLE EQUATION EXAMPLE FIGURE TABLE MSGSET PROCEDURE SIDEBAR QANDASET ANCHOR BRIDGEHEAD REMARK HIGHLIGHTS ABSTRACT AUTHORBLURB EPIGRAPH INDEXTERM REFENTRY SECT3 SIMPLESECT) -->

        <figure id="fw-linux24" float="1">
          <title>Firewall Object, tab 'Network' for Linux</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="fw-linux24.png" format="png" align="Left" scale="50">
            </imageobject>
          </mediaobject>
        </figure>

      </sect2>

      <sect2>
        <title>OpenBSD</title>
        <!-- one of (CALLOUTLIST GLOSSLIST ITEMIZEDLIST ORDEREDLIST SEGMENTEDLIST SIMPLELIST VARIABLELIST CAUTION IMPORTANT NOTE TIP WARNING LITERALLAYOUT PROGRAMLISTING PROGRAMLISTINGCO SCREEN SCREENCO SCREENSHOT SYNOPSIS CMDSYNOPSIS FUNCSYNOPSIS CLASSSYNOPSIS FIELDSYNOPSIS CONSTRUCTORSYNOPSIS DESTRUCTORSYNOPSIS METHODSYNOPSIS FORMALPARA PARA SIMPARA ADDRESS BLOCKQUOTE GRAPHIC GRAPHICCO MEDIAOBJECT MEDIAOBJECTCO INFORMALEQUATION INFORMALEXAMPLE INFORMALFIGURE INFORMALTABLE EQUATION EXAMPLE FIGURE TABLE MSGSET PROCEDURE SIDEBAR QANDASET ANCHOR BRIDGEHEAD REMARK HIGHLIGHTS ABSTRACT AUTHORBLURB EPIGRAPH INDEXTERM REFENTRY SECT3 SIMPLESECT) -->

        <figure id="fw-openbsd" float="1">
          <title>Firewall Object, tab 'Network' for OpenBSD</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="fw-openbsd.png" format="png" align="Left" scale="50">
            </imageobject>
          </mediaobject>
        </figure>

      </sect2>

      <sect2>
        <title>Solaris</title>
        <!-- one of (CALLOUTLIST GLOSSLIST ITEMIZEDLIST ORDEREDLIST SEGMENTEDLIST SIMPLELIST VARIABLELIST CAUTION IMPORTANT NOTE TIP WARNING LITERALLAYOUT PROGRAMLISTING PROGRAMLISTINGCO SCREEN SCREENCO SCREENSHOT SYNOPSIS CMDSYNOPSIS FUNCSYNOPSIS CLASSSYNOPSIS FIELDSYNOPSIS CONSTRUCTORSYNOPSIS DESTRUCTORSYNOPSIS METHODSYNOPSIS FORMALPARA PARA SIMPARA ADDRESS BLOCKQUOTE GRAPHIC GRAPHICCO MEDIAOBJECT MEDIAOBJECTCO INFORMALEQUATION INFORMALEXAMPLE INFORMALFIGURE INFORMALTABLE EQUATION EXAMPLE FIGURE TABLE MSGSET PROCEDURE SIDEBAR QANDASET ANCHOR BRIDGEHEAD REMARK HIGHLIGHTS ABSTRACT AUTHORBLURB EPIGRAPH INDEXTERM REFENTRY SECT3 SIMPLESECT) -->

        <figure id="fw-solaris" float="1">
          <title>Firewall Object, tab 'Network' for Solaris</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="fw-solaris.png" format="png" align="Left" scale="50">
            </imageobject>
          </mediaobject>
        </figure>

      </sect2>

      <sect2>
        <title>PIX</title>
        <!-- one of (CALLOUTLIST GLOSSLIST ITEMIZEDLIST ORDEREDLIST SEGMENTEDLIST SIMPLELIST VARIABLELIST CAUTION IMPORTANT NOTE TIP WARNING LITERALLAYOUT PROGRAMLISTING PROGRAMLISTINGCO SCREEN SCREENCO SCREENSHOT SYNOPSIS CMDSYNOPSIS FUNCSYNOPSIS CLASSSYNOPSIS FIELDSYNOPSIS CONSTRUCTORSYNOPSIS DESTRUCTORSYNOPSIS METHODSYNOPSIS FORMALPARA PARA SIMPARA ADDRESS BLOCKQUOTE GRAPHIC GRAPHICCO MEDIAOBJECT MEDIAOBJECTCO INFORMALEQUATION INFORMALEXAMPLE INFORMALFIGURE INFORMALTABLE EQUATION EXAMPLE FIGURE TABLE MSGSET PROCEDURE SIDEBAR QANDASET ANCHOR BRIDGEHEAD REMARK HIGHLIGHTS ABSTRACT AUTHORBLURB EPIGRAPH INDEXTERM REFENTRY SECT3 SIMPLESECT) -->

        <figure id="fw-pix-os" float="1">
          <title>Firewall Object, tab 'Network' for PIX</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="fw-pix-os.png" format="png" align="Left" scale="50">
            </imageobject>
          </mediaobject>
        </figure>

      </sect2>
    </sect1>


    <sect1 id="firewall-interface">
      <title>Firewall's Interface</title>

      <figure id="firewall-interface1" float="1">
        <title>The Interface Object belonging to a firewall</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="firewall_interface1.jpg" 
                format="jpg" align="Left" scale="50">
          </imageobject>
        </mediaobject>
      </figure>

      <para>The dialogue for the interface object that belongs to a
        firewall is similar to that for the Host's interface (<xref
        linkend="host-interface">) but has a few extra controls.
        </para>

      <para>The interfaces of the firewall have a parameter called
        <emphasis>"Security Level"</emphasis>. Depending on the
        firewall platform, the security level may either have two
        values <emphasis>"External"/"Internal"</emphasis> or a numeric
        value between 0 and 100, with 0 being least secure and 100
        being most secure levels. The GUI dialogue adjusts
        automatically and shows appropriate controls depending on the
        choice of the firewall platform in the interface's parent
        firewall object.
        </para>

      <para><xref linkend="firewall-interface1"> shows a screenshot
        of the dialogue for the interface object that belongs to an
        iptables firewall object named "firewall-iptables". <xref
        linkend="firewall-interface2"> shows a screenshot of the
        dialogue for the interface object that belongs to a Cisco PIX
        firewall object named "firewall-pix".
        </para>

      <figure id="firewall-interface2" float="1">
        <title>An Interface with a numeric Security Level </title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="firewall_interface2.jpg" format="jpg" align="Left" scale="50">
          </imageobject>
        </mediaobject>
      </figure>

      <sect2 id="network-zone">
        <title>Network Zone</title>

        <para>One of the platform-specific parameters of the
          interface is a reference to the Network Zone. Currently only
          a Cisco PIX firewall requires the Network Zone. The
          interface dialogue shows controls for the Network Zone in a
          separate tab (<xref linkend="firewall-interface3">), which
          appears only if the parent firewall object specifies the
          firewall platform which requires it. The GUI dynamically
          generates a pull-down menu with all available network and
          group objects and puts it in the Network Zone dialog. You
          need to choose one object in the menu. Usually the external
          interface (the one which connects your firewall to the
          Internet) has the Network Zone set to
          <emphasis>"Any"</emphasis>. It is also recommended to create
          a group of objects to represent Network Zones of all other
          interfaces of the firewall.</para>

        <figure id="firewall-interface3" float="1">
          <title>The Network Zone dialogue</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="firewall_interface3.jpg" format="jpg" align="Left" scale="50">
            </imageobject>
          </mediaobject>
        </figure>

        <para>Consider the network layout as on <xref
        linkend="network-zones">. Here the firewall has three
        interfaces: 'outside', 'dmz' and 'inside'. Behind the firewall
        there is a router which in turn is connected to three subnets
        'subnet A', 'subnet B' and 'subnet C'. Subnet A is shared
        between the router and the firewall (each device has an
        interface on this subnet). Let's also suppose that we have
        created Network Objects for each subnet and called them
        'subnet DMZ', 'subnet A', 'subnet B' and 'subnet C' (remember,
        spaces are allowed in object names). For this setup, network
        zones should be configured as follows: </para>

        <para>
            <informaltable frame="none">
            <tgroup cols="2">
              <colspec colwidth="64pt" align="center">
              <colspec colwidth="150pt" align="center">
              <thead>
                <row>
                  <entry>Interface</entry>
                  <entry>Network Zone</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry><filename>outside</filename></entry>

                  <entry><emphasis>ANY</emphasis></entry>
                </row>
                <row>
                  <entry><filename>dmz</filename></entry>

                  <entry><emphasis>subnet DMZ</emphasis></entry>
                </row>
                <row>
                  <entry><filename>inside</filename></entry>

                  <entry>
                      <emphasis>subnet A,</emphasis>
                      <emphasis>subnet B,</emphasis>
                      <emphasis>subnet B</emphasis>
                    </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
          </para>

        <para>Since the network zone for the
          <emphasis>'inside'</emphasis> interface consists of multiple
          objects, a group must be created so that you could use this
          group as a Network Zone object. </para>

        <figure id="network-zones" float="1">
          <title>Choosing Network Zones</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="fwbuilder-using-netzone1.jpg" 
                  format="jpg" align="Left" scale="50">
            </imageobject>
          </mediaobject>
        </figure>


        <para><xref linkend="platform-specific-interface-parameters">
        explains differences in the way firewall platforms interpret
        values in the Security Level and Network Zone parameters of
        the firewall interfaces.</para>

        <table pgwide="0" id="platform-specific-interface-parameters">
          <title></title>
          <tgroup cols="3">
            <thead>
              <row>
                <entry><para>Firewall Platform</para></entry>
                <entry><para>Security Level Values</para></entry>
                <entry><para>Network Zone</para></entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry><para>iptables</para></entry>
                <entry><para>two values: 'External' or 'Internal'</para></entry>
                <entry><para>N/A</para></entry>
              </row>
              <row>
                <entry><para>ipfilter</para></entry>
                <entry><para>two values: 'External' or 'Internal'</para></entry>
                <entry><para>N/A</para></entry>
              </row>
              <row>
                <entry><para>pf</para></entry>
                <entry><para>two values: 'External' or 'Internal'</para></entry>
                <entry><para>N/A</para></entry>
              </row>
              <row>
                <entry><para>Cisco PIX</para></entry>
                <entry><para>numeric, 0 - 100</para></entry>
                <entry><para>a reference to a group or network object</para></entry>
              </row>
            </tbody>
          </tgroup>
        </table>


      </sect2>
    </sect1>

  </chapter>

  <!-- ***************************************************************
  -->
  <chapter id="network-discovery">
    <title>Network Discovery: A Quick Way to Create Objects</title>

    <figure id="discovery-menu" float="1">
      <title>Calling the Object Discovery Druid</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="discovery_menu.jpg" format="jpg" align="Left" scale="50">
        </imageobject>
      </mediaobject>
    </figure>
    
    <para>One of the distinguishing features that Firewall Builder
    provides is support for automated object creation. This helps
    populate the objects tree for large networks with lots of hosts
    and subnets. It would have taken hours if the user always had to
    do it manually, while the Objects Discovery Druid helps complete
    this task in minutes. You can bring this Druid up using the main
    menu <guimenuitem>"Tools"</guimenuitem>/<guimenuitem>"Discover
    Objects"</guimenuitem> </para>

    <para>The Druid supports three main methods for automated object
    creation:</para>

    <para>
        <itemizedlist spacing="compact">
        <listitem><para>Reading file /etc/hosts</para></listitem>
        <listitem><para>Import of DNS zone</para></listitem>
        <listitem><para>Network discovery using SNMP queries</para></listitem>
      </itemizedlist>
    </para>
    
    <para>You choose the method on the first page of the Druid ( <xref
                                                                       linkend="discovery-page1">. )</para>

    <figure id="discovery-page1" float="1">
      <title>Calling Object Discovery Druid</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="discovery_page1.jpg" format="jpg" align="Left" scale="50">
        </imageobject>
      </mediaobject>
    </figure>
    
    <para>Just check the radio-button next to the method you want to
    use and click the <guibutton>'Next'</guibutton> button.</para>

    <sect1>
      <title>Reading file /etc/hosts</title>

      <para>This method imports host records present in the standard
        file <emphasis>/etc/hosts</emphasis> or any other file that
        contain records in the following format (this format is
        actually described in the man page hosts(5)).</para>

      <para>IP_Address   host_name</para>

      <para>The IP address must be separated from the host name with
        any number of spaces or tab symbols. Lines starting with
        '#' are considered comments and are ignored. Currently
        Firewall Builder does not support ipv6 addresses and ignores
        them.</para>

      <para>When you choose the import from /etc/hosts on the first
        page, the Druid asks you for the file path and name on the
        next page. Once that information is entered, it reads the
        contents of that file and presents a table of new objects
        (<xref linkend="discovery-hosts-2">):</para>

      <figure id="discovery-hosts-2" float="1">
        <title>Creating objects using gathered information</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="discovery_hosts_2.jpg" format="jpg" align="Left" scale="50">
          </imageobject>
        </mediaobject>
      </figure>
      
      <para>This page of the druid is the same for all discovery
        methods, so let's discuss it in detail.</para>

      <para>Discovered objects are shown in the table. Since the
        source of information used for discovery could have had
        different host names for the same IP address, object names are
        shown in a pull-down menu. If there was only one name for the
        address, then the pull-down menu would have only one entry,
        otherwise it has several entries. The rightmost column in the
        table shows choices for the object type to be created: it can
        become either the Host, Network, or Firewall. Sometimes, the
        Druid can guess the type of the object or use the proper type
        depending on the discovery method used.</para>

      <para>The Druid creates objects only for selected records in
        the table. Use the checkbox in the very first column of the
        table to select objects. The comment to the right shows the
        total number of selected objects at any given moment (text
        "Selected: N objects"). 6 objects are selected in the
        screenshot <xref linkend="discovery-hosts-2">
        </para>

      <para>This page of the Druid also has the following buttons:</para>

      <para>
          <itemizedlist spacing="compact">
          <listitem>
            <para><guibutton>"Select All"</guibutton></para>

            <para>Selects all records in the table</para>
          </listitem>
          <listitem>
            <para><guibutton>"Unselect All"</guibutton></para>

            <para>Unselects all records in the table</para>
          </listitem>
          <listitem>
            <para><guibutton>"Filter"</guibutton></para>

            <para>Brings up a filter dialog. Filtering helps manage
              long lists of objects.</para>
          </listitem>
          <listitem>
            <para><guibutton>"Remove Filter"</guibutton></para>

            <para>Removes currently applied filter and shows all
              records in the table</para>
          </listitem>
        </itemizedlist>
        </para>

      <figure id="discovery-hosts-filter" float="1">
        <title>Filter Dialog</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="discovery_hosts_filter.jpg" format="jpg" align="Left" scale="50">
          </imageobject>
        </mediaobject>
      </figure>      

      <para>The Druid can filter records in the table either by
        their address, by their name, or by both. To filter by address
        enter part of it in the "Address" field. The program compares
        the text entered in the filter dialog with an address in the
        table and shows only those records whose address starts with
        the text of the filter. For example, to only filter out hosts
        with addresses on the net 10.3.14.0 we could use the filter
        "10.3.14". Likewise, to remove hosts "bear" and "beaver"
        (addresses 10.3.14.50 and 10.3.14.74) we could use the filter
        "10.3.14.6". Note that filter string does not contain any
        wildcard symbols like "*". The filter shows only records that
        have addresses which literarily match the filter string.
        </para>

      <para>Filtering by the object name uses POSIX regular
        expressions syntax described in the man page regex(7). For
        example, to find all records whose names start with 'f' we
        could use the regular expression '^f'. Symbol '^' matches the
        beginning of the string, so this regular expression matches
        any name that starts with 'f'. To find all names that end with
        'somedomain.com', we could use the regular expression
        '.*somedomain.com$' </para>

    </sect1>

    <sect1>
      <title>DNS zone import</title>

      <para>This method works only on those OS where there is a
        library supporting DNS zone transfers. Currently it is
        available on Linux and Solaris. </para>

      <para>First, the Druid asks you for the domain name you wish to
        import (<xref linkend="discovery-dns-domain">)</para>

      <figure id="discovery-dns-domain" float="1">
        <title>Entering the domain name</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="discovery_dns_domain.jpg" format="jpg" align="Left" scale="50">
          </imageobject>
        </mediaobject>
      </figure>      

      <para>Once the domain name is entered and you have clicked
        <guibutton>"Next"</guibutton>, the program first runs the DNS
        query to find out what name servers are responsible for that
        domain. It then presents a list of name servers on the next
        page for you to choose from (<xref
                                           linkend="discovery-dns-ns">).</para>

      <figure id="discovery-dns-ns" float="1">
        <title>List of name servers</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="discovery_dns_ns.jpg" format="jpg" align="Left" scale="50">
          </imageobject>
        </mediaobject>
      </figure>      


      <para> You can use one of the registsred name servers, or, if
        you have your own local name server which is authoritative for
        this domain (for example the local secondary server), you can
        enter its name or address in the entry field at the bottom of
        the dialog. Clicking <guibutton>"Next"</guibutton> initiates
        the zone transfer process (<xref
                                         linkend="discovery-dns-transfer">). </para>

      <figure id="discovery-dns-transfer" float="1">
        <title>DNS zone transfer</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="discovery_dns_transfer.jpg" format="jpg" align="Left" scale="50">
          </imageobject>
        </mediaobject>
      </figure>      

      <para>If the DNS zone transfer succeeded and the druid was
        able to pull the information it needs to create objects, you
        can switch to the next page where you choose and create
        objects. That page is the same as the one presented in <xref
                                                                     linkend="discovery-hosts-2">. </para>

    </sect1>

    <sect1>
      <title>Network Discovery</title>

      <figure id="discovery-snmp-seed" float="1">
        <title>Initial Parameters for the Network Discovery program</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="discovery_snmp_seed.jpg" format="jpg" align="Left" scale="50">
          </imageobject>
        </mediaobject>
      </figure>      

      <para>The Network discovery program (sometimes referred to as
        the "Network Crawler") needs a host to start from. This host
        is called the "seed host"; you enter it in the first page of
        the Druid (<xref linkend="discovery-snmp-seed">). The crawler
        implements the following algorithm (this is a somewhat
        simplified explanation):</para>

      <para>First, it runs several SNMP queries against the seed
        host trying to collect the following data: the list of its
        interfaces and its ARP and routing tables. This host is then
        added to the table of discovered network objects, together
        with its interfaces, their addresses and netmasks and the
        host's "sysinfo" parameters. Then the crawler analyses the
        routing table of that host; this allows it to discover the
        networks and subnets which in turn are also added to the list
        of discovered objects. Then it analyses the ARP table, which
        holds MAC and IP addresses of neighboring hosts. It takes one
        host found in this table at a time and repeats the same
        algorithm using it as a seed host. When it pulls an ARP table
        from the next host, it discards entries that describe objects
        it already knows about. However if it finds new entries, it
        tries them as well and thus travels further down the
        network. Eventually it will visit every host on all subnets on
        the network.</para>

      <para>This algorithm relies on hosts answering to the SNMP
        queries. If the very first host (the "seed" host) does not run
        SNMP agent, the crawler will stop on the first run of its
        algorithm and won't find anything. Therefore it is important
        to use a host which does run SNMP agent as a "seed" host. Even
        if most of the hosts on the network do not run SNMP agents,
        but a few do, the crawler will most likely find all of
        them. This happens because it discovers objects when it reads
        the ARP tables from the host which answers; so even if
        discovered hosts do not answer to SNMP queries, the crawler
        already found them anyway. </para>

      <para>One of the ways to limit the scope of the network that
        the crawler will visit is to use the parameter "Confine scan
        to the network". You need to enter both a network address and
        a netmask; the crawler will then check if hosts it discovers
        belong to this network and if they do not, discard
        them.</para>

      <figure id="discovery-snmp-options" float="1">
        <title>Parameters for Network Discovery: Page 1</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="discovery_snmp_options.jpg" format="jpg" align="Left" scale="50">
          </imageobject>
        </mediaobject>
      </figure>      

      <figure id="discovery-snmp-options2" float="1">
        <title>Parameters for Network Discovery: Page 2</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="discovery_snmp_options2.jpg" format="jpg" align="Left" scale="50">
          </imageobject>
        </mediaobject>
      </figure>      

      <para>There are a few settings that affect the crawler's
        algorithm (see <xref linkend="discovery-snmp-options"> and
        <xref linkend="discovery-snmp-options2">). Here is the
        list:</para>

      <para>
          <itemizedlist spacing="compact">
          <listitem>
            <para>Run network scan recursively</para>

            <para>As was described above, the crawler starts with
              the "seed" host and then repeats its algorithm using
              every discovered host as a new "seed". If this option is
              turned OFF, then the crawler runs its algorithm only once
              and stops.</para>
          </listitem>
          <listitem>
            <para>Follow point-to-point links</para>

            <para>If a firewall or a router has a point-to-point
            interface (for example, PPP interface), then the crawler
            can automatically calculate the IP address of the other
            side of this interface. It then continues the discovery
            process by querying a router on the other side. Very
            often, the point-to-point link connects the organization's
            network to an ISP and you are not really interested in
            collecting data about your ISP network. By default crawler
            won't cross point-to-point links, but this option, if
            activated, permits it.
            </para>
          </listitem>
          <listitem>
            <para>Include virtual addresses</para>

            <para>Sometimes servers or routers have more than one IP
              address assigned to the same interface. If this option
              is turned on, the crawler "discovers" these virtual
              addresses and tries to create objects for them.</para>
          </listitem>
          <listitem>
            <para>Run reverse name lookup queries to determine host
              names</para>

            <para>If the host discovered by the crawler answers to
              SNMP queries, it will report its name, which the crawler
              will use to create an object in Firewall
              Builder. However, if the host does not answer the query,
              the crawler can not determine its name and only knows
              its IP address. The crawler can use DNS to back-resolve
              such addresses and determine host names if this option
              is turned ON. </para>
          </listitem>

          <listitem>
            <para>SNMP query parameters</para>

            <para>You must specify the SNMP "read" community string
              which will be used for SNMP queries. You can also
              specify the number of retries and a timeout for the
              query.</para>
          </listitem>

          <listitem>
            <para>DNS parameters:</para>

            <para>You can specify the number of retries and a
              timeout for the DNS lookup query, as well as the number
              of threads.  Firewall Builder uses a multithreaded
              resolver in order to speed up the process. In other
              words, it can run several DNS lookups simultaneously,
              the "Number of threads" parameter defines how many
              lookups it can run in parallel.</para>
          </listitem>
        </itemizedlist>
        </para>


      <para>Once all parameters are entered, the crawler actually
        gets to work, which may take a while. Depending on the size of
        the network and such parameters as the SNMP timeout value,
        scanning may take minutes or even hours. The progress of the
        scanner can be monitored on the page in the Druid (<xref
                                                                 linkend="discovery-snmp-crawler">). You can always stop the
        crawler using button <guibutton>"Stop network
        scan"</guibutton>. Data does not get lost if you do this as
        the Druid will use whatever objects the crawler discovered
        before you stopped it.</para>

      <figure id="discovery-snmp-crawler" float="1">
        <title>Parameters for Network Discovery: Page 2</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="discovery_snmp_crawler.jpg" format="jpg" align="Left" scale="50">
          </imageobject>
        </mediaobject>
      </figure>      

      <para>the <guibutton>"Save scan log to file"</guibutton> button 
        saves the content of the progress window to a text file and is
        mostly used for troubleshooting and bug reports related to
        the crawler. </para>

      <para>If the crawler succeeded and was able to collect
        information it needs to create objects, you can switch to the
        next page where you choose and create objects. That page is
        the same as the one presented in <xref
                                               linkend="discovery-hosts-2">.</para>

    </sect1>
  </chapter>

  <!-- *************************************************************** -->
  <chapter>
    <title>Working With Services</title>
    <sect1>
      <title>IP Service</title>

      <para>The simple IP service object is represented in the
        screenshot <xref linkend="ip-service-dialog1">. Firewall
        Builder provides standard object types for well-known and
        frequently used protocols such as ICMP (IP protocol number 1),
        TCP (IP protocol number 6) and UDP (IP protocol number
        17). The IP service object helps describe other protocols
        which are neither ICMP nor TCP nor UDP. The protocol is
        defined by the 8-bit field in the IP packet header. The
        screenshot <xref linkend="ip-service-dialog1"> represents
        object 'ESP' (Encapsulating Security Payload, part of the
        IPSEC protocol family) which uses the IP protocol number
        50. Protocol numbers are assigned by IANA; one can look up the
        number for a particular protocol at the following URL:
        http://www.iana.org/assignments/protocol-numbers/</para>

      <para>Besides the protocol number, the header of the IP packet
        also has a field called "options" which is a variable-length
        list of optional information for the packet. Not all firewalls
        can examine options, and those that can usually have certain
        limitations as to what options they can match
        against. Firewall Builder tries to provide controls for many
        popular options, supported by the most sophisticated
        firewalls. Not all options supported by Firewall Builder are
        supported by all target firewall platforms (<xref
                                                          linkend="support-for-ip-options">).</para>

      <para>Firewall Builder supports the following options:</para>

      <informaltable frame="none">
        <tgroup cols="2">
          <colspec colwidth="150pt" align="left">
          <tbody>
            <row>
              <entry><filename>Source route options: LSRR, SSRR</filename></entry>

              <entry>Normally IP routing is dynamic with each router
                making decisions about which next hop router to send
                the packet to. However another option exists, where
                the sender can choose the route. In the case of the
                Loose Source Route, the sender (host) can specify a
                list of routers the packet must traverse, but it may
                also pass through other routers between any two
                addresses in the list. The Strict Source Route works
                very much the same way, except the packet must
                traverse only through the specified addresses. Source
                routing can potentially be used to reach hosts behind
                the firewall even if these hosts use private IP
                addresses which normally are not reachable over the
                Internet.</entry>
            </row>
            <row>
              <entry><filename>Record route option: RR</filename></entry>

              <entry>This option causes every router that handles
                the packet on the way to add its IP address to a list
                in the options field. This option is used by the ping
                utility when it is called with "-R" command line
                switch; it can potentially be exploited to discover
                the internal network addressing and layout behind the
                firewall. Although the risk is low, some firewall
                administrators prefer to block packets with this
                option set.</entry>
            </row>
            <row>
              <entry><filename>Timestamp option:</filename></entry>

              <entry>This option tells routers that handle the
                packet to record their timestamps and sometimes
                addresses (like in the case of the record route
                option). This option is seldom used, but can
                potentially be exploited to gather information about
                the protected network, so some firewall administrators
                prefer to block packets with this option set. </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>


      <para>IP packets sometimes may become fragmented. This happens
        if the original datagram is larger than what a physical
        network layer can transmit. The IP packet header has special
        fields (called "Flags" and "Fragmentation Offset") which help
        detect fragmented packets and reassemble them. Many firewalls
        can check these bits as well. Certain combinations of flags
        and fragmentation offsets can never happen during a normal
        operation but were seen to be used by attackers. Firewall
        Builder provides two options for most commonly used cases
        related to packet fragmentation: option 'all fragments'
        matches the second and further fragments, while option 'short'
        is used to match packets that are too short to contain even
        a complete IP header.</para>

      <para>Standard IP Service objects that come with Firewall
        Builder appear in the "Standard" tree, in the 
        <guimenuitem>Services/IP</guimenuitem> branch.</para>

      <table id="support-for-ip-options">
        <title>Support for IP options and fragmentation on various firewall platforms</title>
        <tgroup cols="7">
          <colspec                 align="center">
          <colspec colwidth="64pt" align="center">
          <colspec colwidth="64pt" align="center">
          <colspec colwidth="64pt" align="center">
          <colspec                 align="center">
          <colspec                 align="center">
          <colspec                 align="center">
          <thead>
            <row>
              <entry>Firewall</entry>
              <entry>  lsrr   </entry>
              <entry>  ssrr   </entry>
              <entry>   rr    </entry>
              <entry>timestamp</entry>
              <entry>all fragments</entry>
              <entry>'short' packets</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>iptables</entry>
              <entry>+</entry>
              <entry>+</entry>
              <entry>+</entry>
              <entry>+</entry>
              <entry>+</entry>
              <entry>-</entry>
            </row>
            <row>
              <entry>ipfilter</entry>
              <entry>-</entry>
              <entry>+</entry>
              <entry>+</entry>
              <entry>+</entry>
              <entry>+</entry>
              <entry>+</entry>
            </row>
            <row>
              <entry>pf</entry>
              <entry>-</entry>
              <entry>-</entry>
              <entry>-</entry>
              <entry>-</entry>
              <entry>-</entry>
              <entry>-</entry>
            </row>
            <row>
              <entry>Cisco PIX</entry>
              <entry>-</entry>
              <entry>-</entry>
              <entry>-</entry>
              <entry>-</entry>
              <entry>-</entry>
              <entry>-</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <figure id="ip-service-dialog1" float="1">
        <title>Editing the IP Service Object</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="ip_service_dialog1.jpg" format="jpg" align="Left" scale="50">
          </imageobject>
        </mediaobject>
      </figure>      

      <para>The IP Service dialog provides the following controls: </para>

      <para>
          <itemizedlist spacing="compact">
          <listitem>
            <para>Name:</para>

            <para>This is the name of the object</para>
          </listitem>

          <listitem>
            <para>Protocol:</para>

            <para>This is the protocol number. </para>
          </listitem>

          <listitem>
            <para>Options:</para>

            <para>These flags represent 'Options' flags in the IP header:</para>

            <para>
                <simplelist>
                <member>lsrr (loose source route)</member>
                <member>ssrr (strict source route)</member>
                <member>rr (record route)</member>
                <member>timestamp</member>
                <member>all fragments</member>
                <member>short packet</member>
              </simplelist>
              </para>
          </listitem>
          <listitem>
            <para>Comments:</para>

            <para>This is a free-style text field used for comments.</para>
          </listitem>
        </itemizedlist>
        </para>

    </sect1>

    <sect1>
      <title>ICMP Service</title>

      <para>The ICMP Service object is a generalized representation
        of ICMP protocol. ICMP packets are often used to communicate
        error messages which are acted upon by either the IP layer or
        higher layer protocols (TCP or UDP). ICMP can also be used as
        a simple query protocol.  The firewall administrator needs to
        understand the nature and purpose of ICMP in order to properly
        configure the firewall to block unwanted and permit useful
        ICMP messages. ICMP packets have two header fields that
        distinguish particular ICMP messages: the
        <emphasis>"type"</emphasis> and <emphasis>"code"</emphasis>
        fields. There can be 15 different ICMP types, each of which
        may use different values for its <emphasis>"code"</emphasis>
        field to further specify the condition. Firewall Builder
        provides a dialog with a built-in list of all possible ICMP
        types and corresponding codes which helps the administrator to
        the pick appropriate one without having to look up these numbers
        in the book (<xref linkend="icmp-service-dialog1">). The standard
        ICMP Service objects that come with Firewall Builder appear in
        the "Standard" tree, in the 
        <guimenuitem>Services/ICMP</guimenuitem> branch.
        </para>

      <figure id="icmp-service-dialog1" float="1">
        <title>Editing the ICMP Service Object</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="icmp_service_dialog1.jpg" format="jpg" align="Left" scale="50">
          </imageobject>
        </mediaobject>
      </figure>      

      <para>ICMP Service dialog provides the following controls:</para>

      <para>

          <itemizedlist spacing="compact">
          <listitem>
            <para>Name:</para>
            <para>This is the name of the object.</para>
          </listitem>
          <listitem>
            <para>ICMP Type and Code:</para>

            <itemizedlist spacing="compact">
              <listitem>
                <para>Type:</para>

                <para>ICMP message type. This control consists of
                  two widgets: numeric field and pull-down menu that
                  represent list of possible types and their
                  names. You can choose type either by number (using
                  the numeric entry field) or by its description
                  (using the pull-down menu).</para>
              </listitem>

              <listitem>
                <para>Code:</para>

                <para>ICMP message code. Just like the above, this
                  control consists of two widgets: numeric field and
                  pull-down menu that represent list of possible codes
                  and their names. This menu changes when you choose
                  different ICMP type since different types use
                  different codes. You can choose code either by
                  number (using the numeric entry field) or by its
                  description (using the pull-down menu).</para>
              </listitem>

              <listitem>
                <para>Checkbox <guibutton>'Any Type'</guibutton></para>

                <para>Check this if you wish to create an object
                  that would match with any ICMP type and code.</para>
              </listitem>
            </itemizedlist>

          </listitem>

          <listitem>
            <para>Comment:</para>

            <para>This is a free-style text field used for comments.</para>
          </listitem>
        </itemizedlist>

        </para>
    </sect1>

    <sect1 id="tcp-service">
      <title>TCP Service</title>

      <para>TCP Service object is a generalization of TCP protocol
        which provides a connection-oriented, reliable, byte stream
        service. Many well-known frequently used application protocols
        use underlying TCP protocol: FTP (File Transfer Protocol),
        SMTP (Simple Mail Transfer Protocol), HTTP (Hyper Text
        Transfer Protocol) and so on. TCP header contains special
        fields called source and destination port numbers that are
        used to identify the sending and receiving application using
        data stream. These two values, along with the source and
        destination IP addresses in the IP header, uniquely identify
        each connection. </para>

      <para>Since port numbers are used to distinguish applications
        using data stream provided by TCP protocol, each application
        should use unique port number. To ensure interoperability,
        these numbers must be assigned by a central authority in a
        coordinated manner. Internet Assigned Numbers Authority (IANA)
        does that; assigned TCP and UDP port numbers can be looked up
        at the following URL:
        http://www.iana.org/assignments/port-numbers . Most Unix
        systems also come with a file /etc/services which contains a
        list of assigned port numbers.</para>

      <para>Firewall Builder comes with a collection of predefined
        TCP Service objects with port numbers already configured. You
        can simply use these objects in your policy rules and do not
        have to look up port numbers every time you need them. </para>

      <para>Typical TCP Service object is represented in a
        screenshot <xref linkend="tcp-service-dialog1">.</para>

      <figure id="tcp-service-dialog1" float="1">
        <title>Editing TCP Service Object</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="tcp_service_dialog1.jpg" 
                format="jpg" align="Left" scale="50">
          </imageobject>
        </mediaobject>
      </figure>      

      <para>In Firewall Builder, TCP Service object is a
        generalization of TCP protocol. TCP header of a packet carries
        only one fixed value for the source port and one fixed value
        for the destination port. In TCP Service object allows a range
        of values to be used for the source and destination
        ports. This allows single TCP Service object to describe
        either a family of protocols using consequitive port numbers,
        or a protocol that may use variable port numbers or simply
        many protocols that use port numbers from a certain range. For
        example, on Unix systems TCP sessions opened by priviliged
        process always have their source port number assigned from the
        range below 1024, while unpriviliged processes use source port
        numbers from the range starting from 1024 and above. TCP
        Service object with source port range defined as shown in the
        screenshot <xref linkend="tcp-service-dialog2"> describes
        all priviliged TCP sessions.</para>

      <figure id="tcp-service-dialog2" float="1">
        <title>TCP Service Object: priviliged source ports</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="tcp_service_dialog2.jpg" 
                format="jpg" align="Left" scale="50">
          </imageobject>
        </mediaobject>
      </figure>      

      <para>Using '0' as both start and end values for a range means
        'any value' for that range. Source port range of the object
        'priviliged TCP' starts from 0 and ends at 1023 (port ranges
        are inclusive in Firewall Builder), while its destination port
        range start and end are both set to zero, which means 'any
        destination port'. This object describes any TCP protocol
        with source port in range 0-1023 and any destination
        port.</para>

      <para>If all you need is to create an object to describe TCP
        protocol with particular destination port, just use the same
        port number for both start and end of destination port range
        (which effectively creates a range that consists of a single
        value). Example in <xref linkend="tcp-service-dialog1"> shows
        such service.</para>

      <para>TCP header also contains a collection of one-bit fields,
        or flags, that carry a variety of control information. For
        example, the SYN and ACK flags are used for connection
        establishment, and the FIN flag is used for connection
        termination. Certain combination of flags are not allowed
        during the normal protocol operation but may cause unpredicted
        reaction in some systems; because of this reason firewall
        administrator may want to block TCP packets with unwanted
        combination of flags. </para>

      <para>There are six flags in TCP header. We just briefly
        mention them here; more information can be found in <citetitle
        pubwork="book">TCP/IP Illustrated, vol 1</citetitle> by
        W. Richard Stevens, chapter 17. </para>

      <informaltable frame="none">
        <tgroup cols="2">
          <colspec colwidth="64pt" align="center">
          <colspec                 align="left">
          <tbody>
            <row>
              <entry><filename>URG</filename></entry>

              <entry>The "urgent" pointer is valid</entry>

            </row>
            <row>
              <entry><filename>ACK</filename></entry>

              <entry>The acknowledgment number is valid</entry>

            </row>
            <row>
              <entry><filename>PSH</filename></entry>

              <entry>The reciever should pass this data to the
                application as soon as possible</entry>

            </row>
            <row>
              <entry><filename>RST</filename></entry>

              <entry>Reset the connection</entry>

            </row>
            <row>
              <entry><filename>SYN</filename></entry>

              <entry>Synchronize sequence numbers to initiate a
                connection.</entry>

            </row>
            <row>
              <entry><filename>FIN</filename></entry>

              <entry>The sender is finished sending data.</entry>

            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>Firewall Builder supports all six flags, although not
        all target firewall platforms can match all combinations
        of TCP flags or flags at all (See <xref linkend="support-for-tcp-flags">).</para>

      <table id="support-for-tcp-flags" pgwide="0">
        <title>Support for Matching against TCP flags</title>
        <tgroup cols="2">
          <colspec colwidth="64pt"  align="center">
          <colspec colwidth="200pt" align="center">
          <thead>
            <row>
              <entry>Firewall</entry>
              <entry>Can inspect TCP header flags in the packet</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>iptables</entry>
              <entry>Yes</entry>
            </row>
            <row>
              <entry>ipfilter</entry>
              <entry>Yes</entry>
            </row>
            <row>
              <entry>pf</entry>
              <entry>Yes</entry>
            </row>
            <row>
              <entry>Cisco PIX</entry>
              <entry>No</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>
        Usually firewall can not only match on a combination of flags,
        but can also examine only given subset of all TCP
        flags. Firewall builder provides two sets of checkboxes for
        TCP flags and flag masks (see <xref
                                            linkend="tcp-service-dialog3">). Checkboxes in the first row
        control TCP flags that we want the firewall to examine and
        checkboxes in the second row tell it whether they should be
        set or cleared. Only flags whose checkboxes in the first row
        are set will be looked at by the firewall; to remind about
        this, Firewall Builder deactivates checkboxes in the second
        row for the flags that are to be ignored.  Object in <xref
                                                                   linkend="tcp-service-dialog3"> matches TCP packet with any
        combination of port numbers, TCP flag SYN set and all other
        flags cleared. Firewall will examine all TCP flags.
      </para>

      <para>
        <figure id="tcp-service-dialog3" float="1">
          <title>TCP Service Object: any TCP packet with SYN flag set and all other flags cleared.</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="tcp_service_dialog3.jpg" format="jpg" align="Left" scale="50">
            </imageobject>
          </mediaobject>
        </figure>      
      </para>

      <para>
        Combination of flags and a mask can be used in a rule that
        looks for some flags to be set or unset and ignore other ones
        regardless of their state. For example we can create a rule
        that detects so called "null scan" which is done using TCP
        packets with all flags cleared. For this rule we create a TCP
        Service object "tcp null scan" where all flag masks are set
        but all TCP flags are cleared. This means we examine all flags
        but match if they all are cleared. This object is represented
        in <xref linkend="tcp-service-dialog4">.
      </para>

      <para>
        <figure id="tcp-service-dialog4" float="1">
          <title>"null scan" TCP Service Object: firewall examines all TCP flags and matches if all are cleared.</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="tcp_service_dialog4.jpg" format="jpg" align="Left" scale="50">
            </imageobject>
          </mediaobject>
        </figure>      
      </para>


      <para>TCP Service dialog provides the following controls:</para>

      <para>
          <itemizedlist  spacing="compact">
          <listitem>
            <para>Name:</para>

            <para>This is the name of the object</para>
          </listitem>
          <listitem>
            <para>Source port range:</para>

            <para>These two controls define start and end of the
              source port range; they accept values between 0 and
              65535.</para>
          </listitem>
          <listitem>
            <para>Destination port range:</para>

            <para>These two controls define start and end of the
              destination port range; they accept values between 0 and
              65535.</para>
          </listitem>
          <listitem>
            <para>TCP Flags:</para>

            <para>TCP flags and masks, see above.</para>
          </listitem>
          <listitem>
            <para>Comments:</para>

            <para>This is a free-style text field used for comments.</para>
          </listitem>
        </itemizedlist>
        </para>
    </sect1>

    <sect1>
      <title>UDP Service</title>

      <para>UDP Service object is a generalization of UDP protocol
        which is connectionless transport layer protocol. Many well
        known applicaitons use UDP as their transport, such as DNS
        (Domain Name System), DHCP (Dynamic Host Configuration
        Protocol), NTP (Network Time Protocol), SNMP (Simple Network
        Management Protocol) and so on.</para>

      <para>Similarly to that in TCP, UDP uses port numbers to
        distinguish multiple applications running on one machine from
        one another. UDP packet header carries two port numbers: the
        source port and the destination port. UDP Service object in
        Firewall Builder allows for definition of ranges for both
        source and destination port. The meaning of values assigned to
        the start and end of the range is the same as in TCP Service
        object: ranges are inclusive, that is both start and end ports
        of the range are included. Using '0' for both start and end of
        the range means 'any port'. These rules work for both source
        and destination ranges. Screenshot <xref
                                                 linkend="udp-service-dialog1"> shows UDP Service object 'dns'
        that represents Domain Name System protocol which uses
        destination port 53.  </para>

      <para>
        <figure id="udp-service-dialog1" float="1">
          <title>Editing UDP Service Object</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="udp_service_dialog1.jpg" format="jpg" align="Left" scale="50">
            </imageobject>
          </mediaobject>
        </figure>      
        </para>

      <para>UDP Service dialog provides the following controls:</para>

      <para>
          <itemizedlist  spacing="compact">
          <listitem>
            <para>Name:</para>

            <para>This is the name of the object</para>
          </listitem>
          <listitem>
            <para>The Source port range:</para>

            <para>These two controls define the start and the end of
              the source port range; they accept values between 0 and
              65535.</para>
          </listitem>
          <listitem>
            <para>The Destination port range:</para>

            <para>These two controls define the start and the end of
              the destination port range; they accept values between 0
              and 65535.</para>
          </listitem>
          <listitem>
            <para>Comments:</para>

            <para>This is a free-style text field used for comments.</para>
          </listitem>
        </itemizedlist>
        </para>

    </sect1>

    <sect1>
      <title>Custom Service</title>

      <para>The Custom Service object can be used to inject
        arbitrary code into generated firewall script. Any combination
        of options allowed in the target firewall command line
        language which does not fit in a strict model of standard
        service object types can be expressed using Custom Service
        object. For example, iptables comes with a collection of
        patches called "Patch-o-matic" which adds an ability to match
        against complex combinations of packet parameters or header
        fields that are not supported by a standard code. One of the
        patches adds an ability to detect a port scan condition, where
        offending host tries to connect to UDP or TCP ports on the
        firewall or hosts behind it picking port numbers in turns
        trying to detect which ports are active and which are
        'dead'. Normally the firewall would inspect each attempt to
        connect to a port separately from others and would generate
        many log records, one line per connection attempt. While this
        behavior is normal, it still fails to recognize a pattern in
        the actions of offending host, which may be important in
        investigation of malicious activity since port scanning is
        often a step in a preparation for more focused attack.
        </para>

      <para>Screenshot <xref linkend="custom-service-dialog1">
        represents Custom Service object that uses capabilities of
        'PSD' module from patch-o-matic. This module can match against
        port scan attempts that are spread in time and has few
        parameters to fine tune detection mechanism. Custom Object
        'psd' defines command line options specific for module 'psd'
        in the field 'Code'</para>

      <para>In general, Custom service can store arbitrary piece of
        code for each supported firewall platform. When this object is
        used in firewall policy, policy compiler picks appropriate
        line of code depending on what target firewall platform the
        code is being compiled for.</para>

      <note>
        <para> The code specified in the Custom Service is used
          literally; no validation is done either by Firewall Builder
          GUI or policy compilers. </para>
      </note>

      <para>
        <figure id="custom-service-dialog1" float="1">
          <title>Editing Custom Service Object</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="custom_service_dialog1.jpg" format="jpg" align="Left" scale="50">
            </imageobject>
          </mediaobject>
        </figure>      
        </para>
      <para>Custom Service dialog provides the following controls:</para>

      <para>
          <itemizedlist  spacing="compact">
          <listitem>
            <para>Name:</para>

            <para>This is the name of the object</para>
          </listitem>
          <listitem>
            <para>Platform:</para>

            <para>This is a pull-down menu that shows a list of all
              firewall platforms for which modules were installed and
              loaded when the GUI started. </para>
          </listitem>
          <listitem>
            <para>Code:</para>

            <para>This is a line of code in the target firewall language.</para>
          </listitem>
          <listitem>
            <para>Comments:</para>

            <para>This is a free-style text field used for comments.</para>
          </listitem>
        </itemizedlist>
        </para>


      <para></para>
    </sect1>

  </chapter>

  <chapter>
    <title>Firewall Policies</title>


    <sect1 id="policies-and-rules">
      <title>Policies and Rules</title>

      <para>Each firewall object has several sets of rules associated
      with it: Global Policy, Interface Policies and Network Address
      Translation (NAT) rules. Rules in the global policy and in
      interface policies control access to and from the firewall
      machine and machines behind it, while NAT rules describe address
      and port transformations that the firewall should make to the
      packets flowing through it.</para>

      <para>Firewall software varies widely in the way it can process
      packets. For example, some firewalls allow for rules to be
      written without specification of the interface, while some
      others require all rules to be associated with interface. Some
      firewalls perform address and port transofrmations first and
      then apply policy rules, while some others do it the other way
      around. There are many other variations and features, specific
      to particular implementations. In Firewall Builder though user
      works with an abstract firewall that looks uniform regardless of
      the target firewall platform it is used to generate code
      for. For example, Cisco PIX applies its Access List rules to the
      packet before it performs address and port transformations
      according to the NAT rules. This makes this firewall platform
      substantially different and inconvenient because a policy rule
      that controls access to the server behind the firewall doing NAT
      should be written using firewall's object instead of the
      server's object. The meaning of such rule is not obvious at a
      glance since one has to keep in mind all NAT rules as well to
      understand that this policy rule controls access not the
      firewall machine, but rather to the server behind it. Firewall
      Builder compensates for variations like this using smart
      algorithms to transform rules defined in the GUI to generate
      code in the language of the target firewall platform to achieve
      desired effect.</para>

      <para><xref linkend="policies-seq"> represents logical sequence
      in which rules defined in Firewall Builder affect network
      packet. This diagram describes an abstract firewall which
      Firewall Builder represents for the user. In some cases the
      target firewall may work the same way, in some other cases it
      won't. Either way, the goal is for administrator to build the
      rules assuming his firewall works like shown on <xref
      linkend="policies-seq">. The firewall may have multiple
      interfaces and multiple interface policies. Since interface is
      one of the parameters of the rule, and rules in different
      Interface Policies are tied to different interfaces, they are
      orthogonal. Because of that, it does not matter in which order
      Interface Policies are applied. It is guaranteed however that
      Interface Policies are stacked on top of the Global Policy and
      inspect the packet before the Global Policy will.
      </para>

      <figure id="policies-seq" float="1">
        <title>Sequence in which NAT and Policy rules apply to the
        packet in Firewall Builder </title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="policies-seq.jpg"
                format="jpg" align="Left" scale="50">
          </imageobject>
        </mediaobject>
      </figure>

      <para>Among three major types of supported sets of rules, Global
      Policy rules and Interface Policy rules are similar. These rules
      represent access control because they define which packets will
      be permitted and which will be denied. Both Global and Interface
      Policy rules operate on the packet's source and destination
      addresses and protocol parameters. The difference is that
      Interface rules also take into account firewall's interface
      which the packet is crossing in one or another direction. Global
      Policy rules work regardless of the interface. In case of
      iptables, Global Policy is roughly equivalent the iptables
      commands that do not specify interface using "-i" or "-o"
      option, however there might be no such direct correspondence in
      other firewall platforms.  Interface Policy rules are associated
      with particular interface of the firewall and have an option
      that describes direction in which packet should cross the
      interface in order for the rule to match it.
      </para>

      <note><para>
        Although this may be counter-intuitive for those who are very
        familiar with iptables (netfilter), Interface Policies are NOT
        directly converted into INPUT and OUTPUT chains. In fact,
        certain rules in Interface Policy may still go into the
        FORWARD chain. Only rules where the firewall object or one of
        its interfaces is used in the destination generate iptables
        rules that go into INPUT chain. Similarly, rules that have the
        firewall or one of its interfaces in source generate iptables
        rules that go into OUTPUT chain. Such rules may happen in both
        Global and Interface Policies. What makes Global and Interface
        policies different, is a reference to the interface which in
        iptables corresponds to "-i" and "-o" clauses with
        corresponding interface name.
      </para></note>

      <sect2>
        <title>Actions</title>

        <para>
          Policy rule action can be one of the following:
          <emphasis>Acccept</emphasis>, <emphasis>Deny</emphasis> or
          <emphasis>Reject</emphasis>. If a rule's action is Accept,
          then a packet with source and destination addresses and
          service matching the rule is permitted through. If a rule's
          action is Deny, such packet is silently dropped. If a rule's
          action is Reject, then the packet is dropped and an
          appropriate ICMP message is sent back to the sender. For
          target platforms that support it, there might be an option
          to send a TCP RST packet back in response for TCP
          services. <xref linkend="actions"> illustrates rule actions.
        </para>

        <figure id="actions" float="1">
          <title>Actions </title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="actions.png"
                  format="jpg" align="Left" scale="50">
            </imageobject>
          </mediaobject>
        </figure>

        <para>
          Some firewall platforms also support action
          <emphasis>Accounting</emphasis>. Rule with this action is
          supposed to only count packets that match it but does not
          make any decision whether the packet should be permitted or
          denied. Rules with this action are an exception because even
          if the packet matches such rule, the inspection process
          continues with other rules below it. On <xref
          linkend="accounting-action"> rule #0 counts packets that are
          part of <emphasis>HTTP</emphasis> sessions opened through
          the firewall. Rule #1 permits <emphasis>HTTP</emphasis>
          access to the server <emphasis>server</emphasis> from any
          source and rule #2 permits internal network to connect to
          any destination. Since accounting rule #0 has
          <emphasis>any</emphasis> in its source and destination
          fields, it will count both accesses to the web server
          <emphasis>server</emphasis> and traffic created when users
          on the internal net connect to the web sites out on the
          Internet.
        </para>

        <figure id="accounting-action" float="1">
          <title>Example of Accounting Action </title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="accounting-action.png"
                  format="jpg" align="Left" scale="50">
            </imageobject>
          </mediaobject>
        </figure>

      </sect2>

      <sect2 id="directions">
        <title>Directions</title>

        <para> The direction is being defined with respect to the
        firewall machine, not to the network behind it. For example,
        packets that leave internal network through the firewall are
        considered "inbound" on firewall's internal interface and
        "outbound" on its external interface. Likewise, packets that come
        from the Internet are "inbound" on firewall's external interface
        and "outbound" on its internal interface.  <xref
        linkend="f-directions"> illustrates definition of the direction
        for packets entering or exiting firewall interface. </para>

        <figure id="f-directions" float="1">
          <title>Directions </title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="directions.png"
                  format="jpg" align="Left" scale="50">
            </imageobject>
          </mediaobject>
        </figure>

      </sect2>

<!--
Table:

firewall platform   should rules     Can we write      In what order
                    be associated    rules without     does this firewall
                    with interface?  interface?        perform NAT and policy
                                                       control?

iptables             can be, but
                     not necessarily    yes            NAT, policy

OpenBSD pf           can be, but
                     not necessarily    yes            NAT, policy

ipfilter             can be, but
                     not necessarily    yes            NAT, policy

PIX                  always             no             policy, NAT

-->

      <sect2 id="global-policy">
        <title>Global Firewall Policy</title>

        <figure id="global-policy1" float="1">
          <title>Global Policy</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="global_policy.jpg" format="jpg" align="Left" scale="50">
            </imageobject>
          </mediaobject>
        </figure>

        <para>The Firewall policy consists of a set of rules. Packets
        are analysed by comparing their parameters with rules in the
        policy; inspecting rules in an orderly manner from top to
        bottom. The first rule that matches the packet is used. Each
        rule includes a standard set of parameters, or <emphasis>Rule
        Elements</emphasis>, which are used to compare the data packet
        with, such as "Source", "Destination", "Service",
        "Direction". If a rule is a part of the Interface Policy
        (<xref linkend="interface-policy">), then the interface it
        belongs to acts as yet another parameter. For example, if a
        packet entering the firewall has a source address which
        matches the object in the "Source" field of the rule, its
        destination address matches the object in "Destination", its
        protocol and port numbers match the object in the field
        "Service", and its direction matches that specified in the
        field "Direction", then the firewall will take action,
        specified in the "Action" field of the matching rule. In the
        case of Interface rule, the firewall will also take into
        account the interface through which packet had entered or
        through which it is about to leave the firewall.</para>

        <para>For example on <xref linkend="global-policy1">, the rule
        #0 says that all fragmented packets should be dropped (the
        rule uses service object <emphasis>ip_fragments</emphasis> and
        the <emphasis>Deny</emphasis> action). Rule #1 says that
        connections from the internal network (object
        <emphasis>internal-net</emphasis>) to the firewall itself
        (object <emphasis>firewall-pix</emphasis>) using protocols
        <emphasis>telnet</emphasis> and <emphasis>snmp</emphasis> are
        allowed (action <emphasis>Accept</emphasis>). The "Catch all"
        rule #8 denies all packets that have not been matched by any
        other rule above it. The global policy on <xref
                                                        linkend="global-policy1"> is built to allow only specific
        services and deny everything else, which is a good practice.
        </para>

        <para><xref linkend="rule-elements"> lists rule elements
        available in the policy, depending on the chosen target
        firewall platform.
        </para>
      </sect2>

      <sect2 id="interface-policy">
        <title>Interface Policy</title>

        <figure id="interface-policy1" float="1">
          <title>Interface Policy for iptables firewall</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="interface_policy1.jpg" format="jpg" align="Left" scale="50">
            </imageobject>
          </mediaobject>
        </figure>

        <figure id="interface-policy2" float="1">
          <title>Interface Policy for Cisco PIX firewall</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="interface_policy2.jpg" format="jpg" align="Left" scale="50">
            </imageobject>
          </mediaobject>
        </figure>

        <para>Each firewall's interface may have a security policy
        associated with it. Different firewalls require different
        commands to attach policy rules to the firewall, but policy
        compilers take care of that and generate the appropriate
        code. The Interface Policy consists of a set of rules; each
        rule has the same rule elements as a Global Policy rule and
        adds some additional ones. </para>

        <para>In <xref linkend="interface-policy1"> rule #0 (the so
        called Anti-spoofing rule) says that all packets which enter
        the firewall's interface eth0 (direction is
        <emphasis>"Inbound"</emphasis>) and have their source address
        match either the internal network or dmz network or any
        address that belongs to the firewall itself, should be dropped
        and a record should be made in the log (since there is a
        "notebook and pencil" icon in the
        <emphasis>"Options"</emphasis> rule element).
        </para>
      </sect2>
    </sect1>

    <sect1 id="nat">
      <title>Network Address Translation Rules</title>

      <sect2>
        <title>Basic NAT Rules</title>

        <figure id="nat-policy" float="1">
          <title>Network Address Translation Rules</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="nat_policy.jpg" format="jpg" align="Left" scale="50">
            </imageobject>
          </mediaobject>
        </figure>

        <para>Just like the firewall policy, the Network Address
        Translation (NAT) rules are inspected by the firewall in the
        order they appear in the NAT policy. Each NAT rule consists of
        the following rule elements:</para>

        <para>
          <itemizedlist spacing="compact">
            <listitem><para>Original Source</para>

              <para>This is the object which the source address of
              original packet should match for it to be translated by
              this rule </para>
            </listitem>
            <listitem><para>Original Destination</para>

              <para>This is the object which the destination address
              of original packet should match for it to be translated
              by this rule </para>
            </listitem>
            <listitem><para>Original Service</para>

              <para>This is the service which the original packet should
              match to be translated by this rule</para>
            </listitem>
            <listitem><para>Translated Source</para>

              <para>This object defines the address which should be
              used to substitute the original packet's source address
              </para>
            </listitem>
            <listitem><para>Translated Destination</para>

              <para>This object defines the address which should be
              used to substitute the destination address in the original
              packet.</para>
            </listitem>
            <listitem><para>Translated Service</para>

              <para>This object defines the protocol and port numbers
              which should be used to substitute those parameters in
              the original packet</para>
            </listitem>
            <listitem><para>Comment</para>
            </listitem>
          </itemizedlist>
        </para>

        <para>Here is how it works:</para>

        <para>The original packet is compared with NAT rules, one at a
        time, starting with the topmost rule. Once the rule that
        matches packet's source and destination addresses and its
        service is found, the firewall takes parameters from the
        second half of that rule and makes substitutions for the
        source and destination addresses and port numbers. Some rule
        elements in the first half of the rule may be left empty (they
        show "Any" in this case); these elements match any value of a
        corresponding parameter of the packet.  Some rule elements in
        the second half of the rule may also be left empty (in which
        case the GUI shows the word "Original" in the rule
        element). This tells the firewall that no substitution should
        happen for those elements. </para>

        <para>In fact the firewall not only substitutes addresses and
        port numbers, it also makes a record in its internal table to
        remember the original packet and translated packet it just
        produced. This way the firewall can perform a reverse
        translation when the reply packet comes back. </para>

        <para>The NAT rules in the screenshot <xref
        linkend="nat-policy"> tell the firewall to do the
        following:</para>

        <para>
          <itemizedlist spacing="compact">
            <listitem>
              <para>Rule #0:</para>

              <para>If the original packet has a destination address
              which matches the addresses of an external interface of
              the firewall object "firewall-iptables" and protocol TCP
              and port 80 (matches service "http", protocol used by
              web servers), then its destination address should be
              changed to that of the object "mail server" and the
              service should be left the same. Note that this rule
              would have had the same effect if the "Translated
              Service" was left "Original".</para>
            </listitem>
            <listitem>
              <para>Rule #1:</para>

              <para>This rule is very much the same as #0, except it
              works for packets headed for TCP port 25 (service "smtp"
              which describes protocol used to send and receive
              Internet email)</para>
            </listitem>
            <listitem>
              <para>Rule #2:</para>

              <para>This rule is like #0 and #1, except it works for
              the service "ssh"</para>
            </listitem>
            <listitem>
              <para>Rule #3:</para>

              <para>This rule follows the same pattern as #0-2, but
              translates packets headed for the external firewall's
              address, TCP port 2222, and sends them to the standard
              TCP port that belongs to the service "ssh" on the
              internal machine "build server". This rule illustrates
              that you can simultaneously translate both addresses and
              services: it makes changes to the destination address of
              the packet and the service.</para>
            </listitem>
            <listitem>
              <para>Rule #4:</para>

              <para>This rule matches packets that originated in the
              internal network (object "internal-net") and headed for
              DMZ net (object "dmz-net"). Since all rule elements in
              the second half of the rule are left blank, this rule
              tells the firewall that no translation is needed for
              these packets.</para>
            </listitem>
            <listitem>
              <para>Rule #5:</para>

              <para>This rule defines another type of translation: all
              packets originated in either the internal network or in
              DMZ net, going to any destination, should have their
              source address replaced with the address of the
              firewall's external interface. This type of translation
              rule is sometimes called the "Masquerading".</para>
            </listitem>
          </itemizedlist>
        </para>

        <para>Some firewall platforms support negation in NAT
        rules. If it is supported, this feature can be activated
        through the pop-up menu ( <xref linkend="editing-policy2"> )
        that appears when you click the right mouse button on the rule
        element in the NAT rule. <xref linkend="rule-elements"> shows
        what firewall platforms support negation in NAT.</para>

        <para>You can create NAT rules and edit them using the same
        methods as described in <xref linkend="editing-policy-and-nat"></para>

      </sect2>

      <sect2>
        <title>Source Address Translation</title>
        <para>
	Suppose your internal network is configured using so-called
	private IP addresses as defined in RFC 1918. These addresses
	are:
      </para>

        <para>
	<itemizedlist>
            <listitem>
              <para>
	    10.0.0.0 / 255.0.0.0
	    </para>
            </listitem>
            <listitem>
              <para>
	      172.16.0.0 / 255.240.0.0
	    </para>
            </listitem>
            <listitem>
              <para>
	      192.168.0.0 / 255.255.0.0
	    </para>
            </listitem>
          </itemizedlist>
      </para>

        <para>
        If your network uses addresses from one of these blocks, and
        you want to provide Internet access for machines on this net,
        then you may need Network Address Translation (NAT) configured
        on the firewall. This particular type of NAT configuration is
        often called Masquerading. When configured this way, the
        firewall rewrites source IP address of each packet sent by
        internal machines to the Internet, replacing private IP
        address with the address of its external interface.
      </para>

        <para>
        In Firewall Builder this type of the NAT rule is composed as
        shown on <xref linkend="basic-nat-1">
      </para>

        <para>
	<figure id="basic-nat-1">
            <title>Source Address Translation Rule</title>
            <mediaobject>
              <imageobject>
                <imagedata fileref="basic-nat-1.png" 
                           format="png" align="left" scale="50">
              </imageobject>
              <textobject>
                <phrase></phrase>
              </textobject>
            </mediaobject>
          </figure>
      </para>


        <para>
        In this rule object representing internal network is placed in
        "Original Source" and firewall's object is placed in
        "Translated Source", indicating that we want source address of
        the packets to be translated. As before, we do not need to
        worry about reply packets because underlying firewall software
        keeps track of translations done for all the connections
        opened through the firewall and rewrites addresses in all
        reply packets automatically.
      </para>

        <para>
        <xref linkend="basic-nat-1"> uses firewall object in
        Translated Source, which means source address of the packet
        will be substituted with the addresses of firewall's
        interfaces. Since the firewall has more than one interface,
        this rule will use all of them in a such fasion that packets
        exiting the firewall through interface
        <emphasis>"eth1"</emphasis> will have their source address
        translated into address of that interface, packets exiting
        through <emphasis>"eth2"</emphasis> will have its interface
        used for their source address and so on. Decision on which
        interface given packet should exit the firewall through is
        made by firewall's TCP/IP stack using its routing table.
      </para>

        <para>
        One of the consequences of this design is that rule #0 on
        <xref linkend="basic-nat-1"> provides translation for packets
        coming from <emphasis>internal_net</emphasis> and going out to
        the Internet, as well as those coming from
        <emphasis>internal_net</emphasis> and going back to the same
        net. The latter case may sound strange and useless, but we'll
        see later that it may have some very practical applications
        (see ... ).
      </para>

        <para>
        But what if the firewall has three or more interfaces ? This
        happens if it has multiple connections to the Internet or
        other insecure subnets like DMZ. Following the same logic, the
        translation will be performed using all interfaces of the
        firewall. <xref linkend="src-nat"> (A) illistrates this.
      </para>

        <para>
        There may be situations when we would not want to
        automatically use all interfaces of the firewall for
        translation.  Suppose firewall "firewall" has two insecure
        interfaces, one of which connects it to the Internet, while
        another one is connected to DMZ subnet which is using private
        IP addresses on the net 10.2.1.0. We want to translate the
        source address of packets going out to the Internet through
        external interface<emphasis>eth1</emphasis> and do not want
        any other translation to happen.  Rule #0 in <xref
                                                           linkend="basic-nat-2"> does just that.
      </para>

        <para>
	<figure id="basic-nat-2">
            <title>Source Address Translation Rule Using Interface of the Firewall</title>
            <mediaobject>
              <imageobject>
                <imagedata fileref="basic-nat-2.png" 
                           format="png" align="left" scale="50">
              </imageobject>
              <textobject>
                <phrase></phrase>
              </textobject>
            </mediaobject>
          </figure>
      </para>


        <para>
        Rule #0 in <xref linkend="basic-nat-2"> uses firewall's
        interface "eth1" for translation. This means that only packets
        exiting through this interface will be translated; packets
        exiting through <emphasis>"eth2"</emphasis> will keep their
        original source address on the internal net. <xref
                                                           linkend="src-nat"> (B) illistrates this.
      </para>

        <note>
          <para>
          Interface object can be used in the NAT rules even if the
          address of this interface is obtained dynamically and is not
          known beforehand.
        </para>
        </note>

        <para>
        Another possibility is when neither firewall itself, nor one
        of its interfaces is used in Translated Source in the
        rule. The translation is similar to the one in <xref
                                                             linkend="src-nat"> (A) except the same address is used
        regardless of the interface the packet exits firewall
        through. This case is illustrated in <xref
                                                   linkend="basic-nat-3"> and <xref linkend="src-nat"> (C).
      </para>

        <para>
	<figure id="basic-nat-3">
            <title>Source Address Translation Rule Using Host Object</title>
            <mediaobject>
              <imageobject>
                <imagedata fileref="basic-nat-3.png" 
                           format="png" align="left" scale="50">
              </imageobject>
              <textobject>
                <phrase></phrase>
              </textobject>
            </mediaobject>
          </figure>
      </para>


        <para>
	<figure id="src-nat">

            <title>Translations done to packets going in different
	  directions: (A) when firewall object is used in TSrc in the
	  NAT rule; (B) when interface eth1 is used in TSrc in the NAT
	  rule; (C) when host object with address 192.0.2.50 is used
	  in TSrc in the NAT rule</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="src-translations.png" 
                           format="png" align="left" scale="50">
              </imageobject>
              <textobject>
                <phrase></phrase>
              </textobject>
            </mediaobject>
          </figure>
      </para>

      </sect2>

      <sect2>
        <title>Destination Address Translation</title>

        <para>
        Suppose we have a network using private IP addresses behind
        the firewall, and a server on it. We need to provide access to
        this server from the Internet in a such way that connections
        will be established to the address of the firewall. In this
        case we need destination address of packets to be rewritten so
        packets would reach the server on internal network. The
        simplest rule that translates destination address of incoming
        packets looks like the one on <xref linkend="basic-nat-10-0">:
     </para>

        <para>
	<figure id="basic-nat-10-0">
            <title>Simple Destination Address Translation Rule</title>
            <mediaobject>
              <imageobject>
                <imagedata fileref="basic-nat-10-0.png" 
                           format="png" align="left" scale="50">
              </imageobject>
              <textobject>
                <phrase></phrase>
              </textobject>
            </mediaobject>
          </figure>
      </para>

        <para>
        Basically this rule says "if destination address of the packet
        matches one of the addresses of the firewall, replace it with
        the address defined by the object "server". Note that since we
        used firewall object in Original Destination, all addresses of
        all interfaces of the firewall are used for translation. <xref
                                                                       linkend="dst-nat"> (A) illustrates this. The red, green and
        blue packets come to the firewall from different subnets and
        all have destination addresses that match address of the
        corresponding interface. If it were not for our NAT rule,
        packets like that would have been accepted by the firewall and
        sent to a process expecting them. However NAT rule comes to
        play and changes destination address of all three packets to
        10.3.14.100 (the address of server). Packets with this address
        do not match any address belonging to the firewall and
        therefore get sent out of the firewall according to the rules
        of routing.
      </para>

        <para>
        The rule in <xref linkend="basic-nat-10-0"> does not specify
        any service for the translation and therefore translates
        addresses in packets of all protocols. This actually makes
        this rule rather impractical because it will translate and
        bounce any packets that are headed for the firewall, making it
        impossible to connect to the firewall itself using telnet or
        any other protocol. This is especially inconvenient since as
        we saw earlier translation happens for packets coming from all
        directions; this means that you won't be able to connect to
        the firewall even from inside of your network. To alleviate
        this problem we just add an appropriate service object to the
        rule as shown in <xref linkend="basic-nat-10">:
      </para>
        
        <para>
	<figure id="basic-nat-10">
            <title>Translation limited to packets of HTTP protocol</title>
            <mediaobject>
              <imageobject>
                <imagedata fileref="basic-nat-10.png" 
                           format="png" align="left" scale="50">
              </imageobject>
              <textobject>
                <phrase></phrase>
              </textobject>
            </mediaobject>
          </figure>
      </para>

        <para>
        Rule #0 in <xref linkend="basic-nat-10"> has limited scope
        because of the service object "http" in Original Service; it
        matches and performs address translation only for packets of
        HTTP protocol, while other packets are processed by TCP/IP
        stack on the firewall as usual. Very often we only want to
        translate address for packets coming from particular side of
        the firewall, typically from the Internet, and do not change
        other packets. Rule #0 on <xref linkend="basic-nat-11">
        achieves this goal by using firewall's interface object in
        Original Destination. Only packets with destination address
        the same as that of interface eth1 of the firewall match this
        rule and get their address translated. Packets coming from
        other directions will have different destination address and
        won't match the rule (see <xref linkend="dst-nat"> (B) ).
      </para>

        <para>
	<figure id="basic-nat-11">
            <title>Destination Address Translation Rule Using Interface of the Firewall</title>
            <mediaobject>
              <imageobject>
                <imagedata fileref="basic-nat-11.png" 
                           format="png" align="left" scale="50">
              </imageobject>
              <textobject>
                <phrase></phrase>
              </textobject>
            </mediaobject>
          </figure>
      </para>

        <para>
	<figure id="dst-nat">
            <title>Translations done to packets going in different
	  directions: (A) when firewall object is used in ODst in the
	  NAT rule and (B) when interface eth1 is used in ODst in the
	  NAT rule</title>
            <mediaobject>
              <imageobject>
                <imagedata fileref="dst-translations.png" 
                           format="png" align="left" scale="50">
              </imageobject>
              <textobject>
                <phrase></phrase>
              </textobject>
            </mediaobject>
          </figure>
        </para>

      </sect2>

    </sect1>

    <sect1 id="editing-policy-and-nat">
      <title>Editing firewall Policy and NAT Rules</title>

      <sect2>
        <title>Adding and removing rules</title>

        <figure id="editing-policy1" float="1">
          <title>Modifying Policy rules</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="editing_policy1.jpg" format="jpg" align="Left" scale="50">
            </imageobject>
          </mediaobject>
        </figure>

        <para>Rules can be added, removed or moved around in the
          policy using commands in a popup menu which appears if you
          click the right mouse button on the rule element "Num" (the
          very first rule element, counting from the left). Screenshot
          <xref linkend="editing-policy1"> illustrates this
          menu. </para>

        <para>This menu allows for adding new rules above or below
          of the currently selected rule in the policy, removing
          rules, moving the current rule up and down, plus the usual
          <guimenuitem>"Copy"</guimenuitem>/<guimenuitem>"Paste"</guimenuitem>
          operations done on policy rules.</para>

        <para>Functions of this pop-up menu are also duplicated in
          the main menu <guimenuitem>"Rules"</guimenuitem></para>

        <para>You can also use the drag and drop operation to move
          rules up and down in the policy. Just drag the rule with the
          mouse by its "number" rule element.</para>
      </sect2>

      <sect2>
        <title>Adding, removing and modifying objects in the policy
          and NAT rules</title>

        <para>To add objects to the policy or NAT rule you can
          either drag them from the tree and drop them into the
          corresponding rule element, or use the
          <guimenuitem>"Copy"</guimenuitem>/<guimenuitem>"Paste"</guimenuitem>
          operation. Objects can be copied into clipboard both from
          the tree and from another policy rule; in both cases use the
          pop-up menu or main menu <guimenuitem>"Edit"</guimenuitem>.</para>

        <para>Clicking the right mouse button when the cursor is
          over rule elements "Source","Destination" or "Service"
          brings a context-sensitive pop-up menu ( <xref
                                                         linkend="editing-policy2"> ). The same pop-up menu appears
          when you do that over the "Original Source", "Original
          Destination", "Original Service", "Translated Source",
          "Translated Destination" and "Translated Service" rule
          elements in the NAT rule. </para>

        <figure id="editing-policy2" float="1">
          <title>Modifying Object in the Policy Rule</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="editing_policy2.jpg" format="jpg" align="Left" scale="50">
            </imageobject>
          </mediaobject>
        </figure>

        <para>This menu provides items for the following functions:</para>

        <para>
          <itemizedlist spacing="compact">
            <listitem>
              <para>Edit:</para>

              <para>This menu item opens the currently selected
                object in the dialog</para>
            </listitem>
            <listitem>
              <para>Edit in a new window:</para>

              <para>This menu item creates a new main window and
                opens the currently selected object in it. If more
                than one main window currently exists, the object will
                be opened in one of the existing windows.</para>
            </listitem>
            <listitem>
              <para>Copy:</para>

              <para>The object is copied into clipboard.</para>
            </listitem>
            <listitem>
              <para>Cut:</para>

              <para>The object is copied into clipboard and removed from the rule.</para>
            </listitem>
            <listitem>
              <para>Paste:</para>

              <para>The object is copied from the clipboard to the rule.</para>
            </listitem>
            <listitem>
              <para>Negate:</para>

              <para>All objects in the selected rule element are
                negated. The rule element "Source" is negated in
                rule #1 in screenshot <xref linkend="editing-policy2">
                </para>
            </listitem>
          </itemizedlist>
        </para>

      </sect2>

      <sect2>
        <title>Changing rule action</title>

        <para>Clicking the right mouse button when the cursor is
          over the rule element "Action" brings a context-sensitive
          pop-up menu ( <xref linkend="editing-policy3"> ).</para>

        <figure id="editing-policy3" float="1">
          <title>Modifying the Action of the Policy Rule</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="editing_policy3.jpg" format="jpg" align="Left" scale="50">
            </imageobject>
          </mediaobject>
        </figure>

        <para>This menu provides items for the following functions:</para>

        <itemizedlist spacing="compact">
          <listitem>
            <para>Accept:</para>

            <para>The rule will accept the packet matching it</para>
          </listitem>
          <listitem>
            <para>Deny:</para>

            <para>The rule will drop the packet matching it</para>
          </listitem>
          <listitem>
            <para>Reject:</para>

            <para>The rule will drop the packet matching it, and will also
            send appropriate ICMP responce message back to
            source.</para>
          </listitem>
        </itemizedlist>

      </sect2>

      <sect2>
        <title>Changing rule direction</title>

        <para>Clicking the right mouse button when the cursor is
          over the rule element "Direction" brings a context-sensitive
          pop-up menu ( <xref linkend="editing-policy4"> ).</para>

        <figure id="editing-policy4" float="1">
          <title>Modifying the Direction of the Policy Rule</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="editing_policy4.jpg" format="jpg" align="Left" scale="50">
            </imageobject>
          </mediaobject>
        </figure>

        <para>This menu provides items for the following functions:</para>

        <itemizedlist spacing="compact">
          <listitem>
            <para>Inbound:</para>

            <para>The rule matches packets entering the firewall</para>
          </listitem>
          <listitem>
            <para>Outbound:</para>

            <para>The rule matches packets exiting the firewall</para>
          </listitem>
          <listitem>
            <para>Both:</para>

            <para>The rule matches both entering and exiting packets</para>
          </listitem>
        </itemizedlist>

      </sect2>

      <sect2>
        <title>Changing rule options and logging</title>

        <para>clicking the right mouse button when the cursor is
          over the rule element "Options" brings up a
          context-sensitive pop-up menu ( <xref
                                                linkend="editing-policy5">. )</para>

        <figure id="editing-policy5" float="1">
          <title>Modifying Options of the Policy Rule</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="editing_policy5.jpg" format="jpg" align="Left" scale="50">
            </imageobject>
          </mediaobject>
        </figure>

        <para>This menu provides items for the following functions:</para>

        <itemizedlist spacing="compact">
          <listitem>
            <para>Modify Options:</para>

            <para>This menu item brings up a dialogue which allows
              you to modify certain options specific to the target
              firewall platform and associated only with the current
              rule.</para>
          </listitem>
          <listitem>
            <para>Turn logging ON:</para>

            <para>Turns logging on for all packets matching this
              rule. If the target firewall platform does not support
              selective logging of packets, this menu item is
              disabled.</para>
          </listitem>
          <listitem>
            <para>Turn logging OFF:</para>

            <para>Turn logging off for packets matching this rule.
              If the target firewall platform does not support
              selective logging of packets, this menu item is
              disabled.</para>
          </listitem>
        </itemizedlist>

      </sect2>

    </sect1>



    <sect1 id="rule-elements">
      <title>Support for Rule Elements and Features on Various Firewalls</title>

      <para>Certain fields in the rules are only available if the
      target firewall platform supports them.  For example, the
      iptables firewall provides controls for logging of matched
      packets, while Cisco PIX does not; PIX always logs every packet
      it drops. Where possible, the policy compilers are trying to
      emulate the missing feature. For example, OpenBSD PF does not
      support negation natively, but policy compiler
      <emphasis>"fwb_pf"</emphasis> provides a workaround and tries to
      emulate this feature for PF. Another example is policy rules
      with "Outbound" direction. Cisco PIX supports only inbound
      Access Lists, so the policy compiler emulates outbound Access
      Lists while generating configuration for PIX. <xref
      linkend="policy-rule-elements"> represents a list of fields in
      the rules and which firewall platforms support them. Information
      about these fields and features is available for fwbuilder GUI
      that disables corresponding menu items and hides associated
      policy elements when they are not supported.</para>

      <para>
          <table id="policy-rule-elements">
          <title></title>
          <tgroup cols="11">
            <thead>
              <row>
                <entry>Firewall Platform</entry>
                <entry>Source</entry>
                <entry>Destination</entry>
                <entry>Service</entry>
                <entry>Time Interval</entry>
                <entry>Direction</entry>
                <entry>Action</entry>
                <entry>Logging/ Options</entry>
                <entry>Comment</entry>
                <entry>Negation in Policy rules</entry>
                <entry>Negation in NAT rules</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>iptables</entry>
                <entry>+</entry>
                <entry>+</entry>
                <entry>+</entry>
                <entry>+</entry>
                <entry>+</entry>
                <entry>+</entry>
                <entry>+</entry>
                <entry>+</entry>
                <entry>+</entry>
                <entry>+</entry>
              </row>
              <row>
                <entry>ipfilter</entry>
                <entry>+</entry>
                <entry>+</entry>
                <entry>+</entry>
                <entry>-</entry>
                <entry>+</entry>
                <entry>+</entry>
                <entry>+</entry>
                <entry>+</entry>
                <entry>+</entry>
                <entry>-</entry>
              </row>
              <row>
                <entry>pf</entry>
                <entry>+</entry>
                <entry>+</entry>
                <entry>+</entry>
                <entry>-</entry>
                <entry>+</entry>
                <entry>+</entry>
                <entry>+</entry>
                <entry>+</entry>
                <entry>+</entry>
                <entry>+</entry>
              </row>
              <row>
                <entry>Cisco PIX</entry>
                <entry>+</entry>
                <entry>+</entry>
                <entry>+</entry>
                <entry>-</entry>
                <entry>+</entry>
                <entry>+</entry>
                <entry>-</entry>
                <entry>+</entry>
                <entry>-</entry>
                <entry>-</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        </para>

    </sect1>

    <sect1 id="multiple-addresses">
      <title>Using Objects With Multiple Addresses in the Policy and NAT rules</title>

      <para>One of the great advantages of the object-oriented
      approach to building firewall's policy is that it helps simplify
      the representation of the policy. Host and Firewall objects can have
      child Interface objects, which in turn have child Address and
      Physical Address objects. Any object in the hierarchy Host -
      Interface - Address/Physical Address can be used in the policy
      and compiler uses all objects in the hierarchy down from the one
      used in the policy to build the rule.</para>

      <figure id="multiple-addresses-obj1" float="1">
        <title>Host object with an interface that has multiple addresses</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="multiple-addresses-obj1.jpg" format="jpg" align="Left" scale="50">
          </imageobject>
        </mediaobject>
      </figure>
    

      <figure id="multiple-addresses1" float="1">
        <title>Using objects with multiple addresses in the policy
        rules</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="multiple-addresses-rule1.jpg" format="jpg" align="Left" scale="50">
          </imageobject>
        </mediaobject>
      </figure>
    

      <para>Consider example <xref linkend="multiple-addresses-obj1">, <xref linkend="multiple-addresses1">.
      Here interface <emphasis>eth0</emphasis> of the Host object
      <emphasis>"test server"</emphasis> has three IP addresses (named
      <emphasis>"test server:eth0:1"</emphasis> through
      <emphasis>"test server:eth0:3"</emphasis>) and interface
      <emphasis>eth0</emphasis> of the Host object <emphasis>"dmz
      host"</emphasis> has only one IP address <emphasis>"dmz
      host:eth0"</emphasis>. Policy rule #4 says that <emphasis>"dmz
      host"</emphasis> can talk to <emphasis>"test server"</emphasis>
      using any protocol. Since <emphasis>"test server"</emphasis> has
      three different addresses, we need to generate policy rule that
      will match any of them (obviously not on all three at once,
      that's impossible, so we have to use logical operation "OR", not
      "AND" here.) Basically, rule #4 is equivalent to three separate
      rules, each of them using one address of <emphasis>"test
      server"</emphasis> in turn. These three rules are represented in
      <xref linkend="multiple-addresses2"> (original rule #4 also
      shown there, but it is disabled.)</para>

      <figure id="multiple-addresses2" float="1">
        <title>Equivalent rules</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="multiple-addresses-rule2.jpg" format="jpg" align="Left" scale="50">
          </imageobject>
        </mediaobject>
      </figure>
    
      <para>Firewall Builder takes care of this situation
      automatically and generates firewall policy described in
      <xref linkend="multiple-addresses1"> as if a user have built a policy in
      the GUI using the three rules as shown in <xref
      linkend="multiple-addresses2">. </para>

      <para>In fact, the algorithm it uses is even more general. In
      the example <xref linkend="multiple-addresses1"> host
      <emphasis>"test server"</emphasis> has single interface with
      multiple addresses which compiler used to generate target
      firewall code. The policy compiler works in a similar way even
      if host or firewall object used in the rule has multiple
      interfaces and each interface, in turn, has multiple
      addresses. If host (or firewall) object is used in the rule,
      then the compiler scans all its interfaces, finds all
      corresponding addresses and uses them to generate firewall
      configuration. If interface object is used in the rule, then the
      compiler uses all its addresses. And finally, if Address or
      Physical Address object is used in the rule, then compiler uses
      only this parameter to generate the target firewall
      configuration. In other words, compiler always traverses the
      tree, starting from the object found in the policy rule and uses
      parameters of all Address and Physical Address objects it
      finds. Since Address and Physical Address objects are the leaf
      nodes in the tree and have no other objects beneath them, the
      compiler uses parameters of the objects of these types to
      generate the target code. </para>

      <note><para>There is an exception to this algorithm, see <xref
        linkend="using-mac-address"></para></note>
    </sect1>

  </chapter>


  <chapter id="policy">
    <title>Examples of Policy Rules
    </title>

    <!-- ********************************************************* -->
    <sect1>
      <title>
	Letting certain protocols through, while blocking everything else
      </title>

      <para>
	This is one of the simplest, most basic tasks you may want
	your firewall to do - block all the traffic while letting
	certain protocols through. Let's assume that we have a network
	consisting of just the firewall "firewall1" and a few hosts
	behind it. We want to let protocols SMTP and FTP through to
	the server "hostA" from the Internet, and block everything
	else. All we need to do is put the following rules in the
	Global Policy:
      </para>

      <para>
	<figure>
	  <title>Example of a rule permitting only certain protocols to the server and blocking everything else. </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="policy-1.png" format="png" align="left" scale="50">
	    </imageobject>
	    <textobject>
	      <phrase>[]</phrase>
	    </textobject>
	  </mediaobject>
	</figure>
      </para>

      <para>
	Rule #0 allows SMTP and FTP through to the server, while rule #1 blocks
	and logs everything else. It is worth mentioning that this policy also blocks
	all the access to firewall itself, including access to it from internal
	hosts.
      </para>

      <para>
	We do not need any additional rules to take care of &quot;reply&quot; packets coming
	back from the server to clients because our underlying firewall software
	supports stateful inspection and &quot;understands&quot; that such packets should be
	let through.
      </para>

    </sect1>


    <!-- ********************************************************* -->
    <sect1>
	<title>Interchangeable and non-interchangeable objects</title>

      <para>
	In the previous example we put object "hostA" into the
	Destination field of the policy rule #0 because our goal was
	to permit protocols SMTP and FTP to that host and not to any
	other one. This actually reflects general principle Firewall
	Builder is based on: put the object you want to control access
	for in the Source or Destination field of the policy rule. Two
	different objects with the same address may or may not be
	interchangeable, depending on their type and other
	parameters. One of the frequent mistakes is to create Host
	object with IP address of the firewall, then use it in the
	policy and expect Firewall Builder to build policy controlling
	access to the firewall.  Unfortunately it does not always work
	that way. If you wish to control access to or from the
	firewall machine, then put Firewall object into the policy
	rule.
      </para>

      <para>
	Another example of two objects which may on the first glance
	represent the same thing, but in fact are not interchangeable,
	is IP service object with protocol number set to 1 and ICMP
	service object with type and code set to "any". Both objects
	might represent the same type of service, namely "Any ICMP
	message". IP protocol 1 is in fact ICMP, so one would expect
	the behaviour of the firewall to be the same regardless of
	what type of service object is used. However, target firewall
	software typically uses special syntax for indication of
	different protocols, so using proper syntax for ICMP protocol
	turns certain features on, like for example session state
	tracking. Using just IP with protocol number 1 will most
	likely not turn these features on and therefore will lead to
	unexpected results.
      </para>
      
      <para>
	On the other hand, two objects of the same type with different
	names but the same values of all other parameters are
	perfectly interchangeable. Using different objects to describe
	the same object may be confusing, but the final firewall
	policy will be correct. Firewall Builder leaves design of the
	objects up to the firewall administrator. 
      </para>
    </sect1>


    <!-- ********************************************************* -->
    <sect1>
      <title>Using groups</title>
 
      <para>
	Sometimes we need to define a lot of very similar rules for
	multiple hosts or networks. For example, there may be a need
	to permit the same service to 10 different hosts on the
	network, while still blocking it to all others. The simplest
	way to accomplish this is to add 10 rules with the same source
	and service fields and just different destinations. Obviously
	this can make firewall policy quite cluttered. To avoid this
	and make policy readable we can use groups. Group is just a
	container which includes multiple objects of the same or
	similar type. Firewall Builder supports groups of objects and
	groups of services. One can put "Host", "Network" and
	"Firewall" objects in the group of objects; service objects
	can not be put in a such group. Similarly group of services
	can contain "IP Service", "TCP Service", "UDP Service" and
	"ICMP Service" objects and can not contain hosts or
	networks. Groups can contain other groups of the same type as
	well. <xref linkend="group-dialog1"> represents an example of
	the object group.
      </para>

      <para>
	To add objects to a group simply drag them from the tree on
	the left into group view on the right, or use Copy/Paste
	functions available via menus.
      </para>

      <para>
	Once appropriate group has been created, it can be used for
	the policy and NAT rules just like any other object.
      </para>

      <para>
	<figure>
	  <title>Example of a rule using object group. </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="policy-1-1.png"
                  format="png" align="left" scale="50">
	    </imageobject>
	    <textobject>
	      <phrase>[]</phrase>
	    </textobject>
	  </mediaobject>
	</figure>
      </para>


    </sect1>

    <!-- ********************************************************* -->
    <sect1>
      <title>Firewall talking to itself</title>
 
      <para>Many services running on the firewall machine need to be
      able to establish connections to the same machine. X11, RPC, DNS
      are services like that, to name a few. Blocking these services
      on the firewall can cause various problems, depending on what
      protocol is being blocked. If it is DNS, then it may take a lot
      longer than usual to get to a command line prompt when logging
      in to the machine using telnet or ssh. Once logged in, you won't
      be able to resolve any host names into addresses. If X11 is
      blocked, then X server and any graphic environment using it
      (KDE, Gnome etc.)  won't start. In any case though the problem
      can easily be solved by adding a simple rule to the loopback
      interface of the firewall to permit all sorts of
      commincations. As shown on <xref linkend="rule-on-loopback">,
      this rule should use firewall object in both source and
      destination, have action <emphasis>Accept</emphasis> and
      direction <emphasis>Both</emphasis>.  </para>

      <para>
	<figure id="rule-on-loopback">
	  <title>Rule permitting everything on the loopback interface</title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="policy-10.png"
                  format="png" align="left" scale="50">
	    </imageobject>
	    <textobject>
	      <phrase>[]</phrase>
	    </textobject>
	  </mediaobject>
	</figure>
      </para>


      <note><para>
        Running X11 and other complex services on the dedicated
        firewall machine should be discouraged, however
        recommendations given in this chapter do apply to the firewall
        protecting a server or a workstation where X11, RPC and other
        services are perfectly normal.
      </para></note>
    </sect1>

    <!-- ********************************************************* -->
    <sect1>
      <title>Blocking unwanted types of packets</title>
 
      <para>
	Fragmented IP packets, although useful in certain situations,
	are often used as a tool to probe and penetrate simple packet
	filters. Particular kind of fragmented packets, namely those
	with incorrect length specification, are especially bad
	because they can cause some operating systems to crash (for
	example Windows NT was known to crash before fix was developed
	and published by Microsoft).  These packets therefore are
	considered potentially harmful and should be blocked on the
	perimeter of your network. Many firewall platforms provide
	ways to deal with such packets.
      </para>

      <para>
	In Firewall Builder, we provide a way to set flags or options
	in the IP service object. Two options deal with fragments: one
	is called "all fragments" and another "short fragments". <xref
	linkend="f-policy-2"> shows how does object "ip_fragments"
	look like with both options turned on. Policy compilers
	recognize this object and generate correct code for underlying
	firewall software platform.
      </para>

      <para>
	<figure id="f-policy-2">
	  <title>IP Service object which represents fragmented packets.</title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="policy-2.png" format="png" align="left" scale="50">
	    </imageobject>
	    <textobject>
	      <phrase>[IP Service object which represents fragmented packets]</phrase>
	    </textobject>
	  </mediaobject>
	</figure>
      </para>

      <para>
	Object "ip_fragments" is included in the section "Services/IP"
	of the standard objects database coming with Firewall Builder.
      </para>

      <para>
	Another potentially harmful type of packets is so called
	"Christmas tree" packet. This one is just a TCP packet with
        impossible combination of TCP flags or even all TCP flags
        turned on at once (for example SYN, ACK, FIN, RST, PSH). This
        combination is never used in real communications, so if a
        packet like that appears at the boundary of your network, it
        should be considered illegal and blocked. Object "tcp-xmas" is
        included in the section "Services/TCP" of the standard objects
        database coming with Firewall Builder.
      </para>

      <para>
	Some platforms provide a mechanism to turn on and off stateful
	inspection on individual rules. Turning it off on those rules
	which do not require it may improve performance of the
	firewall.  Obviously we do not need stateful inspection while
	analysing fragmented packets as we do not really want any
	session to be established, so we can safely use this option on
	this rule. One example of firewall platform which supports
	stateful inspection but provides a way to turn it on and off
	is iptables. In Firewall Builder, this can be done in the rule
	options dialog (which is platform-sensitive and shows
	different options for different platforms). <xref
	linkend="f-policy-3"> shows rule options dialog for iptables
	firewall:
      </para>

      <para>
	<figure id="f-policy-3">
	  <title>Rule options dialog for iptables firewall</title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="policy-3.png" format="png" align="left" scale="50">
	    </imageobject>
	    <textobject>
	      <phrase>[Rule options dialog for iptables firewall]</phrase>
	    </textobject>
	  </mediaobject>
	</figure>
      </para>

      <para>
	Here is an example of the policy rule which is intended to
	block all fragmented and TCP "Christmas tree" packets. Note an
	icon in the "Options" column, it indicates that this rule has
	non-default options set.
      </para>

      <para>
	<figure>
	  <title>Rule blocking all fragmented packets and TCP "christmas tree" packets</title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="policy-4.png" format="png" align="left" scale="50">
	    </imageobject>
	    <textobject>
	      <phrase>[Rule blocking all fragmented packets and TCP "christmas tree" packets]</phrase>
	    </textobject>
	  </mediaobject>
	</figure>
      </para>

      <para>
	This rule is part of the Global Policy and therefore applies
	to all packets crossing the firewall regardless of their
	origin. This means that it will block such packets originating
	in your network, too. If by some reason you might want to be
	able to send this kind of packets out, then put this rule in
	the Interface Policy on your external interface, with
	Direction "Inbound".
      </para>

      <para>
	An interactive Druid available via menu item "Rules/Help me
	build firewall policy" can create a rule to protect against
	fragmented packets.
      </para>
    </sect1>


    <!-- ********************************************************* -->
    <sect1>
      <title>Anti-spoofing rules</title>
 
      <para>
        Generally speaking, IP spoofing is a technique of generating
        IP packets with source address that belongs to someone else.
        Spoofing creates danger when hosts on the LAN permit access to
        their resources and services to trusted hosts by checking
        source IP of the packets. Using spoofing, intruder can fake
        source address of his packets and make them look like those
        originated on the trusted hosts.  Basic idea of anti-spoofing
	protection is to create a firewall rule assigned to the
	external interface of the firewall to examine source address
	of all packets crossing that interface coming from outside. If
	the address belongs to internal network or firewall itself,
	packet should be dropped. Since rule must take into account
	both the interface packet is coming through and the direction in
	which it is coming, it must be put into Interface Policy. This
	is one of the rare cases when the rule can not be put into
	Global Policy.
      </para>

      <para>
	To create anti-spoofing rule in Firewall Builder we need
	objects for all subnets inside the firewall perimeter and
	obviously an object for firewall itself. Objects for internal
	subnets can be put in the single group, to make rule
	compact. Then we create a rule in the Interface Policy of
	firewall's external interface (interface eth1 on <xref
	linkend="f-policy-5">) and put all these objects, or a group
	which contains them, plus the firewall object in the "source"
	rule element. "Destination" and "service" must be set to "any"
	and Direction must be set to "inbound". <xref
	linkend="f-policy-5"> shows the anti-spoofing rule.
      </para>

      <para>
       <xref linkend="creating_firewall"> explains how firewall object
       and its interfaces can be created. <xref
       linkend="firewall-interface"> has more details on the
	firewall's interfaces, their types and other properties. <xref
	linkend="directions"> explains concept of the direction.
      </para>

      <para>
	<figure id="f-policy-5">
	  <title>Anti-spoofing rule</title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="policy-5.png" format="png" align="left" scale="50">
	    </imageobject>
	    <textobject>
	      <phrase>[Anti-spoofing rule]</phrase>
	    </textobject>
	  </mediaobject>
	</figure>
      </para>

      <para>
	Just like in the previous example, it may be advantageous to
	turn stateful inspection off on anti-spoofing rules. Since we
	want to prevent these packets from entering our network, there
	is going to be no session opened and we do not want to keep
	state at all. You can use "Options" element to do it.
      </para>

      <para>
	An interactive Druid available via menu item "Rules/Help me
	build firewall policy" can create anti-spoofing rules.
      </para>
    </sect1>

    <!-- ********************************************************* -->
    <sect1>
      <title>Protecting local host</title>
 
      <para>
	This is the kind of policy you would want if you are using
	firewall software running on the host itself.  Sometimes your
	host may obtain its IP address dynamically using DHCP or PPPoE
	protocol; Firewall Builder can handle this situation as well.
      </para>

      <para>
	<itemizedlist>
	  <listitem>
	    <para> create firewall object, do not forget to choose
	    firewall platform and OS it is running on and add its
            interfaces, including loopback interface. If host gets its
            IP address dynamically, mark interface as 'dynamic' using
            appropriate checkbox. See <xref linkend="creating_firewall">.
	    </para>
	  </listitem>
	  <listitem>
	    <para> call Druid, choose "Firewall protects local host"
	    and then pick rules you want. 
	    </para>
	  </listitem>
	</itemizedlist>
      </para>

      <para>
	See what Druid have created for you. You can edit these and
	add more rules now.
      </para>

    </sect1>

    <!-- ********************************************************* -->
    <sect1>
      <title>Proper blocking of Ident protocol</title>
 
      <para>
	Suppose we want to block connections to certain ports on the
	server behind the firewall, but want to do it in a "polite"
	manner, that is somehow let sender host know right away that
	the connection attempt was blocked so our server would look
	like nothing is listening on that port at all. One of the
	practical applications of this setup would be blocking Ident
	connections to a mail relay or a mail server. Sendmail and
	many other MTA's (Mail Transport Agents) attempt to connect to
	Ident port (TCP port 113) on the mail relay every time they
	accept email from that relay. Many believe Ident protocol is
	practically useless and does not really serve as a protection
	against SPAM or for any other useful purpose. Unfortunately
	silent blocking of ident connections on the firewall using a
	rule with action <emphasis>"Deny"</emphasis> adds a delay in
	the email delivery. This happens because when sender host
	tries to establish Ident connection to the recipient, it sends
	TCP SYN packet to it (the first packet in three-way TCP
	handshake) and then waits for TCP ACK packet in
	responce. However, it never sees it because recipient's
	firewall blocked its first TCP SYN packet. In the situation
	like this sender host assumes the reply packet got lost and
	tries to send TCP SYN packet again. It repeats this for a few
	seconds (usually 30 sec) before it gives up. This adds 30 sec
	delay to email delivery. Our intent is to show how one can
	construct a policy rule to block Ident without causing this
	delay.
      </para>

      <para>
	The simplest way to block any protocol is to use "Deny" action
	in the policy rule. Since "Deny" causes firewall to silently
	drop the packet, sender never knows what happened to it and
	keeps waiting for responce. To avoid this delay we will set
	rule Action to "Reject". Normally "Reject" makes firewall to
	send ICMP "unreachable" message back to sender, thus
	indicating that access to requested port is denied by the
	firewall. This may be insufficient in some cases because host
	trying to connect to our Ident port won't understand this type
	of ICMP message and will keep trying. In fact, most OS do not
	recognize ICMP "administratively prohibited" message and do
	keep trying. To make host on the other side stop its attempts
	right away we need to send TCP RST packet back instead of ICMP
	message. This can be done by adding appropriate rule option
	(see <xref linkend="f-policy-7">) It is also safe to turn
	stateful inspection off on this rule since we do not want
	connection to be established and therefore do not need to
	keep track of it.
      </para>

      <para>
	<figure>
	  <title>Using action "Reject" with rule option</title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="policy-6.png" format="png" align="left" scale="50">
	    </imageobject>
	    <textobject>
	      <phrase>[Using action "Reject" with rule option]</phrase>
	    </textobject>
	  </mediaobject>
	</figure>
      </para>

      <para>
	<figure id="f-policy-7">
	  <title>Adding rule option to make send TCP RST packet</title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="policy-7.png" format="png" align="left" scale="50">
	    </imageobject>
	    <textobject>
	      <phrase>[Adding rule option to make send TCP RST packet]</phrase>
	    </textobject>
	  </mediaobject>
	</figure>
      </para>

    </sect1>


    <!-- ********************************************************* -->
    <sect1>
      <title>Using negation in policy rules</title>
 
      <para>
	Suppose we want to set up a rule to permit access from the
	host on DMZ net "mail_relay_1" to hosts on the Internet, but
	do not want to open access from it to machines on our internal
	network represented by the object "internal_net". Since we
	want it to connect to hosts on the Internet and can not
	predict their addresses, we have to use "any" as a destination
	in the policy rule. Unfortunately "any" includes our internal
	net as well, which is going to open undesired hole in the
	firewall.
      </para>

      <para>
	There are two solutions to this problem. First, we can use two
	rules: first will deny access from "mail_relay_1" to
	"internal_net" and the second will permit access from
	"mail_relay_1" to "any". Since rules are consulted in the
	order they are specified in the policy, access to internal net
	will be blocked by the first rule since the packet would hit
	it first. These two rules are represented on <xref linkend="f-policy-8">
      </para>

      <para>
	<figure id="f-policy-8">
	  <title>Using two rules to block access from DMZ to internal net and permit
	    access to the Internet</title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="policy-8.png" format="png" align="left" scale="50">
	    </imageobject>
	    <textobject>
	      <phrase>[Using two rules to block access from DMZ to internal net and permit
		access to the Internet]</phrase>
	    </textobject>
	  </mediaobject>
	</figure>
      </para>

      <para>
	Another solution uses negation. We can specify destination in
	the rule as "not internal_net", thus permitting access to
	anything but "internal_net".  Negation can be enabled and
	disabled in the pop-up menu which you call by clicking right
	mouse button on the corresponding rule field. This rule
	depends on the rules below it to block access from
	"mail_relay1" to the "internal_net". If the policy was built
	using general principle of blocking everything and then
	enabling only types of connections that must be permitted,
	then it usually has a "catch-all" rule at the bottom that
	blocks everything. This last rule is going to deny connections
	from the "mail_relay1" to "internal_net".
      </para>

      <para>
	<figure id="f-policy-9">
	  <title>Using rule with negation to block access from DMZ to internal
	net and permit access to the Internet</title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="policy-9.png" format="png" align="left" scale="50">
	    </imageobject>
	    <textobject>
	      <phrase>[Using rule with negation to block access from DMZ to internal
		net and permit access to the Internet]</phrase>
	    </textobject>
	  </mediaobject>
	</figure>
      </para>

      <para>
	Negation can be used in NAT rules in a similar way.
      </para>
    </sect1>
  </chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

  <chapter id="nat-examples">

    <title>Examples of Network Address Translation Rules</title>

      
    <!-- ********************************************************* -->
    <sect1>
      <title>Providing Internet connection for workstations behind the firewall</title>

      <para>
	Suppose your internal network is configured using so-called
	private IP addresses as defined in RFC 1918. These addresses
	are:
      </para>

      <para>
	<itemizedlist>
	  <listitem>
	    <para>
	    10.0.0.0 / 255.0.0.0
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      172.16.0.0 / 255.240.0.0
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      192.168.0.0 / 255.255.0.0
	    </para>
	  </listitem>
	</itemizedlist>
      </para>

      <para>
	If your network uses addresses from one of these blocks, and
	you want to provide Internet access for machines on this net,
	then you may need Network Address Translation (NAT) configured
	on the firewall. This particular type of NAT configuration is
	often called Masquerading.  When configured this way, the firewall
	rewrites source IP address of each packet sent by internal
	machines to the Internet, replacing private IP address with the
	address of its external interface.
      </para>

      <para>
	In Firewall Builder this type of the NAT rule is composed as
	shown on <xref linkend="f-nat-1">
      </para>

      <para>
	<figure id="f-nat-1">
	  <title>Masquerading rule (this rule is part of NAT ruleset)</title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="nat-1.png" 
                  format="png" align="left" scale="50">
	    </imageobject>
	    <textobject>
	      <phrase>[Masquerading rule (part of NAT ruleset)]</phrase>
	    </textobject>
	  </mediaobject>
	</figure>
      </para>

      <para>
	Here, object representing internal network is placed in
	"Original Source" and firewall's object is placed in
	"Translated Source", thus indicating that we want source
	address of the packets to be translated.  As before, we do not
	need to worry about reply packets because underlying firewall
	software keeps track of translations done for all the
	connections opened through the firewall and rewrites addresses
	in all reply packets automatically.
      </para>

      <para>
        <xref linkend="f-nat-1"> uses firewall object in Translated
        Source, which means firewall will substitute a source address
        in the packet for the address of its external interface. But
        what if the firewall has two or more external interfaces ?
        This happens if it has multiple connections to the Internet or
        other insecure subnets like DMZ. Generally speaking,
        Masquerading rule translates source address of packets that go
        from the more secure subnet to the less secure one. See <xref
        linkend="firewall-interface"> for detailed explanation of
        Security Levels of firewall's interfaces. If the firewall has
        multiple interfaces and firewall object is used in the
        Translated Source of the NAT rule like in <xref
        linkend="f-nat-1">, then the firewall will translate source
        address into address of the interface through which the packet
        is going to exit (which is dictated by the routing
        table). Firewall <emphasis>"fw2"</emphasis> on <xref
        linkend="f-nat-1-1"> has two insecure interfaces:
        <emphasis>"eth1"</emphasis> and <emphasis>"eth2"</emphasis>,
        both use routable IP addresses. NAT rule #0 will automatically
        translate source address of outgoing packets into the address
        of either eth1 or eth2, depending on the routing which
        dictates through which interface the packet is going to exit.
      </para>

      <para>
	<figure id="f-nat-1-1">
	  <title>NAT rule for the firewall with two external interfaces</title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="nat-1-1.png"
                  format="png" align="left" scale="50">
	    </imageobject>
	    <textobject>
	      <phrase></phrase>
	    </textobject>
	  </mediaobject>
	</figure>
      </para>

      <para>
        There may be situations when we would not want to
        automatically use all external interfaces of the firewall for
        translation. Suppose firewall <emphasis>"fw2"</emphasis> has
        two insecure interfaces, one of which connects it to the
        Internet, while another one is connected to DMZ subnet which
        is using private IP addresses on the net 192.168.2.0. We want
        to do the same masquerading translation for all packets going
        from internal network to the Internet as before, but do not
        need to translate packets going from the internal net to
        DMZ. <xref linkend="f-nat-1-2"> illustrates this configuration.
      </para>

     <para>
	<figure id="f-nat-1-2">
	  <title>Translation using only one interface of the firewall</title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="nat-1-2.png"
                  format="png" align="left" scale="50">
	    </imageobject>
	    <textobject>
	      <phrase></phrase>
	    </textobject>
	  </mediaobject>
	</figure>
      </para>

      <para>
        Rule #0 in <xref linkend="f-nat-1-2"> uses firewall's
        interface <emphasis>"eth1"</emphasis> for translation. This
        means that only packets exiting through this interface will be
        translated; packets exiting through
        <emphasis>"eth2"</emphasis> will keep their original source
        address on the internal net.
      </para>

      <note><para> Interface object can be used in the NAT rules even
      if the address of this interface is obtained dynamically and is
      not known beforehand.  </para></note>

      <para>
	The rules on <xref linkend="f-nat-1"> , <xref
	linkend="f-nat-1-1"> and <xref linkend="f-nat-1-2"> provide
	address translation for packets, but to permit connections to
	the Internet a special Global Policy rule is needed. This rule
	simply permits all connections from internal network to "any"
	and should be placed somewhere close to the end of the policy,
	for example right on top of "catch all and log" rule.
      </para>


      <para>
	<figure id="f-nat-2">
	  <title>Rule #3 permits connections from internal network to the Internet
	(this rule is part of Global Policy)</title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="nat-2.png"
                  format="png" align="left" scale="50">
	    </imageobject>
	    <textobject>
	      <phrase>[Rule #3 permits connections from internal network to the Internet
	(this rule is part of Global Policy)]</phrase>
	    </textobject>
	  </mediaobject>
	</figure>
      </para>

    </sect1>


    <!-- ********************************************************* -->
    <sect1>
      <title>Server behind the firewall using address of the firewall for access</title>
 
      <para>
	Suppose we have a network using private IP addresses behind
	the firewall, and a web server on it. We need to provide
	access to this server from the Internet in a such way that
	connections will be established to the address of the
	firewall. In this case we need destination address of packets
	to be rewritten so packets would reach the server on internal
	network. Just like in the previous case we need one NAT rule
	to provide translation and one Global Policy rule to permit
	connecitons. <xref linkend="f-nat-3"> shows NAT rule we need:
      </para>

      <para>
	<figure id="f-nat-3">
	  <title>NAT rule for the server behind the firewall</title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="nat-3.png"
                  format="png" align="left" scale="50">
	    </imageobject>
	    <textobject>
	      <phrase>[NAT rule for the server behind the firewall]</phrase>
	    </textobject>
	  </mediaobject>
	</figure>
      </para>

      <para>
	Since we wanted to use address of the firewall's external
	interface to access the server, firewall's object is placed in
	"Original Destination" part of the rule. Server's object was
	placed in "Translated Destination" part of the rule so that
	original destination address of the packet will be replaced
	with server's address.
      </para>

      <para>
        Just like with masquerading rules, firewall with multiple
        external (or insecure) interfaces automatically uses all of
        them for this type of the NAT rule. Which one will actually be
        used for a particular packet depends on the routing that
        dictates which interface the packet enters the firewall
        through.  Firewall <emphasis>"fw2"</emphasis> on <xref
        linkend="f-nat-3-1"> has two external interfaces:
        <emphasis>"eth1"</emphasis> and <emphasis>"eth2"</emphasis>,
        both use routable IP addresses. NAT rule #1 provides
        translation for packets entering the firewall through either
        eth1 or eth2; in both cases destination address of the packet
        is going to be rewritten and packet will be sent to the server
        <emphasis>"hostA"</emphasis>.
      </para>

      <para>
	<figure id="f-nat-3-1">
	  <title>NAT rule for the server behind the firewall which has multiple insecure interfaces</title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="nat-3-1.png"
                  format="png" align="left" scale="50">
	    </imageobject>
	    <textobject>
	      <phrase></phrase>
	    </textobject>
	  </mediaobject>
	</figure>
      </para>


      <para>
        This may not have the desired effect in certain configurations
        though. One such case is when the second insecure
        interface<emphasis>"eth2"</emphasis> of the firewall is
        connected to a DMZ subnet using private addresses. The
        translation is not necessary for the packets going from DMZ to
        internal net and we are avoiding it by using firewall's
        external interface <emphasis>"eth1"</emphasis> instead of the
        firewall's object in the NAT rule #1 as shown in <xref
        linkend="f-nat-3-2">.
      </para>


      <para>
	<figure id="f-nat-3-2">
	  <title>NAT rule for the server behind the firewall, using interface object in the NAT rule</title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="nat-3-2.png"
                  format="png" align="left" scale="50">
	    </imageobject>
	    <textobject>
	      <phrase>[NAT rule for the server behind the firewall]</phrase>
	    </textobject>
	  </mediaobject>
	</figure>
      </para>



      <para>
	As before, we also need a Global Policy rule to permit
	connections to the server. This rule is shown on <xref
	linkend="f-nat-4">
      </para>

      <para>
	<figure id="f-nat-4">
	  <title>rule #0 permits access to the server (This rule is part of Global Policy)</title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="nat-4.png" format="png" align="left" scale="50">
	    </imageobject>
	    <textobject>
	      <phrase>[rule #0 permits access to the server (This rule is part of Global Policy)]</phrase>
	    </textobject>
	  </mediaobject>
	</figure>
      </para>

      <para> <xref linkend="f-nat-3-2"> also illustrates how
      configuration <xref linkend="f-nat-3"> could be combined with
      configuration <xref linkend="f-nat-1">. Such combination allows
      machines on the local network to go out to the Internet, and at
      the same time users on the Internet can access server located on
      the internal network - all using single IP address of the
      firewall's external interface! This configuration can be useful
      for those with cable or DSL connection and single IP address.
      </para>
    </sect1>


    <!-- ********************************************************* -->
    <sect1>
      <title>Server behind the firewall using virtual address for access</title>
      
      <para>
	Those who have more than one IP address allocated by their ISP
	may want to configure the firewall to map extra addresses to 
	different servers inside their network. This can be done using
	slightly different NAT rule.
      </para>

      <para>
       First of all, we add virtual addresses to appropriate interface
       of the firewall. See <xref linkend="creating-objects"> and
       <xref linkend="address-object"> for an explanation on how
       address can be added to the interface. Since our goal is to use
       these additional IP addresses for NAT, we will add them to the
       external interface of the firewall. <xref linkend="f-nat-5">
       shows firewall <emphasis>fw2</emphasis> with external interface
       <emphasis>eth1</emphasis> that has two IP addresses: 192.0.2.22
       and 192.2.0.44. These two addresses are represented by
       corresponding Address objects with names
       <emphasis>fw2:eth1(ip1)</emphasis> and
       <emphasis>fw2:eth1(ip2)</emphasis>. The choice of the name for
       the Address object is completely up to administrator, although
       we usually recommend our users choose descriptive names which
       can be easily recognized when objects are used in the policy
       and NAT rules.
      </para>

      <note> 
      <para>Firewall script created by Firewall Builder adds virtual
      addresses created in the GUI to the real interfaces of the
      firewall machine. This means that you do not need to configure
      these virtual addresses in two places - in the configuration of
      the firewall machine and in the GUI. Adding them in the GUI
      should be sufficient. Should you need to remove a virtual
      address, you just remove it in the GUI. It will be removed from
      the interface on the firewall machine when you run regenerated
      firewall script.  </para>

      <para>Firewall Builder uses appopriate command line utilities to
      add virtual addresses to interfaces depending on the OS the
      firewall runs on. For example, for the firewall running on Linux
      it uses <emphasis>/sbin/ip</emphasis> tool, while for the
      firewall running on FreeBSD or OpenBSD it uses
      <emphasis>ifconfig</emphasis>. Policy compilers that generate
      firewall script are aware not only of the names of tools that
      are available on the target OS, but also of the differences in
      the command line syntax specific to that OS.</para>
      </note>


      <para>
	<figure id="f-nat-5">
	  <title>Firewall has two IP addresses on its external interface eth1</title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="nat-5.png" 
                  format="png" align="left" scale="50">
	    </imageobject>
	    <textobject>
	      <phrase></phrase>
	    </textobject>
	  </mediaobject>
	</figure>
      </para>

      <para>
        <xref linkend="f-nat-5"> also shows how different addresses
        assigned to the firewall's external interface can be used for
        different purposes. NAT rule #0 uses address 192.0.2.22
        represented by the object <emphasis>fw2:eth1(ip1)</emphasis>
        for masquerading translation for machines on internal network
        trying to access services on the Internet. NAT rule #1 uses
        address 192.0.2.44 represented by the object
        <emphasis>fw2:eth1(ip2)</emphasis> to provide access to the
        server <emphasis>hostA</emphasis>. These two NAT rules are
        just like those explained in the previous two chapters, except
        they use Address objects instead of the Firewall or Interface
        objects.
      </para>


      <para>
	Finally we need a Global Policy rule to permit connections to
	the server. This rule looks exactly like that in the previous
	case - see <xref linkend="f-nat-4">
      </para>

    </sect1>


    <!-- ********************************************************* -->
    <sect1>
      <title>Server behind the firewall with port mapping</title>
 
      <para>
	This case is similar to two previous ones, except it
	illustrates how NAT rule can help change a port number besides
	of the address. This can be useful if server behind the
	firewall runs on some alternative port, yet we want to make it
	so that users would access it using another port when connect
	to it. For example, one could use it to provide access to the
	web server running on non-standard port #8080 by setting up
	translation of TCP ports to the standard one #80. This
	configuration can be combined with either one of the two
	above, that is translation can be done using either firewall's
	external interface address or some different address.
      </para>

      <para>
	This kind of translation works for both TCP and UDP services. 
      </para>

      <para>
	First of all, additional Service object needs to be created.
	Since our goal is to provide access to the web server running
	on TCP port #8080, we need to create a TCP Object with
	destination port equal to 8080. The source port number does
	not matter in this case, therefore we leave source port
	setting at zero in our new object. We also do not need to set
	any TCP flags since we are not going to build rules matching
	those. Basically, all we need is an object that defines
	destination port 8080. See <xref linkend="creating-objects">
	and <xref linkend="tcp-service"> for an explanation on how
	create and edit TCP Service object. <xref linkend="f-nat-7">
	illustrates this object's setup.
      </para>

      <para>
	<figure id="f-nat-7">
	  <title>TCP Service object for port tranlsation rule</title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="nat-7.png" format="png" align="left" scale="50">
	    </imageobject>
	    <textobject>
	      <phrase>[TCP Service object for port tranlsation rule]</phrase>
	    </textobject>
	  </mediaobject>
	</figure>
      </para>

      <para>
	Now we can create the rule, it would look just like previous
	translation rules except we put appropriate service objects in
	"Original Service" and "Translated Service" columns. see 
	<xref linkend="f-nat-8">
      </para>

      <para>
	<figure id="f-nat-8">
	  <title>NAT rule with port translation</title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="nat-8.png" format="png" align="left" scale="50">
	    </imageobject>
	    <textobject>
	      <phrase>[NAT rule with port translation]</phrase>
	    </textobject>
	  </mediaobject>
	</figure>
      </para>

      <para>
	Of course we need Global Policy rule as well to permit
	connections to our server. As described in <xref
	linkend="policies-and-rules">, Firewall Builder operates
	assuming policy rules are consulted after NAT. This means
	policy rule should use TCP Service object "tcp-8080" instead
	of "http". See <xref linkend="f-nat-9">
      </para>


      <para>
	<figure id="f-nat-9">
	  <title>Global Policy rule which permits access to the server</title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="nat-9.png" format="png" align="left" scale="50">
	    </imageobject>
	    <textobject>
	      <phrase>[Global Policy rule which permits access to the server]</phrase>
	    </textobject>
	  </mediaobject>
	</figure>
      </para>
      
    </sect1>

    <!-- ********************************************************* -->
    <sect1>
      <title>Destination NAT Onto the Same Network</title>
 
      <para>
	This situation is described in iptables HOWTO <ulink url="&ipt-howto">&ipt-howto</ulink>
      </para>

      <para>
	This problem occurs when machines on internal LAN try to
	access a server (let's say a web server) which is actually
	located on the same LAN and NAT'ed through the firewall for
	exaternal access. If internal users access it by its external
	NAT'ed address, then they send their TCP packets through the
	firewall, which translates them and sends them to the server
	on LAN. Server, however, replies back to the clients directly,
	because they are on the same network. Since the reply has
	server's real address in the source, clients do not recognize
	it and connection can not be established.
      </para>

      <para>
	To resolve this problem you need to add yet another NAT rule
	to the policy to force translation on packets going from
	clients to the server so that source address in these packets
	will be replaced with address of the firewall. In this case
	server will reply back to the firewall, which will translate
	again before sending back to the client. Client will see the
	address it expects and connection will get established. 
      </para>

      <para>
	In order to implement this rule we will use interface objects
	of the firewall as shown in <xref linkend="f-nat-11">.  Rule
	#0 is just a usual NAT rule that provides access to the web
	server from outside, while rule #1 adds source address
	translation and does the trick we want.  Firewall's interface
	<emphasis>eth0</emphasis> is internal and belongs to the same
	subnet the server <emphasis>hostA</emphasis> belongs to. For
	all packets going from hosts on
        <emphasis>internal_net</emphasis> to the server
        <emphasis>hostA</emphasis> rule #1 substitutes the source
        address with the address of interface
        <emphasis>eth0</emphasis>.  This makes the server reply back
        to the firewall, which in turn provides reverse translation
        before it sends these reply packets back to client hosts on
        <emphasis>internal_net</emphasis>
      </para>

      <para>
	<figure id="f-nat-11">
	  <title>DNAT back to the same LAN</title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="nat-11.png"
                  format="png" align="left" scale="50">
	    </imageobject>
	    <textobject>
	      <phrase>[DNAT back to the same LAN]</phrase>
	    </textobject>
	  </mediaobject>
	</figure>
      </para>

    </sect1>

    <!-- ********************************************************* -->
    <sect1>
      <title>"No NAT" rules</title>
 
      <para>Sometimes we need to instruct the firewall to do NAT for
      certain connections, but not for others. In other words, we need
      to set up a rule to define an exceptions for another NAT
      rule. For example, suppose firewall <emphasis>fw3</emphasis> has
      three interfaces: an external interface
      <emphasis>eth1</emphasis>, internal interface
      <emphasis>eth0</emphasis> and interface
      <emphasis>eth2</emphasis> connected to a DMZ subnet. Both
      internal net and DMZ use private IP addresses. Our goal is to
      provide NAT for both internal net and DMZ to be able to
      establish conenctions to hosts out on the Internet, but
      connections between internal net and DMZ should not be
      translated. This can be achieved using combination of rules
      shown in <xref linkend="f-nat-12">
      </para>

      <para>
	<figure id="f-nat-12">
	  <title>Example of no NAT rule</title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="nat-12.png"
                  format="png" align="left" scale="50">
	    </imageobject>
	    <textobject>
	      <phrase></phrase>
	    </textobject>
	  </mediaobject>
	</figure>
      </para>

      <para>
       Since both <emphasis>Translated Source</emphasis> and
       <emphasis>Translated Destination</emphasis> in the rule #0 are
       left <emphasis>Original</emphasis>, this rule says that
       connections from
      <emphasis>internal_net</emphasis> to
      <emphasis>dmz_net_1</emphasis> and from
      <emphasis>dmz_net_1</emphasis> to
      <emphasis>internal_net</emphasis> should not be translated.  The
      rule #1 is a usual masquerading type rule as described in
      previous chapters. The order of these two rules is important:
      the <emphasis>Original destination</emphasis> in the rule #1 is
      <emphasis>Any</emphasis>, which means connections from both
      <emphasis>internal_net</emphasis> and
      <emphasis>dmz_net_1</emphasis> to any host on any network should
      be translated. In order to exclude connections between
      <emphasis>internal_net</emphasis> and
      <emphasis>dmz_net_1</emphasis> from the rule #1, "no nat" rule
      #0 must be located above rule #1 so it would hit first.
      </para>

      <note>
        <para>The same effect can be achieved by using negation in the
        <emphasis>Original Destination</emphasis></para>
      </note>
    </sect1>


    <!-- ********************************************************* -->
    <sect1>
      <title>Redirecting the traffic</title>
 
      <para>
	This is a special case of NAT where packet's destination
	address gets changed to that of the firewall itself. This may
	be useful if you, for example, run transparent web proxy on
	the firewall box. The rule goes to NAT ruleset and should have
	firewall object in "Translated desination". Redirection rule
	may be combined with port mapping, so redirected packet will
	hit firewall on a different port.
      </para>
      
      <para>
	In a real policy this rule would have a specific port number
	in the "Original Service" to limit its scope to the protocol
	supported by the proxy server and will also be placed on top
	of other NAT rules dealing with the same source addresses so
	it would match first.  <xref linkend="f-nat-10"> shows
	redirection rule which bounces all HTTP connections opened by
	users on "internal_net" to the Squid proxy server running on
	the firewall box on port 3128.
      </para>

      <note><para> Squid needs to be configured as a transparent proxy
      or it won't work. Please see Squid documentation and FAQ for
      instructions.  </para></note>

      <para>
	<figure id="f-nat-10">
	  <title>Redirect rule</title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="nat-10.png"
                  format="png" align="left" scale="50">
	    </imageobject>
	    <textobject>
	      <phrase>[Redirect rule]</phrase>
	    </textobject>
	  </mediaobject>
	</figure>
      </para>

      <para>
	Note that for this setup to work a Global Policy rule is needed to
	permit HTTP requests made by Squid. These requests will originate from
	the firewall itself.
      </para>

    </sect1>

  </chapter>



</book>
